/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	const restify = __webpack_require__(1);
	class Hello {
	    constructor() {
	        this.logHello();
	    }
	    logHello() {
	        console.log("hello");
	    }
	}
	const hello = new Hello();


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.
	//
	// Restify supports both a client and server API, and in the essence of not
	// loading the kitchen sink on clients, the exports here is chunked up into
	// client and server; note clients will have to opt in by setting the env
	// var "RESTIFY_CLIENT_ONLY", but if you're in that boat, it's not hard to do,
	// and enables much faster load times
	//

	'use strict';

	var shallowCopy = __webpack_require__(3).shallowCopy;


	/**
	 * creates an http request client. based on options passed in, will create one
	 * of three existing clients: Http, String, or Json.
	 * @public
	 * @function createClient
	 * @param    {Object} options      an options object
	 * @param    {String} options.type 'http' | 'json' | 'string'
	 * @returns  {HttpClient | JsonClient | StringClient}
	 */
	function createClient(options) {
	    if (typeof (options) === 'string') {
	        options = {
	            url: options
	        };
	    }

	    var assert = __webpack_require__(4);
	    var bunyan = __webpack_require__(31);
	    var clients = __webpack_require__(74);

	    assert.object(options, 'options');

	    var client;
	    var opts = shallowCopy(options);
	    opts.agent = options.agent;
	    opts.name = opts.name || 'restify';
	    opts.type = opts.type || 'application/octet-stream';
	    opts.log = opts.log || bunyan.createLogger(opts.name);

	    switch (opts.type) {
	        case 'json':
	            client = new clients.JsonClient(opts);
	            break;

	        case 'string':
	            client = new clients.StringClient(opts);
	            break;

	        case 'http':
	        default:
	            client = new clients.HttpClient(opts);
	            break;
	    }

	    return (client);
	}


	/**
	 * creates a json httpclient.
	 * @public
	 * @function createJsonClient
	 * @param    {Object}     options an options object
	 * @returns  {JsonClient}         a json client
	 */
	function createJsonClient(options) {
	    if (typeof (options) === 'string') {
	        options = {
	            url: options
	        };
	    }

	    options = options ? shallowCopy(options) : {};
	    options.type = 'json';
	    return (createClient(options));
	}


	/**
	 * creates a string httpclient.
	 * @public
	 * @function createStringClient
	 * @param    {Object}       options an options object
	 * @returns  {StringClient}         a string client
	 */
	function createStringClient(options) {
	    if (typeof (options) === 'string') {
	        options = {
	            url: options
	        };
	    }

	    options = options ? shallowCopy(options) : {};
	    options.type = 'string';
	    return (createClient(options));
	}


	/**
	 * creates a regular httpclient.
	 * @public
	 * @function createHttpClient
	 * @param    {Object}     options an options object
	 * @returns  {HttpClient}         an http client
	 */
	function createHttpClient(options) {
	    if (typeof (options) === 'string') {
	        options = {
	            url: options
	        };
	    }

	    options = options ? shallowCopy(options) : {};
	    options.type = 'http';
	    return (createClient(options));
	}


	/**
	 * creates a server.
	 * @public
	 * @function createServer
	 * @param    {Object} options an options object
	 * @returns  {Server}
	 */
	function createServer(options) {
	    var bunyan = __webpack_require__(31);
	    var InternalError = __webpack_require__(105).InternalError;
	    var Router = __webpack_require__(129);
	    var Server = __webpack_require__(136);

	    var opts = shallowCopy(options || {});
	    var server;

	    opts.name = opts.name || 'restify';
	    opts.log = opts.log || bunyan.createLogger(opts.name);
	    opts.router = opts.router || new Router(opts);

	    server = new Server(opts);
	    server.on('uncaughtException', function (req, res, route, e) {
	        if (this.listeners('uncaughtException').length > 1 ||
	            res.headersSent) {
	            return (false);
	        }

	        res.send(new InternalError(e, e.message || 'unexpected error'));
	        return (true);
	    });

	    return (server);
	}


	/**
	 * Returns a string representation of a URL pattern , with its
	 * parameters filled in by the passed hash.
	 *
	 * If a key is not found in the hash for a param, it is left alone.
	 * @public
	 * @function realizeUrl
	 * @param   {String} pattern a url string
	 * @param   {Object} params  a hash of parameter names to values for
	 *                           substitution
	 * @returns {String}
	 */
	function realizeUrl(pattern, params) {
	    var p = pattern.replace(/\/:([^/]+)/g, function (match, k) {
	        return (params.hasOwnProperty(k) ? '/' + params[k] : match);
	    });


	    return (__webpack_require__(3).sanitizePath(p));
	}


	///--- Exports

	module.exports = {
	    // Client API
	    createClient: createClient,
	    createJsonClient: createJsonClient,
	    createJSONClient: createJsonClient,
	    createStringClient: createStringClient,
	    createHttpClient: createHttpClient,
	    get HttpClient() {
	        return (__webpack_require__(74).HttpClient);
	    },
	    get JsonClient() {
	        return (__webpack_require__(74).JsonClient);
	    },
	    get StringClient() {
	        return (__webpack_require__(74).StringClient);
	    },

	    // Miscellaneous API
	    get bunyan() {
	        return (__webpack_require__(31));
	    },

	    errors: {}

	};

	var errors = __webpack_require__(105);
	Object.keys(errors).forEach(function (k) {
	    module.exports.errors[k] = errors[k];
	    module.exports[k] = errors[k];
	});

	if (!process.env.RESTIFY_CLIENT_ONLY) {

	    module.exports.createServer = createServer;
	    module.exports.httpDate = __webpack_require__(208);
	    module.exports.realizeUrl = realizeUrl;
	    module.exports.formatters = __webpack_require__(200);
	    module.exports.plugins = {};
	    var plugins = __webpack_require__(209);
	    Object.keys(plugins).forEach(function (k) {
	        module.exports.plugins[k] = plugins[k];
	        module.exports[k] = plugins[k];
	    });
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);


	/**
	 * Cleans up sloppy URL paths, like /foo////bar/// to /foo/bar.
	 * @public
	 * @method  sanitizePath
	 * @param   {String} path the HTTP resource path.
	 * @returns {String}      Cleaned up form of path.
	 */
	function sanitizePath(path) {
	    assert.ok(path);

	    // Be nice like apache and strip out any //my//foo//bar///blah
	    path = path.replace(/\/\/+/g, '/');

	    // Kill a trailing '/'
	    if (path.lastIndexOf('/') === (path.length - 1) && path.length > 1) {
	        path = path.substr(0, path.length - 1);
	    }

	    return (path);
	}


	/**
	 * Return a shallow copy of the given object;
	 * @public
	 * @method  shallowCopy
	 * @param   {Object} obj the object to copy
	 * @returns {Object}     the new copy of the object
	 */
	function shallowCopy(obj) {
	    if (!obj) {
	        return (obj);
	    }
	    var copy = {};
	    Object.keys(obj).forEach(function (k) {
	        copy[k] = obj[k];
	    });
	    return (copy);
	}


	/**
	 * Merges two query parameter objects. Merges to array
	 * if the same key is encountered.
	 * @public
	 * @method  mergeQs
	 * @param   {Object} obj1 first qs object
	 * @param   {Object} obj2 second qs object
	 * @returns {Object}      the merged object
	 */
	function mergeQs(obj1, obj2) {

	    var merged = shallowCopy(obj1) || {};

	    // defend against null cause null is an object. yay js.
	    if (obj2 && typeof (obj2) === 'object') {
	        Object.keys(obj2).forEach(function (key) {
	            // if we already have this key and it isn't an array,
	            // make it one array of the same element.
	            if (merged.hasOwnProperty(key) && !(merged[key] instanceof Array)) {
	                merged[key] = [merged[key]];

	                // push the new value down
	                merged[key].push(obj2[key]);
	            } else {
	                // otherwise just set it
	                merged[key] = obj2[key];
	            }
	        });
	    }

	    return (merged);
	}


	///--- Exports

	module.exports = {
	    sanitizePath: sanitizePath,
	    shallowCopy: shallowCopy,
	    mergeQs: mergeQs
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {// Copyright (c) 2012, Mark Cavage. All rights reserved.

	var assert = __webpack_require__(9);
	var Stream = __webpack_require__(13).Stream;
	var util = __webpack_require__(10);



	///--- Globals

	var NDEBUG = process.env.NODE_NDEBUG || false;
	var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;



	///--- Messages

	var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
	var TYPE_REQUIRED = '%s (%s) is required';



	///--- Internal

	function capitalize(str) {
	        return (str.charAt(0).toUpperCase() + str.slice(1));
	}

	function uncapitalize(str) {
	        return (str.charAt(0).toLowerCase() + str.slice(1));
	}

	function _() {
	        return (util.format.apply(util, arguments));
	}


	function _assert(arg, type, name, stackFunc) {
	        if (!NDEBUG) {
	                name = name || type;
	                stackFunc = stackFunc || _assert.caller;
	                var t = typeof (arg);

	                if (t !== type) {
	                        throw new assert.AssertionError({
	                                message: _(TYPE_REQUIRED, name, type),
	                                actual: t,
	                                expected: type,
	                                operator: '===',
	                                stackStartFunction: stackFunc
	                        });
	                }
	        }
	}


	function _instanceof(arg, type, name, stackFunc) {
	        if (!NDEBUG) {
	                name = name || type;
	                stackFunc = stackFunc || _instanceof.caller;

	                if (!(arg instanceof type)) {
	                        throw new assert.AssertionError({
	                                message: _(TYPE_REQUIRED, name, type.name),
	                                actual: _getClass(arg),
	                                expected: type.name,
	                                operator: 'instanceof',
	                                stackStartFunction: stackFunc
	                        });
	                }
	        }
	}

	function _getClass(object) {
	        return (Object.prototype.toString.call(object).slice(8, -1));
	};



	///--- API

	function array(arr, type, name) {
	        if (!NDEBUG) {
	                name = name || type;

	                if (!Array.isArray(arr)) {
	                        throw new assert.AssertionError({
	                                message: _(ARRAY_TYPE_REQUIRED, name, type),
	                                actual: typeof (arr),
	                                expected: 'array',
	                                operator: 'Array.isArray',
	                                stackStartFunction: array.caller
	                        });
	                }

	                for (var i = 0; i < arr.length; i++) {
	                        _assert(arr[i], type, name, array);
	                }
	        }
	}


	function bool(arg, name) {
	        _assert(arg, 'boolean', name, bool);
	}


	function buffer(arg, name) {
	        if (!Buffer.isBuffer(arg)) {
	                throw new assert.AssertionError({
	                        message: _(TYPE_REQUIRED, name || '', 'Buffer'),
	                        actual: typeof (arg),
	                        expected: 'buffer',
	                        operator: 'Buffer.isBuffer',
	                        stackStartFunction: buffer
	                });
	        }
	}


	function func(arg, name) {
	        _assert(arg, 'function', name);
	}


	function number(arg, name) {
	        _assert(arg, 'number', name);
	        if (!NDEBUG && (isNaN(arg) || !isFinite(arg))) {
	                throw new assert.AssertionError({
	                        message: _(TYPE_REQUIRED, name, 'number'),
	                        actual: arg,
	                        expected: 'number',
	                        operator: 'isNaN',
	                        stackStartFunction: number
	                });
	        }
	}


	function object(arg, name) {
	        _assert(arg, 'object', name);
	}


	function stream(arg, name) {
	        _instanceof(arg, Stream, name);
	}


	function date(arg, name) {
	        _instanceof(arg, Date, name);
	}

	function regexp(arg, name) {
	        _instanceof(arg, RegExp, name);
	}


	function string(arg, name) {
	        _assert(arg, 'string', name);
	}


	function uuid(arg, name) {
	        string(arg, name);
	        if (!NDEBUG && !UUID_REGEXP.test(arg)) {
	                throw new assert.AssertionError({
	                        message: _(TYPE_REQUIRED, name, 'uuid'),
	                        actual: 'string',
	                        expected: 'uuid',
	                        operator: 'test',
	                        stackStartFunction: uuid
	                });
	        }
	}


	///--- Exports

	module.exports = {
	        bool: bool,
	        buffer: buffer,
	        date: date,
	        func: func,
	        number: number,
	        object: object,
	        regexp: regexp,
	        stream: stream,
	        string: string,
	        uuid: uuid
	};


	Object.keys(module.exports).forEach(function (k) {
	        if (k === 'buffer')
	                return;

	        var name = 'arrayOf' + capitalize(k);

	        if (k === 'bool')
	                k = 'boolean';
	        if (k === 'func')
	                k = 'function';
	        module.exports[name] = function (arg, name) {
	                array(arg, k, name);
	        };
	});

	Object.keys(module.exports).forEach(function (k) {
	        var _name = 'optional' + capitalize(k);
	        var s = uncapitalize(k.replace('arrayOf', ''));
	        if (s === 'bool')
	                s = 'boolean';
	        if (s === 'func')
	                s = 'function';

	        if (k.indexOf('arrayOf') !== -1) {
	          module.exports[_name] = function (arg, name) {
	                  if (!NDEBUG && arg !== undefined) {
	                          array(arg, s, name);
	                  }
	          };
	        } else {
	          module.exports[_name] = function (arg, name) {
	                  if (!NDEBUG && arg !== undefined) {
	                          _assert(arg, s, name);
	                  }
	          };
	        }
	});


	// Reexport built-in assertions
	Object.keys(assert).forEach(function (k) {
	        if (k === 'AssertionError') {
	                module.exports[k] = assert[k];
	                return;
	        }

	        module.exports[k] = function () {
	                if (!NDEBUG) {
	                        assert[k].apply(assert[k], arguments);
	                }
	        };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(5).Buffer))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(6)
	var ieee754 = __webpack_require__(7)
	var isArray = __webpack_require__(8)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict'

	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	function init () {
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i]
	    revLookup[code.charCodeAt(i)] = i
	  }

	  revLookup['-'.charCodeAt(0)] = 62
	  revLookup['_'.charCodeAt(0)] = 63
	}

	init()

	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 8 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __webpack_require__(10);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function(err) { if (err) throw err; };

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(11);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(12);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 12 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(14).EventEmitter;
	var inherits = __webpack_require__(15);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(16);
	Stream.Writable = __webpack_require__(27);
	Stream.Duplex = __webpack_require__(28);
	Stream.Transform = __webpack_require__(29);
	Stream.PassThrough = __webpack_require__(30);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(17);
	exports.Stream = __webpack_require__(13);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(23);
	exports.Duplex = __webpack_require__(22);
	exports.Transform = __webpack_require__(25);
	exports.PassThrough = __webpack_require__(26);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(13);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(18);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(5).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(14).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(13);

	/*<replacement>*/
	var util = __webpack_require__(19);
	util.inherits = __webpack_require__(20);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(21);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(22);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(24).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(22);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(24).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 20 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 21 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(19);
	util.inherits = __webpack_require__(20);
	/*</replacement>*/

	var Readable = __webpack_require__(17);
	var Writable = __webpack_require__(23);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(5).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(19);
	util.inherits = __webpack_require__(20);
	/*</replacement>*/

	var Stream = __webpack_require__(13);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(22);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(22);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(5).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(22);

	/*<replacement>*/
	var util = __webpack_require__(19);
	util.inherits = __webpack_require__(20);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(25);

	/*<replacement>*/
	var util = __webpack_require__(19);
	util.inherits = __webpack_require__(20);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(23)


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(22)


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(25)


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(26)


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var Stream = __webpack_require__(13).Stream;
	var util = __webpack_require__(10);

	var assert = __webpack_require__(4);
	var bunyan = __webpack_require__(32);
	var LRU = __webpack_require__(54);
	var uuid = __webpack_require__(58);


	///--- Globals

	var sprintf = util.format;
	var DEFAULT_REQ_ID = uuid.v4();
	var STR_FMT = '[object %s<level=%d, limit=%d, maxRequestIds=%d>]';


	///--- Helpers

	/**
	 * appends streams
	 * @private
	 * @function appendStream
	 * @param    {Stream}    streams the stream to append to
	 * @param    {Stream}    s       the stream to append
	 * @returns  {undefined}
	 */
	function appendStream(streams, s) {
	    assert.arrayOfObject(streams, 'streams');
	    assert.object(s, 'stream');

	    if (s instanceof Stream) {
	        streams.push({
	            raw: false,
	            stream: s
	        });
	    } else {
	        assert.optionalBool(s.raw, 'stream.raw');
	        assert.object(s.stream, 'stream.stream');
	        streams.push(s);
	    }
	}


	///--- API
	/**
	 * A Bunyan stream to capture records in a ring buffer and only pass through
	 * on a higher-level record. E.g. buffer up all records but only dump when
	 * getting a WARN or above.
	 * @public
	 * @class
	 * @param {Object} opts                contains the parameters:
	 * @param {Object} opts.stream         The stream to which to write when
	 *                                     dumping captured records. One of `stream`
	 *                                     or `streams` must be specified.
	 * @param {Array} opts.streams         One of `stream` or `streams` must be
	 *                                     specified.
	 * @param {Number | String} opts.level The level at which to trigger dumping
	 *                                     captured records. Defaults to
	 *                                     bunyan.WARN.
	 * @param {Number} opts.maxRecords     Number of records to capture. Default
	 *                                     100.
	 * @param {Number} opts.maxRequestIds  Number of simultaneous request id
	 *                                     capturing buckets to maintain. Default
	 *                                     1000.
	 * @param {Boolean} opts.dumpDefault   If true, then dump captured records on
	 *                                     the *default* request id when dumping.
	 *                                     I.e. dump records logged without
	 *                                     "req_id" field. Default false.
	 */
	function RequestCaptureStream(opts) {
	    assert.object(opts, 'options');
	    assert.optionalObject(opts.stream, 'options.stream');
	    assert.optionalArrayOfObject(opts.streams, 'options.streams');
	    assert.optionalNumber(opts.level, 'options.level');
	    assert.optionalNumber(opts.maxRecords, 'options.maxRecords');
	    assert.optionalNumber(opts.maxRequestIds, 'options.maxRequestIds');
	    assert.optionalBool(opts.dumpDefault, 'options.dumpDefault');

	    var self = this;
	    Stream.call(this);

	    this.level = opts.level ? bunyan.resolveLevel(opts.level) : bunyan.WARN;
	    this.limit = opts.maxRecords || 100;
	    this.maxRequestIds = opts.maxRequestIds || 1000;
	    this.requestMap = LRU({
	        max: self.maxRequestIds
	    });
	    this.dumpDefault = opts.dumpDefault;

	    this._offset = -1;
	    this._rings = [];

	    this.streams = [];

	    if (opts.stream) {
	        appendStream(this.streams, opts.stream);
	    }

	    if (opts.streams) {
	        opts.streams.forEach(appendStream.bind(null, this.streams));
	    }

	    this.haveNonRawStreams = false;

	    for (var i = 0; i < this.streams.length; i++) {
	        if (!this.streams[i].raw) {
	            this.haveNonRawStreams = true;
	            break;
	        }
	    }
	}
	util.inherits(RequestCaptureStream, Stream);


	/**
	 * write to the stream
	 * @public
	 * @function write
	 * @param    {Object}    record a bunyan log record
	 * @returns  {undefined}
	 */
	RequestCaptureStream.prototype.write = function write(record) {
	    var req_id = record.req_id || DEFAULT_REQ_ID;
	    var ring;
	    var self = this;

	    if (!(ring = this.requestMap.get(req_id))) {
	        if (++this._offset > this.maxRequestIds) {
	            this._offset = 0;
	        }

	        if (this._rings.length <= this._offset) {
	            this._rings.push(new bunyan.RingBuffer({
	                limit: self.limit
	            }));
	        }

	        ring = this._rings[this._offset];
	        ring.records.length = 0;
	        this.requestMap.set(req_id, ring);
	    }

	    assert.ok(ring, 'no ring found');

	    if (record.level >= this.level) {
	        var i, r, ser;

	        for (i = 0; i < ring.records.length; i++) {
	            r = ring.records[i];

	            if (this.haveNonRawStreams) {
	                ser = JSON.stringify(r,
	                    bunyan.safeCycles()) + '\n';
	            }
	            self.streams.forEach(function (s) {
	                s.stream.write(s.raw ? r : ser);
	            });
	        }
	        ring.records.length = 0;

	        if (this.dumpDefault) {
	            var defaultRing = self.requestMap.get(DEFAULT_REQ_ID);

	            for (i = 0; i < defaultRing.records.length; i++) {
	                r = defaultRing.records[i];

	                if (this.haveNonRawStreams) {
	                    ser = JSON.stringify(r,
	                        bunyan.safeCycles()) + '\n';
	                }
	                self.streams.forEach(function (s) {
	                    s.stream.write(s.raw ? r : ser);
	                });
	            }
	            defaultRing.records.length = 0;
	        }
	    } else {
	        ring.write(record);
	    }
	};


	/**
	 * toString() serialization
	 * @public
	 * @function toString
	 * @returns  {String}
	 */
	RequestCaptureStream.prototype.toString = function toString() {
	    return (sprintf(STR_FMT,
	        this.constructor.name,
	        this.level,
	        this.limit,
	        this.maxRequestIds));
	};


	///--- Serializers

	var SERIALIZERS = {
	    err: bunyan.stdSerializers.err,
	    req: bunyan.stdSerializers.req,
	    res: bunyan.stdSerializers.res,
	    client_req: clientReq,
	    client_res: clientRes
	};


	/**
	 * a request serializer. returns a stripped down object for logging.
	 * @private
	 * @function clientReq
	 * @param    {Object} req the request object
	 * @returns  {Object}
	 */
	function clientReq(req) {
	    if (!req) {
	        return (req);
	    }

	    var host;

	    try {
	        host = req.host.split(':')[0];
	    } catch (e) {
	        host = false;
	    }

	    return ({
	        method: req ? req.method : false,
	        url: req ? req.path : false,
	        address: host,
	        port: req ? req.port : false,
	        headers: req ? req.headers : false
	    });
	}


	/**
	 * a response serializer. returns a stripped down object for logging.
	 * @private
	 * @function clientRes
	 * @param    {Object} res the response object
	 * @returns  {Object}
	 */
	function clientRes(res) {
	    if (!res || !res.statusCode) {
	        return (res);
	    }

	    return ({
	        statusCode: res.statusCode,
	        headers: res.headers
	    });
	}


	/**
	 * create a bunyan logger
	 * @public
	 * @function createLogger
	 * @param    {String}     name of the logger
	 * @returns  {Object}          bunyan logger
	 */
	function createLogger(name) {
	    return (bunyan.createLogger({
	        name: name,
	        serializers: SERIALIZERS,
	        streams: [
	            {
	                level: 'warn',
	                stream: process.stderr
	            },
	            {
	                level: 'debug',
	                type: 'raw',
	                stream: new RequestCaptureStream({
	                    stream: process.stderr
	                })
	            }
	        ]
	    }));
	}



	///--- Exports

	module.exports = {
	    RequestCaptureStream: RequestCaptureStream,
	    serializers: SERIALIZERS,
	    createLogger: createLogger

	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {/**
	 * Copyright (c) 2015 Trent Mick.
	 * Copyright (c) 2015 Joyent Inc.
	 *
	 * The bunyan logging library for node.js.
	 *
	 * -*- mode: js -*-
	 * vim: expandtab:ts=4:sw=4
	 */

	var VERSION = '1.8.4';

	/*
	 * Bunyan log format version. This becomes the 'v' field on all log records.
	 * This will be incremented if there is any backward incompatible change to
	 * the log record format. Details will be in 'CHANGES.md' (the change log).
	 */
	var LOG_VERSION = 0;


	var xxx = function xxx(s) {     // internal dev/debug logging
	    var args = ['XX' + 'X: '+s].concat(
	        Array.prototype.slice.call(arguments, 1));
	    console.error.apply(this, args);
	};
	var xxx = function xxx() {};  // comment out to turn on debug logging


	/*
	 * Runtime environment notes:
	 *
	 * Bunyan is intended to run in a number of runtime environments. Here are
	 * some notes on differences for those envs and how the code copes.
	 *
	 * - node.js: The primary target environment.
	 * - NW.js: http://nwjs.io/  An *app* environment that feels like both a
	 *   node env -- it has node-like globals (`process`, `global`) and
	 *   browser-like globals (`window`, `navigator`). My *understanding* is that
	 *   bunyan can operate as if this is vanilla node.js.
	 * - browser: Failing the above, we sniff using the `window` global
	 *   <https://developer.mozilla.org/en-US/docs/Web/API/Window/window>.
	 *      - browserify: http://browserify.org/  A browser-targetting bundler of
	 *        node.js deps. The runtime is a browser env, so can't use fs access,
	 *        etc. Browserify's build looks for `require(<single-string>)` imports
	 *        to bundle. For some imports it won't be able to handle, we "hide"
	 *        from browserify with `require('frobshizzle' + '')`.
	 * - Other? Please open issues if things are broken.
	 */
	var runtimeEnv;
	if (typeof (process) !== 'undefined' && process.versions) {
	    if (process.versions.nw) {
	        runtimeEnv = 'nw';
	    } else if (process.versions.node) {
	        runtimeEnv = 'node';
	    }
	}
	if (!runtimeEnv && typeof (window) !== 'undefined' &&
	    window.window === window) {
	    runtimeEnv = 'browser';
	}
	if (!runtimeEnv) {
	    throw new Error('unknown runtime environment');
	}


	var os, fs, dtrace;
	if (runtimeEnv === 'browser') {
	    os = {
	        hostname: function () {
	            return window.location.host;
	        }
	    };
	    fs = {};
	    dtrace = null;
	} else {
	    os = __webpack_require__(33);
	    fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	    try {
	        dtrace = __webpack_require__(34);
	    } catch (e) {
	        dtrace = null;
	    }
	}
	var util = __webpack_require__(10);
	var assert = __webpack_require__(9);
	var EventEmitter = __webpack_require__(14).EventEmitter;
	var stream = __webpack_require__(13);

	try {
	    var safeJsonStringify = __webpack_require__(35);
	} catch (e) {
	    safeJsonStringify = null;
	}
	if (process.env.BUNYAN_TEST_NO_SAFE_JSON_STRINGIFY) {
	    safeJsonStringify = null;
	}

	// The 'mv' module is required for rotating-file stream support.
	try {
	    var mv = __webpack_require__(36);
	} catch (e) {
	    mv = null;
	}

	try {
	    var sourceMapSupport = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"source-map-support\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	} catch (_) {
	    sourceMapSupport = null;
	}


	//---- Internal support stuff

	/**
	 * A shallow copy of an object. Bunyan logging attempts to never cause
	 * exceptions, so this function attempts to handle non-objects gracefully.
	 */
	function objCopy(obj) {
	    if (obj == null) {  // null or undefined
	        return obj;
	    } else if (Array.isArray(obj)) {
	        return obj.slice();
	    } else if (typeof (obj) === 'object') {
	        var copy = {};
	        Object.keys(obj).forEach(function (k) {
	            copy[k] = obj[k];
	        });
	        return copy;
	    } else {
	        return obj;
	    }
	}

	var format = util.format;
	if (!format) {
	    // If node < 0.6, then use its `util.format`:
	    // <https://github.com/joyent/node/blob/master/lib/util.js#L22>:
	    var inspect = util.inspect;
	    var formatRegExp = /%[sdj%]/g;
	    format = function format(f) {
	        if (typeof (f) !== 'string') {
	            var objects = [];
	            for (var i = 0; i < arguments.length; i++) {
	                objects.push(inspect(arguments[i]));
	            }
	            return objects.join(' ');
	        }

	        var i = 1;
	        var args = arguments;
	        var len = args.length;
	        var str = String(f).replace(formatRegExp, function (x) {
	            if (i >= len)
	                return x;
	            switch (x) {
	                case '%s': return String(args[i++]);
	                case '%d': return Number(args[i++]);
	                case '%j': return JSON.stringify(args[i++], safeCycles());
	                case '%%': return '%';
	                default:
	                    return x;
	            }
	        });
	        for (var x = args[i]; i < len; x = args[++i]) {
	            if (x === null || typeof (x) !== 'object') {
	                str += ' ' + x;
	            } else {
	                str += ' ' + inspect(x);
	            }
	        }
	        return str;
	    };
	}


	/**
	 * Gather some caller info 3 stack levels up.
	 * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.
	 */
	function getCaller3Info() {
	    if (this === undefined) {
	        // Cannot access caller info in 'strict' mode.
	        return;
	    }
	    var obj = {};
	    var saveLimit = Error.stackTraceLimit;
	    var savePrepare = Error.prepareStackTrace;
	    Error.stackTraceLimit = 3;

	    Error.prepareStackTrace = function (_, stack) {
	        var caller = stack[2];
	        if (sourceMapSupport) {
	            caller = sourceMapSupport.wrapCallSite(caller);
	        }
	        obj.file = caller.getFileName();
	        obj.line = caller.getLineNumber();
	        var func = caller.getFunctionName();
	        if (func)
	            obj.func = func;
	    };
	    Error.captureStackTrace(this, getCaller3Info);
	    this.stack;

	    Error.stackTraceLimit = saveLimit;
	    Error.prepareStackTrace = savePrepare;
	    return obj;
	}


	function _indent(s, indent) {
	    if (!indent) indent = '    ';
	    var lines = s.split(/\r?\n/g);
	    return indent + lines.join('\n' + indent);
	}


	/**
	 * Warn about an bunyan processing error.
	 *
	 * @param msg {String} Message with which to warn.
	 * @param dedupKey {String} Optional. A short string key for this warning to
	 *      have its warning only printed once.
	 */
	function _warn(msg, dedupKey) {
	    assert.ok(msg);
	    if (dedupKey) {
	        if (_warned[dedupKey]) {
	            return;
	        }
	        _warned[dedupKey] = true;
	    }
	    process.stderr.write(msg + '\n');
	}
	function _haveWarned(dedupKey) {
	    return _warned[dedupKey];
	}
	var _warned = {};


	function ConsoleRawStream() {}
	ConsoleRawStream.prototype.write = function (rec) {
	    if (rec.level < INFO) {
	        console.log(rec);
	    } else if (rec.level < WARN) {
	        console.info(rec);
	    } else if (rec.level < ERROR) {
	        console.warn(rec);
	    } else {
	        console.error(rec);
	    }
	};


	//---- Levels

	var TRACE = 10;
	var DEBUG = 20;
	var INFO = 30;
	var WARN = 40;
	var ERROR = 50;
	var FATAL = 60;

	var levelFromName = {
	    'trace': TRACE,
	    'debug': DEBUG,
	    'info': INFO,
	    'warn': WARN,
	    'error': ERROR,
	    'fatal': FATAL
	};
	var nameFromLevel = {};
	Object.keys(levelFromName).forEach(function (name) {
	    nameFromLevel[levelFromName[name]] = name;
	});

	// Dtrace probes.
	var dtp = undefined;
	var probes = dtrace && {};

	/**
	 * Resolve a level number, name (upper or lowercase) to a level number value.
	 *
	 * @param nameOrNum {String|Number} A level name (case-insensitive) or positive
	 *      integer level.
	 * @api public
	 */
	function resolveLevel(nameOrNum) {
	    var level;
	    var type = typeof (nameOrNum);
	    if (type === 'string') {
	        level = levelFromName[nameOrNum.toLowerCase()];
	        if (!level) {
	            throw new Error(format('unknown level name: "%s"', nameOrNum));
	        }
	    } else if (type !== 'number') {
	        throw new TypeError(format('cannot resolve level: invalid arg (%s):',
	            type, nameOrNum));
	    } else if (nameOrNum < 0 || Math.floor(nameOrNum) !== nameOrNum) {
	        throw new TypeError(format('level is not a positive integer: %s',
	            nameOrNum));
	    } else {
	        level = nameOrNum;
	    }
	    return level;
	}


	function isWritable(obj) {
	    if (obj instanceof stream.Writable) {
	        return true;
	    }
	    return typeof (obj.write) === 'function';
	}


	//---- Logger class

	/**
	 * Create a Logger instance.
	 *
	 * @param options {Object} See documentation for full details. At minimum
	 *    this must include a 'name' string key. Configuration keys:
	 *      - `streams`: specify the logger output streams. This is an array of
	 *        objects with these fields:
	 *          - `type`: The stream type. See README.md for full details.
	 *            Often this is implied by the other fields. Examples are
	 *            'file', 'stream' and "raw".
	 *          - `level`: Defaults to 'info'.
	 *          - `path` or `stream`: The specify the file path or writeable
	 *            stream to which log records are written. E.g.
	 *            `stream: process.stdout`.
	 *          - `closeOnExit` (boolean): Optional. Default is true for a
	 *            'file' stream when `path` is given, false otherwise.
	 *        See README.md for full details.
	 *      - `level`: set the level for a single output stream (cannot be used
	 *        with `streams`)
	 *      - `stream`: the output stream for a logger with just one, e.g.
	 *        `process.stdout` (cannot be used with `streams`)
	 *      - `serializers`: object mapping log record field names to
	 *        serializing functions. See README.md for details.
	 *      - `src`: Boolean (default false). Set true to enable 'src' automatic
	 *        field with log call source info.
	 *    All other keys are log record fields.
	 *
	 * An alternative *internal* call signature is used for creating a child:
	 *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);
	 *
	 * @param _childSimple (Boolean) An assertion that the given `_childOptions`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation.
	 */
	function Logger(options, _childOptions, _childSimple) {
	    xxx('Logger start:', options)
	    if (!(this instanceof Logger)) {
	        return new Logger(options, _childOptions);
	    }

	    // Input arg validation.
	    var parent;
	    if (_childOptions !== undefined) {
	        parent = options;
	        options = _childOptions;
	        if (!(parent instanceof Logger)) {
	            throw new TypeError(
	                'invalid Logger creation: do not pass a second arg');
	        }
	    }
	    if (!options) {
	        throw new TypeError('options (object) is required');
	    }
	    if (!parent) {
	        if (!options.name) {
	            throw new TypeError('options.name (string) is required');
	        }
	    } else {
	        if (options.name) {
	            throw new TypeError(
	                'invalid options.name: child cannot set logger name');
	        }
	    }
	    if (options.stream && options.streams) {
	        throw new TypeError('cannot mix "streams" and "stream" options');
	    }
	    if (options.streams && !Array.isArray(options.streams)) {
	        throw new TypeError('invalid options.streams: must be an array')
	    }
	    if (options.serializers && (typeof (options.serializers) !== 'object' ||
	            Array.isArray(options.serializers))) {
	        throw new TypeError('invalid options.serializers: must be an object')
	    }

	    EventEmitter.call(this);

	    // Fast path for simple child creation.
	    if (parent && _childSimple) {
	        // `_isSimpleChild` is a signal to stream close handling that this child
	        // owns none of its streams.
	        this._isSimpleChild = true;

	        this._level = parent._level;
	        this.streams = parent.streams;
	        this.serializers = parent.serializers;
	        this.src = parent.src;
	        var fields = this.fields = {};
	        var parentFieldNames = Object.keys(parent.fields);
	        for (var i = 0; i < parentFieldNames.length; i++) {
	            var name = parentFieldNames[i];
	            fields[name] = parent.fields[name];
	        }
	        var names = Object.keys(options);
	        for (var i = 0; i < names.length; i++) {
	            var name = names[i];
	            fields[name] = options[name];
	        }
	        return;
	    }

	    // Start values.
	    var self = this;
	    if (parent) {
	        this._level = parent._level;
	        this.streams = [];
	        for (var i = 0; i < parent.streams.length; i++) {
	            var s = objCopy(parent.streams[i]);
	            s.closeOnExit = false; // Don't own parent stream.
	            this.streams.push(s);
	        }
	        this.serializers = objCopy(parent.serializers);
	        this.src = parent.src;
	        this.fields = objCopy(parent.fields);
	        if (options.level) {
	            this.level(options.level);
	        }
	    } else {
	        this._level = Number.POSITIVE_INFINITY;
	        this.streams = [];
	        this.serializers = null;
	        this.src = false;
	        this.fields = {};
	    }

	    if (!dtp && dtrace) {
	        dtp = dtrace.createDTraceProvider('bunyan');

	        for (var level in levelFromName) {
	            var probe;

	            probes[levelFromName[level]] = probe =
	                dtp.addProbe('log-' + level, 'char *');

	            // Explicitly add a reference to dtp to prevent it from being GC'd
	            probe.dtp = dtp;
	        }

	        dtp.enable();
	    }

	    // Handle *config* options (i.e. options that are not just plain data
	    // for log records).
	    if (options.stream) {
	        self.addStream({
	            type: 'stream',
	            stream: options.stream,
	            closeOnExit: false,
	            level: options.level
	        });
	    } else if (options.streams) {
	        options.streams.forEach(function (s) {
	            self.addStream(s, options.level);
	        });
	    } else if (parent && options.level) {
	        this.level(options.level);
	    } else if (!parent) {
	        if (runtimeEnv === 'browser') {
	            /*
	             * In the browser we'll be emitting to console.log by default.
	             * Any console.log worth its salt these days can nicely render
	             * and introspect objects (e.g. the Firefox and Chrome console)
	             * so let's emit the raw log record. Are there browsers for which
	             * that breaks things?
	             */
	            self.addStream({
	                type: 'raw',
	                stream: new ConsoleRawStream(),
	                closeOnExit: false,
	                level: options.level
	            });
	        } else {
	            self.addStream({
	                type: 'stream',
	                stream: process.stdout,
	                closeOnExit: false,
	                level: options.level
	            });
	        }
	    }
	    if (options.serializers) {
	        self.addSerializers(options.serializers);
	    }
	    if (options.src) {
	        this.src = true;
	    }
	    xxx('Logger: ', self)

	    // Fields.
	    // These are the default fields for log records (minus the attributes
	    // removed in this constructor). To allow storing raw log records
	    // (unrendered), `this.fields` must never be mutated. Create a copy for
	    // any changes.
	    var fields = objCopy(options);
	    delete fields.stream;
	    delete fields.level;
	    delete fields.streams;
	    delete fields.serializers;
	    delete fields.src;
	    if (this.serializers) {
	        this._applySerializers(fields);
	    }
	    if (!fields.hostname && !self.fields.hostname) {
	        fields.hostname = os.hostname();
	    }
	    if (!fields.pid) {
	        fields.pid = process.pid;
	    }
	    Object.keys(fields).forEach(function (k) {
	        self.fields[k] = fields[k];
	    });
	}

	util.inherits(Logger, EventEmitter);


	/**
	 * Add a stream
	 *
	 * @param stream {Object}. Object with these fields:
	 *    - `type`: The stream type. See README.md for full details.
	 *      Often this is implied by the other fields. Examples are
	 *      'file', 'stream' and "raw".
	 *    - `path` or `stream`: The specify the file path or writeable
	 *      stream to which log records are written. E.g.
	 *      `stream: process.stdout`.
	 *    - `level`: Optional. Falls back to `defaultLevel`.
	 *    - `closeOnExit` (boolean): Optional. Default is true for a
	 *      'file' stream when `path` is given, false otherwise.
	 *    See README.md for full details.
	 * @param defaultLevel {Number|String} Optional. A level to use if
	 *      `stream.level` is not set. If neither is given, this defaults to INFO.
	 */
	Logger.prototype.addStream = function addStream(s, defaultLevel) {
	    var self = this;
	    if (defaultLevel === null || defaultLevel === undefined) {
	        defaultLevel = INFO;
	    }

	    s = objCopy(s);

	    // Implicit 'type' from other args.
	    if (!s.type) {
	        if (s.stream) {
	            s.type = 'stream';
	        } else if (s.path) {
	            s.type = 'file'
	        }
	    }
	    s.raw = (s.type === 'raw');  // PERF: Allow for faster check in `_emit`.

	    if (s.level !== undefined) {
	        s.level = resolveLevel(s.level);
	    } else {
	        s.level = resolveLevel(defaultLevel);
	    }
	    if (s.level < self._level) {
	        self._level = s.level;
	    }

	    switch (s.type) {
	    case 'stream':
	        assert.ok(isWritable(s.stream),
	                  '"stream" stream is not writable: ' + util.inspect(s.stream));

	        if (!s.closeOnExit) {
	            s.closeOnExit = false;
	        }
	        break;
	    case 'file':
	        if (s.reemitErrorEvents === undefined) {
	            s.reemitErrorEvents = true;
	        }
	        if (!s.stream) {
	            s.stream = fs.createWriteStream(s.path,
	                                            {flags: 'a', encoding: 'utf8'});
	            if (!s.closeOnExit) {
	                s.closeOnExit = true;
	            }
	        } else {
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	        }
	        break;
	    case 'rotating-file':
	        assert.ok(!s.stream,
	                  '"rotating-file" stream should not give a "stream"');
	        assert.ok(s.path);
	        assert.ok(mv, '"rotating-file" stream type is not supported: '
	                      + 'missing "mv" module');
	        s.stream = new RotatingFileStream(s);
	        if (!s.closeOnExit) {
	            s.closeOnExit = true;
	        }
	        break;
	    case 'raw':
	        if (!s.closeOnExit) {
	            s.closeOnExit = false;
	        }
	        break;
	    default:
	        throw new TypeError('unknown stream type "' + s.type + '"');
	    }

	    if (s.reemitErrorEvents && typeof (s.stream.on) === 'function') {
	        // TODO: When we have `<logger>.close()`, it should remove event
	        //      listeners to not leak Logger instances.
	        s.stream.on('error', function onStreamError(err) {
	            self.emit('error', err, s);
	        });
	    }

	    self.streams.push(s);
	    delete self.haveNonRawStreams;  // reset
	}


	/**
	 * Add serializers
	 *
	 * @param serializers {Object} Optional. Object mapping log record field names
	 *    to serializing functions. See README.md for details.
	 */
	Logger.prototype.addSerializers = function addSerializers(serializers) {
	    var self = this;

	    if (!self.serializers) {
	        self.serializers = {};
	    }
	    Object.keys(serializers).forEach(function (field) {
	        var serializer = serializers[field];
	        if (typeof (serializer) !== 'function') {
	            throw new TypeError(format(
	                'invalid serializer for "%s" field: must be a function',
	                field));
	        } else {
	            self.serializers[field] = serializer;
	        }
	    });
	}



	/**
	 * Create a child logger, typically to add a few log record fields.
	 *
	 * This can be useful when passing a logger to a sub-component, e.g. a
	 * 'wuzzle' component of your service:
	 *
	 *    var wuzzleLog = log.child({component: 'wuzzle'})
	 *    var wuzzle = new Wuzzle({..., log: wuzzleLog})
	 *
	 * Then log records from the wuzzle code will have the same structure as
	 * the app log, *plus the component='wuzzle' field*.
	 *
	 * @param options {Object} Optional. Set of options to apply to the child.
	 *    All of the same options for a new Logger apply here. Notes:
	 *      - The parent's streams are inherited and cannot be removed in this
	 *        call. Any given `streams` are *added* to the set inherited from
	 *        the parent.
	 *      - The parent's serializers are inherited, though can effectively be
	 *        overwritten by using duplicate keys.
	 *      - Can use `level` to set the level of the streams inherited from
	 *        the parent. The level for the parent is NOT affected.
	 * @param simple {Boolean} Optional. Set to true to assert that `options`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation. See 'tools/timechild.js' for numbers.
	 */
	Logger.prototype.child = function (options, simple) {
	    return new (this.constructor)(this, options || {}, simple);
	}


	/**
	 * A convenience method to reopen 'file' streams on a logger. This can be
	 * useful with external log rotation utilities that move and re-open log files
	 * (e.g. logrotate on Linux, logadm on SmartOS/Illumos). Those utilities
	 * typically have rotation options to copy-and-truncate the log file, but
	 * you may not want to use that. An alternative is to do this in your
	 * application:
	 *
	 *      var log = bunyan.createLogger(...);
	 *      ...
	 *      process.on('SIGUSR2', function () {
	 *          log.reopenFileStreams();
	 *      });
	 *      ...
	 *
	 * See <https://github.com/trentm/node-bunyan/issues/104>.
	 */
	Logger.prototype.reopenFileStreams = function () {
	    var self = this;
	    self.streams.forEach(function (s) {
	        if (s.type === 'file') {
	            if (s.stream) {
	                // Not sure if typically would want this, or more immediate
	                // `s.stream.destroy()`.
	                s.stream.end();
	                s.stream.destroySoon();
	                delete s.stream;
	            }
	            s.stream = fs.createWriteStream(s.path,
	                {flags: 'a', encoding: 'utf8'});
	            s.stream.on('error', function (err) {
	                self.emit('error', err, s);
	            });
	        }
	    });
	};


	/* BEGIN JSSTYLED */
	/**
	 * Close this logger.
	 *
	 * This closes streams (that it owns, as per 'endOnClose' attributes on
	 * streams), etc. Typically you **don't** need to bother calling this.
	Logger.prototype.close = function () {
	    if (this._closed) {
	        return;
	    }
	    if (!this._isSimpleChild) {
	        self.streams.forEach(function (s) {
	            if (s.endOnClose) {
	                xxx('closing stream s:', s);
	                s.stream.end();
	                s.endOnClose = false;
	            }
	        });
	    }
	    this._closed = true;
	}
	 */
	/* END JSSTYLED */


	/**
	 * Get/set the level of all streams on this logger.
	 *
	 * Get Usage:
	 *    // Returns the current log level (lowest level of all its streams).
	 *    log.level() -> INFO
	 *
	 * Set Usage:
	 *    log.level(INFO)       // set all streams to level INFO
	 *    log.level('info')     // can use 'info' et al aliases
	 */
	Logger.prototype.level = function level(value) {
	    if (value === undefined) {
	        return this._level;
	    }
	    var newLevel = resolveLevel(value);
	    var len = this.streams.length;
	    for (var i = 0; i < len; i++) {
	        this.streams[i].level = newLevel;
	    }
	    this._level = newLevel;
	}


	/**
	 * Get/set the level of a particular stream on this logger.
	 *
	 * Get Usage:
	 *    // Returns an array of the levels of each stream.
	 *    log.levels() -> [TRACE, INFO]
	 *
	 *    // Returns a level of the identified stream.
	 *    log.levels(0) -> TRACE      // level of stream at index 0
	 *    log.levels('foo')           // level of stream with name 'foo'
	 *
	 * Set Usage:
	 *    log.levels(0, INFO)         // set level of stream 0 to INFO
	 *    log.levels(0, 'info')       // can use 'info' et al aliases
	 *    log.levels('foo', WARN)     // set stream named 'foo' to WARN
	 *
	 * Stream names: When streams are defined, they can optionally be given
	 * a name. For example,
	 *       log = new Logger({
	 *         streams: [
	 *           {
	 *             name: 'foo',
	 *             path: '/var/log/my-service/foo.log'
	 *             level: 'trace'
	 *           },
	 *         ...
	 *
	 * @param name {String|Number} The stream index or name.
	 * @param value {Number|String} The level value (INFO) or alias ('info').
	 *    If not given, this is a 'get' operation.
	 * @throws {Error} If there is no stream with the given name.
	 */
	Logger.prototype.levels = function levels(name, value) {
	    if (name === undefined) {
	        assert.equal(value, undefined);
	        return this.streams.map(
	            function (s) { return s.level });
	    }
	    var stream;
	    if (typeof (name) === 'number') {
	        stream = this.streams[name];
	        if (stream === undefined) {
	            throw new Error('invalid stream index: ' + name);
	        }
	    } else {
	        var len = this.streams.length;
	        for (var i = 0; i < len; i++) {
	            var s = this.streams[i];
	            if (s.name === name) {
	                stream = s;
	                break;
	            }
	        }
	        if (!stream) {
	            throw new Error(format('no stream with name "%s"', name));
	        }
	    }
	    if (value === undefined) {
	        return stream.level;
	    } else {
	        var newLevel = resolveLevel(value);
	        stream.level = newLevel;
	        if (newLevel < this._level) {
	            this._level = newLevel;
	        }
	    }
	}


	/**
	 * Apply registered serializers to the appropriate keys in the given fields.
	 *
	 * Pre-condition: This is only called if there is at least one serializer.
	 *
	 * @param fields (Object) The log record fields.
	 * @param excludeFields (Object) Optional mapping of keys to `true` for
	 *    keys to NOT apply a serializer.
	 */
	Logger.prototype._applySerializers = function (fields, excludeFields) {
	    var self = this;

	    xxx('_applySerializers: excludeFields', excludeFields);

	    // Check each serializer against these (presuming number of serializers
	    // is typically less than number of fields).
	    Object.keys(this.serializers).forEach(function (name) {
	        if (fields[name] === undefined ||
	            (excludeFields && excludeFields[name]))
	        {
	            return;
	        }
	        xxx('_applySerializers; apply to "%s" key', name)
	        try {
	            fields[name] = self.serializers[name](fields[name]);
	        } catch (err) {
	            _warn(format('bunyan: ERROR: Exception thrown from the "%s" '
	                + 'Bunyan serializer. This should never happen. This is a bug'
	                + 'in that serializer function.\n%s',
	                name, err.stack || err));
	            fields[name] = format('(Error in Bunyan log "%s" serializer '
	                + 'broke field. See stderr for details.)', name);
	        }
	    });
	}


	/**
	 * Emit a log record.
	 *
	 * @param rec {log record}
	 * @param noemit {Boolean} Optional. Set to true to skip emission
	 *      and just return the JSON string.
	 */
	Logger.prototype._emit = function (rec, noemit) {
	    var i;

	    // Lazily determine if this Logger has non-'raw' streams. If there are
	    // any, then we need to stringify the log record.
	    if (this.haveNonRawStreams === undefined) {
	        this.haveNonRawStreams = false;
	        for (i = 0; i < this.streams.length; i++) {
	            if (!this.streams[i].raw) {
	                this.haveNonRawStreams = true;
	                break;
	            }
	        }
	    }

	    // Stringify the object. Attempt to warn/recover on error.
	    var str;
	    if (noemit || this.haveNonRawStreams) {
	        try {
	            str = JSON.stringify(rec, safeCycles()) + '\n';
	        } catch (e) {
	            if (safeJsonStringify) {
	                str = safeJsonStringify(rec) + '\n';
	            } else {
	                var dedupKey = e.stack.split(/\n/g, 2).join('\n');
	                _warn('bunyan: ERROR: Exception in '
	                    + '`JSON.stringify(rec)`. You can install the '
	                    + '"safe-json-stringify" module to have Bunyan fallback '
	                    + 'to safer stringification. Record:\n'
	                    + _indent(format('%s\n%s', util.inspect(rec), e.stack)),
	                    dedupKey);
	                str = format('(Exception in JSON.stringify(rec): %j. '
	                    + 'See stderr for details.)\n', e.message);
	            }
	        }
	    }

	    if (noemit)
	        return str;

	    var level = rec.level;
	    for (i = 0; i < this.streams.length; i++) {
	        var s = this.streams[i];
	        if (s.level <= level) {
	            xxx('writing log rec "%s" to "%s" stream (%d <= %d): %j',
	                rec.msg, s.type, s.level, level, rec);
	            s.stream.write(s.raw ? rec : str);
	        }
	    };

	    return str;
	}


	/**
	 * Build a log emitter function for level minLevel. I.e. this is the
	 * creator of `log.info`, `log.error`, etc.
	 */
	function mkLogEmitter(minLevel) {
	    return function () {
	        var log = this;

	        function mkRecord(args) {
	            var excludeFields;
	            if (args[0] instanceof Error) {
	                // `log.<level>(err, ...)`
	                fields = {
	                    // Use this Logger's err serializer, if defined.
	                    err: (log.serializers && log.serializers.err
	                        ? log.serializers.err(args[0])
	                        : Logger.stdSerializers.err(args[0]))
	                };
	                excludeFields = {err: true};
	                if (args.length === 1) {
	                    msgArgs = [fields.err.message];
	                } else {
	                    msgArgs = Array.prototype.slice.call(args, 1);
	                }
	            } else if (typeof (args[0]) !== 'object' ||
	                    Array.isArray(args[0])) {
	                // `log.<level>(msg, ...)`
	                fields = null;
	                msgArgs = Array.prototype.slice.call(args);
	            } else if (Buffer.isBuffer(args[0])) {  // `log.<level>(buf, ...)`
	                // Almost certainly an error, show `inspect(buf)`. See bunyan
	                // issue #35.
	                fields = null;
	                msgArgs = Array.prototype.slice.call(args);
	                msgArgs[0] = util.inspect(msgArgs[0]);
	            } else {  // `log.<level>(fields, msg, ...)`
	                fields = args[0];
	                if (fields && args.length === 1 && fields.err &&
	                    fields.err instanceof Error)
	                {
	                    msgArgs = [fields.err.message];
	                } else {
	                    msgArgs = Array.prototype.slice.call(args, 1);
	                }
	            }

	            // Build up the record object.
	            var rec = objCopy(log.fields);
	            var level = rec.level = minLevel;
	            var recFields = (fields ? objCopy(fields) : null);
	            if (recFields) {
	                if (log.serializers) {
	                    log._applySerializers(recFields, excludeFields);
	                }
	                Object.keys(recFields).forEach(function (k) {
	                    rec[k] = recFields[k];
	                });
	            }
	            rec.msg = format.apply(log, msgArgs);
	            if (!rec.time) {
	                rec.time = (new Date());
	            }
	            // Get call source info
	            if (log.src && !rec.src) {
	                rec.src = getCaller3Info()
	            }
	            rec.v = LOG_VERSION;

	            return rec;
	        };

	        var fields = null;
	        var msgArgs = arguments;
	        var str = null;
	        var rec = null;
	        if (! this._emit) {
	            /*
	             * Show this invalid Bunyan usage warning *once*.
	             *
	             * See <https://github.com/trentm/node-bunyan/issues/100> for
	             * an example of how this can happen.
	             */
	            var dedupKey = 'unbound';
	            if (!_haveWarned[dedupKey]) {
	                var caller = getCaller3Info();
	                _warn(format('bunyan usage error: %s:%s: attempt to log '
	                    + 'with an unbound log method: `this` is: %s',
	                    caller.file, caller.line, util.inspect(this)),
	                    dedupKey);
	            }
	            return;
	        } else if (arguments.length === 0) {   // `log.<level>()`
	            return (this._level <= minLevel);
	        } else if (this._level > minLevel) {
	            /* pass through */
	        } else {
	            rec = mkRecord(msgArgs);
	            str = this._emit(rec);
	        }
	        probes && probes[minLevel].fire(function () {
	                return [ str ||
	                    (rec && log._emit(rec, true)) ||
	                    log._emit(mkRecord(msgArgs), true) ];
	        });
	    }
	}


	/**
	 * The functions below log a record at a specific level.
	 *
	 * Usages:
	 *    log.<level>()  -> boolean is-trace-enabled
	 *    log.<level>(<Error> err, [<string> msg, ...])
	 *    log.<level>(<string> msg, ...)
	 *    log.<level>(<object> fields, <string> msg, ...)
	 *
	 * where <level> is the lowercase version of the log level. E.g.:
	 *
	 *    log.info()
	 *
	 * @params fields {Object} Optional set of additional fields to log.
	 * @params msg {String} Log message. This can be followed by additional
	 *    arguments that are handled like
	 *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).
	 */
	Logger.prototype.trace = mkLogEmitter(TRACE);
	Logger.prototype.debug = mkLogEmitter(DEBUG);
	Logger.prototype.info = mkLogEmitter(INFO);
	Logger.prototype.warn = mkLogEmitter(WARN);
	Logger.prototype.error = mkLogEmitter(ERROR);
	Logger.prototype.fatal = mkLogEmitter(FATAL);



	//---- Standard serializers
	// A serializer is a function that serializes a JavaScript object to a
	// JSON representation for logging. There is a standard set of presumed
	// interesting objects in node.js-land.

	Logger.stdSerializers = {};

	// Serialize an HTTP request.
	Logger.stdSerializers.req = function req(req) {
	    if (!req || !req.connection)
	        return req;
	    return {
	        method: req.method,
	        url: req.url,
	        headers: req.headers,
	        remoteAddress: req.connection.remoteAddress,
	        remotePort: req.connection.remotePort
	    };
	    // Trailers: Skipping for speed. If you need trailers in your app, then
	    // make a custom serializer.
	    //if (Object.keys(trailers).length > 0) {
	    //  obj.trailers = req.trailers;
	    //}
	};

	// Serialize an HTTP response.
	Logger.stdSerializers.res = function res(res) {
	    if (!res || !res.statusCode)
	        return res;
	    return {
	        statusCode: res.statusCode,
	        header: res._header
	    }
	};


	/*
	 * This function dumps long stack traces for exceptions having a cause()
	 * method. The error classes from
	 * [verror](https://github.com/davepacheco/node-verror) and
	 * [restify v2.0](https://github.com/mcavage/node-restify) are examples.
	 *
	 * Based on `dumpException` in
	 * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js
	 */
	function getFullErrorStack(ex)
	{
	    var ret = ex.stack || ex.toString();
	    if (ex.cause && typeof (ex.cause) === 'function') {
	        var cex = ex.cause();
	        if (cex) {
	            ret += '\nCaused by: ' + getFullErrorStack(cex);
	        }
	    }
	    return (ret);
	}

	// Serialize an Error object
	// (Core error properties are enumerable in node 0.4, not in 0.6).
	var errSerializer = Logger.stdSerializers.err = function err(err) {
	    if (!err || !err.stack)
	        return err;
	    var obj = {
	        message: err.message,
	        name: err.name,
	        stack: getFullErrorStack(err),
	        code: err.code,
	        signal: err.signal
	    }
	    return obj;
	};


	// A JSON stringifier that handles cycles safely.
	// Usage: JSON.stringify(obj, safeCycles())
	function safeCycles() {
	    var seen = [];
	    return function (key, val) {
	        if (!val || typeof (val) !== 'object') {
	            return val;
	        }
	        if (seen.indexOf(val) !== -1) {
	            return '[Circular]';
	        }
	        seen.push(val);
	        return val;
	    };
	}



	var RotatingFileStream = null;
	if (mv) {

	RotatingFileStream = function RotatingFileStream(options) {
	    this.path = options.path;

	    this.count = (options.count == null ? 10 : options.count);
	    assert.equal(typeof (this.count), 'number',
	        format('rotating-file stream "count" is not a number: %j (%s) in %j',
	            this.count, typeof (this.count), this));
	    assert.ok(this.count >= 0,
	        format('rotating-file stream "count" is not >= 0: %j in %j',
	            this.count, this));

	    // Parse `options.period`.
	    if (options.period) {
	        // <number><scope> where scope is:
	        //    h   hours (at the start of the hour)
	        //    d   days (at the start of the day, i.e. just after midnight)
	        //    w   weeks (at the start of Sunday)
	        //    m   months (on the first of the month)
	        //    y   years (at the start of Jan 1st)
	        // with special values 'hourly' (1h), 'daily' (1d), "weekly" (1w),
	        // 'monthly' (1m) and 'yearly' (1y)
	        var period = {
	            'hourly': '1h',
	            'daily': '1d',
	            'weekly': '1w',
	            'monthly': '1m',
	            'yearly': '1y'
	        }[options.period] || options.period;
	        var m = /^([1-9][0-9]*)([hdwmy]|ms)$/.exec(period);
	        if (!m) {
	            throw new Error(format('invalid period: "%s"', options.period));
	        }
	        this.periodNum = Number(m[1]);
	        this.periodScope = m[2];
	    } else {
	        this.periodNum = 1;
	        this.periodScope = 'd';
	    }

	    var lastModified = null;
	    try {
	        var fileInfo = fs.statSync(this.path);
	        lastModified = fileInfo.mtime.getTime();
	    }
	    catch (err) {
	        // file doesn't exist
	    }
	    var rotateAfterOpen = false;
	    if (lastModified) {
	        var lastRotTime = this._calcRotTime(0);
	        if (lastModified < lastRotTime) {
	            rotateAfterOpen = true;
	        }
	    }

	    // TODO: template support for backup files
	    // template: <path to which to rotate>
	    //      default is %P.%n
	    //      '/var/log/archive/foo.log'  -> foo.log.%n
	    //      '/var/log/archive/foo.log.%n'
	    //      codes:
	    //          XXX support strftime codes (per node version of those)
	    //              or whatever module. Pick non-colliding for extra
	    //              codes
	    //          %P      `path` base value
	    //          %n      integer number of rotated log (1,2,3,...)
	    //          %d      datetime in YYYY-MM-DD_HH-MM-SS
	    //                      XXX what should default date format be?
	    //                          prior art? Want to avoid ':' in
	    //                          filenames (illegal on Windows for one).

	    this.stream = fs.createWriteStream(this.path,
	        {flags: 'a', encoding: 'utf8'});

	    this.rotQueue = [];
	    this.rotating = false;
	    if (rotateAfterOpen) {
	        this._debug('rotateAfterOpen -> call rotate()');
	        this.rotate();
	    } else {
	        this._setupNextRot();
	    }
	}

	util.inherits(RotatingFileStream, EventEmitter);

	RotatingFileStream.prototype._debug = function () {
	    // Set this to `true` to add debug logging.
	    if (false) {
	        if (arguments.length === 0) {
	            return true;
	        }
	        var args = Array.prototype.slice.call(arguments);
	        args[0] = '[' + (new Date().toISOString()) + ', '
	            + this.path + '] ' + args[0];
	        console.log.apply(this, args);
	    } else {
	        return false;
	    }
	};

	RotatingFileStream.prototype._setupNextRot = function () {
	    this.rotAt = this._calcRotTime(1);
	    this._setRotationTimer();
	}

	RotatingFileStream.prototype._setRotationTimer = function () {
	    var self = this;
	    var delay = this.rotAt - Date.now();
	    // Cap timeout to Node's max setTimeout, see
	    // <https://github.com/joyent/node/issues/8656>.
	    var TIMEOUT_MAX = 2147483647; // 2^31-1
	    if (delay > TIMEOUT_MAX) {
	        delay = TIMEOUT_MAX;
	    }
	    this.timeout = setTimeout(
	        function () {
	            self._debug('_setRotationTimer timeout -> call rotate()');
	            self.rotate();
	        },
	        delay);
	    if (typeof (this.timeout.unref) === 'function') {
	        this.timeout.unref();
	    }
	}

	RotatingFileStream.prototype._calcRotTime =
	function _calcRotTime(periodOffset) {
	    this._debug('_calcRotTime: %s%s', this.periodNum, this.periodScope);
	    var d = new Date();

	    this._debug('  now local: %s', d);
	    this._debug('    now utc: %s', d.toISOString());
	    var rotAt;
	    switch (this.periodScope) {
	    case 'ms':
	        // Hidden millisecond period for debugging.
	        if (this.rotAt) {
	            rotAt = this.rotAt + this.periodNum * periodOffset;
	        } else {
	            rotAt = Date.now() + this.periodNum * periodOffset;
	        }
	        break;
	    case 'h':
	        if (this.rotAt) {
	            rotAt = this.rotAt + this.periodNum * 60 * 60 * 1000 * periodOffset;
	        } else {
	            // First time: top of the next hour.
	            rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(),
	                d.getUTCDate(), d.getUTCHours() + periodOffset);
	        }
	        break;
	    case 'd':
	        if (this.rotAt) {
	            rotAt = this.rotAt + this.periodNum * 24 * 60 * 60 * 1000
	                * periodOffset;
	        } else {
	            // First time: start of tomorrow (i.e. at the coming midnight) UTC.
	            rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(),
	                d.getUTCDate() + periodOffset);
	        }
	        break;
	    case 'w':
	        // Currently, always on Sunday morning at 00:00:00 (UTC).
	        if (this.rotAt) {
	            rotAt = this.rotAt + this.periodNum * 7 * 24 * 60 * 60 * 1000
	                * periodOffset;
	        } else {
	            // First time: this coming Sunday.
	            var dayOffset = (7 - d.getUTCDay());
	            if (periodOffset < 1) {
	                dayOffset = -d.getUTCDay();
	            }
	            if (periodOffset > 1 || periodOffset < -1) {
	                dayOffset += 7 * periodOffset;
	            }
	            rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(),
	                d.getUTCDate() + dayOffset);
	        }
	        break;
	    case 'm':
	        if (this.rotAt) {
	            rotAt = Date.UTC(d.getUTCFullYear(),
	                d.getUTCMonth() + this.periodNum * periodOffset, 1);
	        } else {
	            // First time: the start of the next month.
	            rotAt = Date.UTC(d.getUTCFullYear(),
	                d.getUTCMonth() + periodOffset, 1);
	        }
	        break;
	    case 'y':
	        if (this.rotAt) {
	            rotAt = Date.UTC(d.getUTCFullYear() + this.periodNum * periodOffset,
	                0, 1);
	        } else {
	            // First time: the start of the next year.
	            rotAt = Date.UTC(d.getUTCFullYear() + periodOffset, 0, 1);
	        }
	        break;
	    default:
	        assert.fail(format('invalid period scope: "%s"', this.periodScope));
	    }

	    if (this._debug()) {
	        this._debug('  **rotAt**: %s (utc: %s)', rotAt,
	            new Date(rotAt).toUTCString());
	        var now = Date.now();
	        this._debug('        now: %s (%sms == %smin == %sh to go)',
	            now,
	            rotAt - now,
	            (rotAt-now)/1000/60,
	            (rotAt-now)/1000/60/60);
	    }
	    return rotAt;
	};

	RotatingFileStream.prototype.rotate = function rotate() {
	    // XXX What about shutdown?
	    var self = this;

	    // If rotation period is > ~25 days, we have to break into multiple
	    // setTimeout's. See <https://github.com/joyent/node/issues/8656>.
	    if (self.rotAt && self.rotAt > Date.now()) {
	        return self._setRotationTimer();
	    }

	    this._debug('rotate');
	    if (self.rotating) {
	        throw new TypeError('cannot start a rotation when already rotating');
	    }
	    self.rotating = true;

	    self.stream.end();  // XXX can do moves sync after this? test at high rate

	    function del() {
	        var toDel = self.path + '.' + String(n - 1);
	        if (n === 0) {
	            toDel = self.path;
	        }
	        n -= 1;
	        self._debug('  rm %s', toDel);
	        fs.unlink(toDel, function (delErr) {
	            //XXX handle err other than not exists
	            moves();
	        });
	    }

	    function moves() {
	        if (self.count === 0 || n < 0) {
	            return finish();
	        }
	        var before = self.path;
	        var after = self.path + '.' + String(n);
	        if (n > 0) {
	            before += '.' + String(n - 1);
	        }
	        n -= 1;
	        fs.exists(before, function (exists) {
	            if (!exists) {
	                moves();
	            } else {
	                self._debug('  mv %s %s', before, after);
	                mv(before, after, function (mvErr) {
	                    if (mvErr) {
	                        self.emit('error', mvErr);
	                        finish(); // XXX finish here?
	                    } else {
	                        moves();
	                    }
	                });
	            }
	        })
	    }

	    function finish() {
	        self._debug('  open %s', self.path);
	        self.stream = fs.createWriteStream(self.path,
	            {flags: 'a', encoding: 'utf8'});
	        var q = self.rotQueue, len = q.length;
	        for (var i = 0; i < len; i++) {
	            self.stream.write(q[i]);
	        }
	        self.rotQueue = [];
	        self.rotating = false;
	        self.emit('drain');
	        self._setupNextRot();
	    }

	    var n = this.count;
	    del();
	};

	RotatingFileStream.prototype.write = function write(s) {
	    if (this.rotating) {
	        this.rotQueue.push(s);
	        return false;
	    } else {
	        return this.stream.write(s);
	    }
	};

	RotatingFileStream.prototype.end = function end(s) {
	    this.stream.end();
	};

	RotatingFileStream.prototype.destroy = function destroy(s) {
	    this.stream.destroy();
	};

	RotatingFileStream.prototype.destroySoon = function destroySoon(s) {
	    this.stream.destroySoon();
	};

	} /* if (mv) */



	/**
	 * RingBuffer is a Writable Stream that just stores the last N records in
	 * memory.
	 *
	 * @param options {Object}, with the following fields:
	 *
	 *    - limit: number of records to keep in memory
	 */
	function RingBuffer(options) {
	    this.limit = options && options.limit ? options.limit : 100;
	    this.writable = true;
	    this.records = [];
	    EventEmitter.call(this);
	}

	util.inherits(RingBuffer, EventEmitter);

	RingBuffer.prototype.write = function (record) {
	    if (!this.writable)
	        throw (new Error('RingBuffer has been ended already'));

	    this.records.push(record);

	    if (this.records.length > this.limit)
	        this.records.shift();

	    return (true);
	};

	RingBuffer.prototype.end = function () {
	    if (arguments.length > 0)
	        this.write.apply(this, Array.prototype.slice.call(arguments));
	    this.writable = false;
	};

	RingBuffer.prototype.destroy = function () {
	    this.writable = false;
	    this.emit('close');
	};

	RingBuffer.prototype.destroySoon = function () {
	    this.destroy();
	};


	//---- Exports

	module.exports = Logger;

	module.exports.TRACE = TRACE;
	module.exports.DEBUG = DEBUG;
	module.exports.INFO = INFO;
	module.exports.WARN = WARN;
	module.exports.ERROR = ERROR;
	module.exports.FATAL = FATAL;
	module.exports.resolveLevel = resolveLevel;
	module.exports.levelFromName = levelFromName;
	module.exports.nameFromLevel = nameFromLevel;

	module.exports.VERSION = VERSION;
	module.exports.LOG_VERSION = LOG_VERSION;

	module.exports.createLogger = function createLogger(options) {
	    return new Logger(options);
	};

	module.exports.RingBuffer = RingBuffer;
	module.exports.RotatingFileStream = RotatingFileStream;

	// Useful for custom `type == 'raw'` streams that may do JSON stringification
	// of log records themselves. Usage:
	//    var str = JSON.stringify(rec, bunyan.safeCycles());
	module.exports.safeCycles = safeCycles;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(5).Buffer))

/***/ },
/* 33 */
/***/ function(module, exports) {

	exports.endianness = function () { return 'LE' };

	exports.hostname = function () {
	    if (typeof location !== 'undefined') {
	        return location.hostname
	    }
	    else return '';
	};

	exports.loadavg = function () { return [] };

	exports.uptime = function () { return 0 };

	exports.freemem = function () {
	    return Number.MAX_VALUE;
	};

	exports.totalmem = function () {
	    return Number.MAX_VALUE;
	};

	exports.cpus = function () { return [] };

	exports.type = function () { return 'Browser' };

	exports.release = function () {
	    if (typeof navigator !== 'undefined') {
	        return navigator.appVersion;
	    }
	    return '';
	};

	exports.networkInterfaces
	= exports.getNetworkInterfaces
	= function () { return {} };

	exports.arch = function () { return 'javascript' };

	exports.platform = function () { return 'browser' };

	exports.tmpdir = exports.tmpDir = function () {
	    return '/tmp';
	};

	exports.EOL = '\n';


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var DTraceProvider;

	function DTraceProviderStub() {}
	DTraceProviderStub.prototype.addProbe = function(name) {
	    var p = { 'fire': function () {} };
	    this[name] = p;
	    return (p);
	};
	DTraceProviderStub.prototype.enable = function() {};
	DTraceProviderStub.prototype.fire = function() {};
	DTraceProviderStub.prototype.disable = function() {};

	var builds = ['Release', 'default', 'Debug'];

	for (var i in builds) {
	    try {
	        var binding = !(function webpackMissingModule() { var e = new Error("Cannot find module \"./build\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
	        DTraceProvider = binding.DTraceProvider;
	        break;
	    } catch (e) {
	        // if the platform looks like it _should_ have DTrace
	        // available, log a failure to load the bindings.
	        if (process.platform == 'darwin' ||
	            process.platform == 'sunos' ||
	            process.platform == 'freebsd') {
	            console.error(e);
	        }
	    }
	}

	if (!DTraceProvider) {
	    DTraceProvider = DTraceProviderStub;
	}

	exports.DTraceProvider = DTraceProvider;
	exports.createDTraceProvider = function(name, module) {
	    if (arguments.length == 2)
	        return (new exports.DTraceProvider(name, module));
	    return (new exports.DTraceProvider(name));
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 35 */
/***/ function(module, exports) {

	var hasProp = Object.prototype.hasOwnProperty;

	function throwsMessage(err) {
		return '[Throws: ' + (err ? err.message : '?') + ']';
	}

	function safeGetValueFromPropertyOnObject(obj, property) {
		if (hasProp.call(obj, property)) {
			try {
				return obj[property];
			}
			catch (err) {
				return throwsMessage(err);
			}
		}

		return obj[property];
	}

	function ensureProperties(obj) {
		var seen = [ ]; // store references to objects we have seen before

		function visit(obj) {
			if (obj === null || typeof obj !== 'object') {
				return obj;
			}

			if (seen.indexOf(obj) !== -1) {
				return '[Circular]';
			}
			seen.push(obj);

			if (typeof obj.toJSON === 'function') {
				try {
					return visit(obj.toJSON());
				} catch(err) {
					return throwsMessage(err);
				}
			}

			if (Array.isArray(obj)) {
				return obj.map(visit);
			}

			return Object.keys(obj).reduce(function(result, prop) {
				// prevent faulty defined getter properties
				result[prop] = visit(safeGetValueFromPropertyOnObject(obj, prop));
				return result;
			}, {});
		};

		return visit(obj);
	}

	module.exports = function(data) {
		return JSON.stringify(ensureProperties(data));
	}

	module.exports.ensureProperties = ensureProperties;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var ncp = __webpack_require__(37).ncp;
	var path = __webpack_require__(39);
	var rimraf = __webpack_require__(40);
	var mkdirp = __webpack_require__(53);

	module.exports = mv;

	function mv(source, dest, options, cb){
	  if (typeof options === 'function') {
	    cb = options;
	    options = {};
	  }
	  var shouldMkdirp = !!options.mkdirp;
	  var clobber = options.clobber !== false;
	  var limit = options.limit || 16;

	  if (shouldMkdirp) {
	    mkdirs();
	  } else {
	    doRename();
	  }

	  function mkdirs() {
	    mkdirp(path.dirname(dest), function(err) {
	      if (err) return cb(err);
	      doRename();
	    });
	  }

	  function doRename() {
	    if (clobber) {
	      fs.rename(source, dest, function(err) {
	        if (!err) return cb();
	        if (err.code !== 'EXDEV') return cb(err);
	        moveFileAcrossDevice(source, dest, clobber, limit, cb);
	      });
	    } else {
	      fs.link(source, dest, function(err) {
	        if (err) {
	          if (err.code === 'EXDEV') {
	            moveFileAcrossDevice(source, dest, clobber, limit, cb);
	            return;
	          }
	          if (err.code === 'EISDIR' || err.code === 'EPERM') {
	            moveDirAcrossDevice(source, dest, clobber, limit, cb);
	            return;
	          }
	          cb(err);
	          return;
	        }
	        fs.unlink(source, cb);
	      });
	    }
	  }
	}

	function moveFileAcrossDevice(source, dest, clobber, limit, cb) {
	  var outFlags = clobber ? 'w' : 'wx';
	  var ins = fs.createReadStream(source);
	  var outs = fs.createWriteStream(dest, {flags: outFlags});
	  ins.on('error', function(err){
	    ins.destroy();
	    outs.destroy();
	    outs.removeListener('close', onClose);
	    if (err.code === 'EISDIR' || err.code === 'EPERM') {
	      moveDirAcrossDevice(source, dest, clobber, limit, cb);
	    } else {
	      cb(err);
	    }
	  });
	  outs.on('error', function(err){
	    ins.destroy();
	    outs.destroy();
	    outs.removeListener('close', onClose);
	    cb(err);
	  });
	  outs.once('close', onClose);
	  ins.pipe(outs);
	  function onClose(){
	    fs.unlink(source, cb);
	  }
	}

	function moveDirAcrossDevice(source, dest, clobber, limit, cb) {
	  var options = {
	    stopOnErr: true,
	    clobber: false,
	    limit: limit,
	  };
	  if (clobber) {
	    rimraf(dest, { disableGlob: true }, function(err) {
	      if (err) return cb(err);
	      startNcp();
	    });
	  } else {
	    startNcp();
	  }
	  function startNcp() {
	    ncp(source, dest, options, function(errList) {
	      if (errList) return cb(errList[0]);
	      rimraf(source, { disableGlob: true }, cb);
	    });
	  }
	}


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
	    path = __webpack_require__(39);

	module.exports = ncp;
	ncp.ncp = ncp;

	function ncp (source, dest, options, callback) {
	  var cback = callback;

	  if (!callback) {
	    cback = options;
	    options = {};
	  }

	  var basePath = process.cwd(),
	      currentPath = path.resolve(basePath, source),
	      targetPath = path.resolve(basePath, dest),
	      filter = options.filter,
	      rename = options.rename,
	      transform = options.transform,
	      clobber = options.clobber !== false,
	      modified = options.modified,
	      dereference = options.dereference,
	      errs = null,
	      started = 0,
	      finished = 0,
	      running = 0,
	      limit = options.limit || ncp.limit || 16;

	  limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;

	  startCopy(currentPath);
	  
	  function startCopy(source) {
	    started++;
	    if (filter) {
	      if (filter instanceof RegExp) {
	        if (!filter.test(source)) {
	          return cb(true);
	        }
	      }
	      else if (typeof filter === 'function') {
	        if (!filter(source)) {
	          return cb(true);
	        }
	      }
	    }
	    return getStats(source);
	  }

	  function getStats(source) {
	    var stat = dereference ? fs.stat : fs.lstat;
	    if (running >= limit) {
	      return setImmediate(function () {
	        getStats(source);
	      });
	    }
	    running++;
	    stat(source, function (err, stats) {
	      var item = {};
	      if (err) {
	        return onError(err);
	      }

	      // We need to get the mode from the stats object and preserve it.
	      item.name = source;
	      item.mode = stats.mode;
	      item.mtime = stats.mtime; //modified time
	      item.atime = stats.atime; //access time

	      if (stats.isDirectory()) {
	        return onDir(item);
	      }
	      else if (stats.isFile()) {
	        return onFile(item);
	      }
	      else if (stats.isSymbolicLink()) {
	        // Symlinks don't really need to know about the mode.
	        return onLink(source);
	      }
	    });
	  }

	  function onFile(file) {
	    var target = file.name.replace(currentPath, targetPath);
	    if(rename) {
	      target =  rename(target);
	    }
	    isWritable(target, function (writable) {
	      if (writable) {
	        return copyFile(file, target);
	      }
	      if(clobber) {
	        rmFile(target, function () {
	          copyFile(file, target);
	        });
	      }
	      if (modified) {
	        var stat = dereference ? fs.stat : fs.lstat;
	        stat(target, function(err, stats) {
	            //if souce modified time greater to target modified time copy file
	            if (file.mtime.getTime()>stats.mtime.getTime())
	                copyFile(file, target);
	            else return cb();
	        });
	      }
	      else {
	        return cb();
	      }
	    });
	  }

	  function copyFile(file, target) {
	    var readStream = fs.createReadStream(file.name),
	        writeStream = fs.createWriteStream(target, { mode: file.mode });
	    
	    readStream.on('error', onError);
	    writeStream.on('error', onError);
	    
	    if(transform) {
	      transform(readStream, writeStream, file);
	    } else {
	      writeStream.on('open', function() {
	        readStream.pipe(writeStream);
	      });
	    }
	    writeStream.once('finish', function() {
	        if (modified) {
	            //target file modified date sync.
	            fs.utimesSync(target, file.atime, file.mtime);
	            cb();
	        }
	        else cb();
	    });
	  }

	  function rmFile(file, done) {
	    fs.unlink(file, function (err) {
	      if (err) {
	        return onError(err);
	      }
	      return done();
	    });
	  }

	  function onDir(dir) {
	    var target = dir.name.replace(currentPath, targetPath);
	    isWritable(target, function (writable) {
	      if (writable) {
	        return mkDir(dir, target);
	      }
	      copyDir(dir.name);
	    });
	  }

	  function mkDir(dir, target) {
	    fs.mkdir(target, dir.mode, function (err) {
	      if (err) {
	        return onError(err);
	      }
	      copyDir(dir.name);
	    });
	  }

	  function copyDir(dir) {
	    fs.readdir(dir, function (err, items) {
	      if (err) {
	        return onError(err);
	      }
	      items.forEach(function (item) {
	        startCopy(path.join(dir, item));
	      });
	      return cb();
	    });
	  }

	  function onLink(link) {
	    var target = link.replace(currentPath, targetPath);
	    fs.readlink(link, function (err, resolvedPath) {
	      if (err) {
	        return onError(err);
	      }
	      checkLink(resolvedPath, target);
	    });
	  }

	  function checkLink(resolvedPath, target) {
	    if (dereference) {
	      resolvedPath = path.resolve(basePath, resolvedPath);
	    }
	    isWritable(target, function (writable) {
	      if (writable) {
	        return makeLink(resolvedPath, target);
	      }
	      fs.readlink(target, function (err, targetDest) {
	        if (err) {
	          return onError(err);
	        }
	        if (dereference) {
	          targetDest = path.resolve(basePath, targetDest);
	        }
	        if (targetDest === resolvedPath) {
	          return cb();
	        }
	        return rmFile(target, function () {
	          makeLink(resolvedPath, target);
	        });
	      });
	    });
	  }

	  function makeLink(linkPath, target) {
	    fs.symlink(linkPath, target, function (err) {
	      if (err) {
	        return onError(err);
	      }
	      return cb();
	    });
	  }

	  function isWritable(path, done) {
	    fs.lstat(path, function (err) {
	      if (err) {
	        if (err.code === 'ENOENT') return done(true);
	        return done(false);
	      }
	      return done(false);
	    });
	  }

	  function onError(err) {
	    if (options.stopOnError) {
	      return cback(err);
	    }
	    else if (!errs && options.errs) {
	      errs = fs.createWriteStream(options.errs);
	    }
	    else if (!errs) {
	      errs = [];
	    }
	    if (typeof errs.write === 'undefined') {
	      errs.push(err);
	    }
	    else { 
	      errs.write(err.stack + '\n\n');
	    }
	    return cb();
	  }

	  function cb(skipped) {
	    if (!skipped) running--;
	    finished++;
	    if ((started === finished) && (running === 0)) {
	      if (cback !== undefined ) {
	        return errs ? cback(errs) : cback(null);
	      }
	    }
	  }
	}



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(38).setImmediate))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(2).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38).setImmediate, __webpack_require__(38).clearImmediate))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {module.exports = rimraf
	rimraf.sync = rimrafSync

	var assert = __webpack_require__(9)
	var path = __webpack_require__(39)
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var glob = __webpack_require__(41)

	var globOpts = {
	  nosort: true,
	  nocomment: true,
	  nonegate: true,
	  silent: true
	}

	// for EMFILE handling
	var timeout = 0

	var isWindows = (process.platform === "win32")

	function defaults (options) {
	  var methods = [
	    'unlink',
	    'chmod',
	    'stat',
	    'lstat',
	    'rmdir',
	    'readdir'
	  ]
	  methods.forEach(function(m) {
	    options[m] = options[m] || fs[m]
	    m = m + 'Sync'
	    options[m] = options[m] || fs[m]
	  })

	  options.maxBusyTries = options.maxBusyTries || 3
	  options.emfileWait = options.emfileWait || 1000
	  options.disableGlob = options.disableGlob || false
	}

	function rimraf (p, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = {}
	  }

	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert(options, 'rimraf: missing options')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')
	  assert.equal(typeof cb, 'function', 'rimraf: callback function required')

	  defaults(options)

	  var busyTries = 0
	  var errState = null
	  var n = 0

	  if (options.disableGlob || !glob.hasMagic(p))
	    return afterGlob(null, [p])

	  fs.lstat(p, function (er, stat) {
	    if (!er)
	      return afterGlob(null, [p])

	    glob(p, globOpts, afterGlob)
	  })

	  function next (er) {
	    errState = errState || er
	    if (--n === 0)
	      cb(errState)
	  }

	  function afterGlob (er, results) {
	    if (er)
	      return cb(er)

	    n = results.length
	    if (n === 0)
	      return cb()

	    results.forEach(function (p) {
	      rimraf_(p, options, function CB (er) {
	        if (er) {
	          if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
	              busyTries < options.maxBusyTries) {
	            busyTries ++
	            var time = busyTries * 100
	            // try again, with the same exact callback as this one.
	            return setTimeout(function () {
	              rimraf_(p, options, CB)
	            }, time)
	          }

	          // this one won't happen if graceful-fs is used.
	          if (er.code === "EMFILE" && timeout < options.emfileWait) {
	            return setTimeout(function () {
	              rimraf_(p, options, CB)
	            }, timeout ++)
	          }

	          // already gone
	          if (er.code === "ENOENT") er = null
	        }

	        timeout = 0
	        next(er)
	      })
	    })
	  }
	}

	// Two possible strategies.
	// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
	// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
	//
	// Both result in an extra syscall when you guess wrong.  However, there
	// are likely far more normal files in the world than directories.  This
	// is based on the assumption that a the average number of files per
	// directory is >= 1.
	//
	// If anyone ever complains about this, then I guess the strategy could
	// be made configurable somehow.  But until then, YAGNI.
	function rimraf_ (p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')

	  // sunos lets the root user unlink directories, which is... weird.
	  // so we have to lstat here and make sure it's not a dir.
	  options.lstat(p, function (er, st) {
	    if (er && er.code === "ENOENT")
	      return cb(null)

	    if (st && st.isDirectory())
	      return rmdir(p, options, er, cb)

	    options.unlink(p, function (er) {
	      if (er) {
	        if (er.code === "ENOENT")
	          return cb(null)
	        if (er.code === "EPERM")
	          return (isWindows)
	            ? fixWinEPERM(p, options, er, cb)
	            : rmdir(p, options, er, cb)
	        if (er.code === "EISDIR")
	          return rmdir(p, options, er, cb)
	      }
	      return cb(er)
	    })
	  })
	}

	function fixWinEPERM (p, options, er, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')
	  if (er)
	    assert(er instanceof Error)

	  options.chmod(p, 666, function (er2) {
	    if (er2)
	      cb(er2.code === "ENOENT" ? null : er)
	    else
	      options.stat(p, function(er3, stats) {
	        if (er3)
	          cb(er3.code === "ENOENT" ? null : er)
	        else if (stats.isDirectory())
	          rmdir(p, options, er, cb)
	        else
	          options.unlink(p, cb)
	      })
	  })
	}

	function fixWinEPERMSync (p, options, er) {
	  assert(p)
	  assert(options)
	  if (er)
	    assert(er instanceof Error)

	  try {
	    options.chmodSync(p, 666)
	  } catch (er2) {
	    if (er2.code === "ENOENT")
	      return
	    else
	      throw er
	  }

	  try {
	    var stats = options.statSync(p)
	  } catch (er3) {
	    if (er3.code === "ENOENT")
	      return
	    else
	      throw er
	  }

	  if (stats.isDirectory())
	    rmdirSync(p, options, er)
	  else
	    options.unlinkSync(p)
	}

	function rmdir (p, options, originalEr, cb) {
	  assert(p)
	  assert(options)
	  if (originalEr)
	    assert(originalEr instanceof Error)
	  assert(typeof cb === 'function')

	  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
	  // if we guessed wrong, and it's not a directory, then
	  // raise the original error.
	  options.rmdir(p, function (er) {
	    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
	      rmkids(p, options, cb)
	    else if (er && er.code === "ENOTDIR")
	      cb(originalEr)
	    else
	      cb(er)
	  })
	}

	function rmkids(p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')

	  options.readdir(p, function (er, files) {
	    if (er)
	      return cb(er)
	    var n = files.length
	    if (n === 0)
	      return options.rmdir(p, cb)
	    var errState
	    files.forEach(function (f) {
	      rimraf(path.join(p, f), options, function (er) {
	        if (errState)
	          return
	        if (er)
	          return cb(errState = er)
	        if (--n === 0)
	          options.rmdir(p, cb)
	      })
	    })
	  })
	}

	// this looks simpler, and is strictly *faster*, but will
	// tie up the JavaScript thread and fail on excessively
	// deep directory trees.
	function rimrafSync (p, options) {
	  options = options || {}
	  defaults(options)

	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert(options, 'rimraf: missing options')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')

	  var results

	  if (options.disableGlob || !glob.hasMagic(p)) {
	    results = [p]
	  } else {
	    try {
	      fs.lstatSync(p)
	      results = [p]
	    } catch (er) {
	      results = glob.sync(p, globOpts)
	    }
	  }

	  if (!results.length)
	    return

	  for (var i = 0; i < results.length; i++) {
	    var p = results[i]

	    try {
	      var st = options.lstatSync(p)
	    } catch (er) {
	      if (er.code === "ENOENT")
	        return
	    }

	    try {
	      // sunos lets the root user unlink directories, which is... weird.
	      if (st && st.isDirectory())
	        rmdirSync(p, options, null)
	      else
	        options.unlinkSync(p)
	    } catch (er) {
	      if (er.code === "ENOENT")
	        return
	      if (er.code === "EPERM")
	        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
	      if (er.code !== "EISDIR")
	        throw er
	      rmdirSync(p, options, er)
	    }
	  }
	}

	function rmdirSync (p, options, originalEr) {
	  assert(p)
	  assert(options)
	  if (originalEr)
	    assert(originalEr instanceof Error)

	  try {
	    options.rmdirSync(p)
	  } catch (er) {
	    if (er.code === "ENOENT")
	      return
	    if (er.code === "ENOTDIR")
	      throw originalEr
	    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
	      rmkidsSync(p, options)
	  }
	}

	function rmkidsSync (p, options) {
	  assert(p)
	  assert(options)
	  options.readdirSync(p).forEach(function (f) {
	    rimrafSync(path.join(p, f), options)
	  })
	  options.rmdirSync(p, options)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern, false)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern, inGlobStar)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	//
	// If inGlobStar and PREFIX is symlink and points to dir
	//   set ENTRIES = []
	// else readdir(PREFIX) as ENTRIES
	//   If fail, END
	//
	// with ENTRIES
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       // Mark that this entry is a globstar match
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.

	module.exports = glob

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var minimatch = __webpack_require__(42)
	var Minimatch = minimatch.Minimatch
	var inherits = __webpack_require__(46)
	var EE = __webpack_require__(14).EventEmitter
	var path = __webpack_require__(39)
	var assert = __webpack_require__(9)
	var isAbsolute = __webpack_require__(47)
	var globSync = __webpack_require__(48)
	var common = __webpack_require__(49)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var inflight = __webpack_require__(50)
	var util = __webpack_require__(10)
	var childrenIgnored = common.childrenIgnored
	var isIgnored = common.isIgnored

	var once = __webpack_require__(52)

	function glob (pattern, options, cb) {
	  if (typeof options === 'function') cb = options, options = {}
	  if (!options) options = {}

	  if (options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return globSync(pattern, options)
	  }

	  return new Glob(pattern, options, cb)
	}

	glob.sync = globSync
	var GlobSync = glob.GlobSync = globSync.GlobSync

	// old api surface
	glob.glob = glob

	function extend (origin, add) {
	  if (add === null || typeof add !== 'object') {
	    return origin
	  }

	  var keys = Object.keys(add)
	  var i = keys.length
	  while (i--) {
	    origin[keys[i]] = add[keys[i]]
	  }
	  return origin
	}

	glob.hasMagic = function (pattern, options_) {
	  var options = extend({}, options_)
	  options.noprocess = true

	  var g = new Glob(pattern, options)
	  var set = g.minimatch.set
	  if (set.length > 1)
	    return true

	  for (var j = 0; j < set[0].length; j++) {
	    if (typeof set[0][j] !== 'string')
	      return true
	  }

	  return false
	}

	glob.Glob = Glob
	inherits(Glob, EE)
	function Glob (pattern, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = null
	  }

	  if (options && options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return new GlobSync(pattern, options)
	  }

	  if (!(this instanceof Glob))
	    return new Glob(pattern, options, cb)

	  setopts(this, pattern, options)
	  this._didRealPath = false

	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length

	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n)

	  if (typeof cb === 'function') {
	    cb = once(cb)
	    this.on('error', cb)
	    this.on('end', function (matches) {
	      cb(null, matches)
	    })
	  }

	  var self = this
	  var n = this.minimatch.set.length
	  this._processing = 0
	  this.matches = new Array(n)

	  this._emitQueue = []
	  this._processQueue = []
	  this.paused = false

	  if (this.noprocess)
	    return this

	  if (n === 0)
	    return done()

	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false, done)
	  }

	  function done () {
	    --self._processing
	    if (self._processing <= 0)
	      self._finish()
	  }
	}

	Glob.prototype._finish = function () {
	  assert(this instanceof Glob)
	  if (this.aborted)
	    return

	  if (this.realpath && !this._didRealpath)
	    return this._realpath()

	  common.finish(this)
	  this.emit('end', this.found)
	}

	Glob.prototype._realpath = function () {
	  if (this._didRealpath)
	    return

	  this._didRealpath = true

	  var n = this.matches.length
	  if (n === 0)
	    return this._finish()

	  var self = this
	  for (var i = 0; i < this.matches.length; i++)
	    this._realpathSet(i, next)

	  function next () {
	    if (--n === 0)
	      self._finish()
	  }
	}

	Glob.prototype._realpathSet = function (index, cb) {
	  var matchset = this.matches[index]
	  if (!matchset)
	    return cb()

	  var found = Object.keys(matchset)
	  var self = this
	  var n = found.length

	  if (n === 0)
	    return cb()

	  var set = this.matches[index] = Object.create(null)
	  found.forEach(function (p, i) {
	    // If there's a problem with the stat, then it means that
	    // one or more of the links in the realpath couldn't be
	    // resolved.  just return the abs value in that case.
	    p = self._makeAbs(p)
	    fs.realpath(p, self.realpathCache, function (er, real) {
	      if (!er)
	        set[real] = true
	      else if (er.syscall === 'stat')
	        set[p] = true
	      else
	        self.emit('error', er) // srsly wtf right here

	      if (--n === 0) {
	        self.matches[index] = set
	        cb()
	      }
	    })
	  })
	}

	Glob.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	Glob.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}

	Glob.prototype.abort = function () {
	  this.aborted = true
	  this.emit('abort')
	}

	Glob.prototype.pause = function () {
	  if (!this.paused) {
	    this.paused = true
	    this.emit('pause')
	  }
	}

	Glob.prototype.resume = function () {
	  if (this.paused) {
	    this.emit('resume')
	    this.paused = false
	    if (this._emitQueue.length) {
	      var eq = this._emitQueue.slice(0)
	      this._emitQueue.length = 0
	      for (var i = 0; i < eq.length; i ++) {
	        var e = eq[i]
	        this._emitMatch(e[0], e[1])
	      }
	    }
	    if (this._processQueue.length) {
	      var pq = this._processQueue.slice(0)
	      this._processQueue.length = 0
	      for (var i = 0; i < pq.length; i ++) {
	        var p = pq[i]
	        this._processing--
	        this._process(p[0], p[1], p[2], p[3])
	      }
	    }
	  }
	}

	Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
	  assert(this instanceof Glob)
	  assert(typeof cb === 'function')

	  if (this.aborted)
	    return

	  this._processing++
	  if (this.paused) {
	    this._processQueue.push([pattern, index, inGlobStar, cb])
	    return
	  }

	  //console.error('PROCESS %d', this._processing, pattern)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // see if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index, cb)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip _processing
	  if (childrenIgnored(this, read))
	    return cb()

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
	}

	Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}

	Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return cb()

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return cb()

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this._emitMatch(index, e)
	    }
	    // This was the last one, and no stats were needed
	    return cb()
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix) {
	      if (prefix !== '/')
	        e = prefix + '/' + e
	      else
	        e = prefix + e
	    }
	    this._process([e].concat(remain), index, inGlobStar, cb)
	  }
	  cb()
	}

	Glob.prototype._emitMatch = function (index, e) {
	  if (this.aborted)
	    return

	  if (this.matches[index][e])
	    return

	  if (isIgnored(this, e))
	    return

	  if (this.paused) {
	    this._emitQueue.push([index, e])
	    return
	  }

	  var abs = this._makeAbs(e)

	  if (this.nodir) {
	    var c = this.cache[abs]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  if (this.mark)
	    e = this._mark(e)

	  this.matches[index][e] = true

	  var st = this.statCache[abs]
	  if (st)
	    this.emit('stat', e, st)

	  this.emit('match', e)
	}

	Glob.prototype._readdirInGlobStar = function (abs, cb) {
	  if (this.aborted)
	    return

	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false, cb)

	  var lstatkey = 'lstat\0' + abs
	  var self = this
	  var lstatcb = inflight(lstatkey, lstatcb_)

	  if (lstatcb)
	    fs.lstat(abs, lstatcb)

	  function lstatcb_ (er, lstat) {
	    if (er)
	      return cb()

	    var isSym = lstat.isSymbolicLink()
	    self.symlinks[abs] = isSym

	    // If it's not a symlink or a dir, then it's definitely a regular file.
	    // don't bother doing a readdir in that case.
	    if (!isSym && !lstat.isDirectory()) {
	      self.cache[abs] = 'FILE'
	      cb()
	    } else
	      self._readdir(abs, false, cb)
	  }
	}

	Glob.prototype._readdir = function (abs, inGlobStar, cb) {
	  if (this.aborted)
	    return

	  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
	  if (!cb)
	    return

	  //console.error('RD %j %j', +inGlobStar, abs)
	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs, cb)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return cb()

	    if (Array.isArray(c))
	      return cb(null, c)
	  }

	  var self = this
	  fs.readdir(abs, readdirCb(this, abs, cb))
	}

	function readdirCb (self, abs, cb) {
	  return function (er, entries) {
	    if (er)
	      self._readdirError(abs, er, cb)
	    else
	      self._readdirEntries(abs, entries, cb)
	  }
	}

	Glob.prototype._readdirEntries = function (abs, entries, cb) {
	  if (this.aborted)
	    return

	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries
	  return cb(null, entries)
	}

	Glob.prototype._readdirError = function (f, er, cb) {
	  if (this.aborted)
	    return

	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE'
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict) {
	        this.emit('error', er)
	        // If the error is handled, then we abort
	        // if not, we threw out of here
	        this.abort()
	      }
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }

	  return cb()
	}

	Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}


	Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
	  //console.error('pgs2', prefix, remain[0], entries)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return cb()

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false, cb)

	  var isSym = this.symlinks[abs]
	  var len = entries.length

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return cb()

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true, cb)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true, cb)
	  }

	  cb()
	}

	Glob.prototype._processSimple = function (prefix, index, cb) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var self = this
	  this._stat(prefix, function (er, exists) {
	    self._processSimple2(prefix, index, er, exists, cb)
	  })
	}
	Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

	  //console.error('ps2', prefix, exists)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return cb()

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this._emitMatch(index, prefix)
	  cb()
	}

	// Returns either 'DIR', 'FILE', or false
	Glob.prototype._stat = function (f, cb) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return cb()

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return cb(null, c)

	    if (needDir && c === 'FILE')
	      return cb()

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (stat !== undefined) {
	    if (stat === false)
	      return cb(null, stat)
	    else {
	      var type = stat.isDirectory() ? 'DIR' : 'FILE'
	      if (needDir && type === 'FILE')
	        return cb()
	      else
	        return cb(null, type, stat)
	    }
	  }

	  var self = this
	  var statcb = inflight('stat\0' + abs, lstatcb_)
	  if (statcb)
	    fs.lstat(abs, statcb)

	  function lstatcb_ (er, lstat) {
	    if (lstat && lstat.isSymbolicLink()) {
	      // If it's a symlink, then treat it as the target, unless
	      // the target does not exist, then treat it as a file.
	      return fs.stat(abs, function (er, stat) {
	        if (er)
	          self._stat2(f, abs, null, lstat, cb)
	        else
	          self._stat2(f, abs, er, stat, cb)
	      })
	    } else {
	      self._stat2(f, abs, er, lstat, cb)
	    }
	  }
	}

	Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
	  if (er) {
	    this.statCache[abs] = false
	    return cb()
	  }

	  var needDir = f.slice(-1) === '/'
	  this.statCache[abs] = stat

	  if (abs.slice(-1) === '/' && !stat.isDirectory())
	    return cb(null, false, stat)

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return cb()

	  return cb(null, c, stat)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = minimatch
	minimatch.Minimatch = Minimatch

	var path = { sep: '/' }
	try {
	  path = __webpack_require__(39)
	} catch (er) {}

	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	var expand = __webpack_require__(43)

	var plTypes = {
	  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
	  '?': { open: '(?:', close: ')?' },
	  '+': { open: '(?:', close: ')+' },
	  '*': { open: '(?:', close: ')*' },
	  '@': { open: '(?:', close: ')' }
	}

	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]'

	// * => any number of characters
	var star = qmark + '*?'

	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!')

	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}

	// normalizes slashes.
	var slashSplit = /\/+/

	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}

	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch

	  var orig = minimatch

	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }

	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }

	  return m
	}

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}

	function minimatch (p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false
	  }

	  // "" only matches ""
	  if (pattern.trim() === '') return p === ''

	  return new Minimatch(pattern, options).match(p)
	}

	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options)
	  }

	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}
	  pattern = pattern.trim()

	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/')
	  }

	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false

	  // make the set of regexps etc.
	  this.make()
	}

	Minimatch.prototype.debug = function () {}

	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return

	  var pattern = this.pattern
	  var options = this.options

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate()

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()

	  if (options.debug) this.debug = console.error

	  this.debug(this.pattern, set)

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })

	  this.debug(this.pattern, set)

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)

	  this.debug(this.pattern, set)

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1
	  })

	  this.debug(this.pattern, set)

	  this.set = set
	}

	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	  var negate = false
	  var options = this.options
	  var negateOffset = 0

	  if (options.nonegate) return

	  for (var i = 0, l = pattern.length
	    ; i < l && pattern.charAt(i) === '!'
	    ; i++) {
	    negate = !negate
	    negateOffset++
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options)
	}

	Minimatch.prototype.braceExpand = braceExpand

	function braceExpand (pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options
	    } else {
	      options = {}
	    }
	  }

	  pattern = typeof pattern === 'undefined'
	    ? this.pattern : pattern

	  if (typeof pattern === 'undefined') {
	    throw new TypeError('undefined pattern')
	  }

	  if (options.nobrace ||
	    !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }

	  return expand(pattern)
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  if (pattern.length > 1024 * 64) {
	    throw new TypeError('pattern is too long')
	  }

	  var options = this.options

	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR
	  if (pattern === '') return ''

	  var re = ''
	  var hasMagic = !!options.nocase
	  var escaping = false
	  // ? => one single character
	  var patternListStack = []
	  var negativeLists = []
	  var stateChar
	  var inClass = false
	  var reClassStart = -1
	  var classStart = -1
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
	  : '(?!\\.)'
	  var self = this

	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star
	          hasMagic = true
	        break
	        case '?':
	          re += qmark
	          hasMagic = true
	        break
	        default:
	          re += '\\' + stateChar
	        break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }

	  for (var i = 0, len = pattern.length, c
	    ; (i < len) && (c = pattern.charAt(i))
	    ; i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c)

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c
	      escaping = false
	      continue
	    }

	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false

	      case '\\':
	        clearStateChar()
	        escaping = true
	      continue

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === '!' && i === classStart + 1) c = '^'
	          re += c
	          continue
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	      continue

	      case '(':
	        if (inClass) {
	          re += '('
	          continue
	        }

	        if (!stateChar) {
	          re += '\\('
	          continue
	        }

	        patternListStack.push({
	          type: stateChar,
	          start: i - 1,
	          reStart: re.length,
	          open: plTypes[stateChar].open,
	          close: plTypes[stateChar].close
	        })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	      continue

	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)'
	          continue
	        }

	        clearStateChar()
	        hasMagic = true
	        var pl = patternListStack.pop()
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        re += pl.close
	        if (pl.type === '!') {
	          negativeLists.push(pl)
	        }
	        pl.reEnd = re.length
	      continue

	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|'
	          escaping = false
	          continue
	        }

	        clearStateChar()
	        re += '|'
	      continue

	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar()

	        if (inClass) {
	          re += '\\' + c
	          continue
	        }

	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	      continue

	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c
	          escaping = false
	          continue
	        }

	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i)
	          try {
	            RegExp('[' + cs + ']')
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE)
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
	            hasMagic = hasMagic || sp[1]
	            inClass = false
	            continue
	          }
	        }

	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	      continue

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()

	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	          && !(c === '^' && inClass)) {
	          re += '\\'
	        }

	        re += c

	    } // switch
	  } // for

	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1)
	    sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + '\\[' + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + pl.open.length)
	    this.debug('setting tail', re, pl)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\'
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|'
	    })

	    this.debug('tail=%j\n   %s', tail, tail, pl, re)
	    var t = pl.type === '*' ? star
	      : pl.type === '?' ? qmark
	      : '\\' + pl.type

	    hasMagic = true
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += '\\\\'
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(': addPatternStart = true
	  }

	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n]

	    var nlBefore = re.slice(0, nl.reStart)
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
	    var nlAfter = re.slice(nl.reEnd)

	    nlLast += nlAfter

	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1
	    var cleanAfter = nlAfter
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
	    }
	    nlAfter = cleanAfter

	    var dollar = ''
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$'
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
	    re = newRe
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re
	  }

	  if (addPatternStart) {
	    re = patternStart + re
	  }

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic]
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }

	  var flags = options.nocase ? 'i' : ''
	  try {
	    var regExp = new RegExp('^' + re + '$', flags)
	  } catch (er) {
	    // If it was an invalid regular expression, then it can't match
	    // anything.  This trick looks for a character after the end of
	    // the string, which is of course impossible, except in multi-line
	    // mode, but it's not a /m regex.
	    return new RegExp('$.')
	  }

	  regExp._glob = pattern
	  regExp._src = re

	  return regExp
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}

	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set

	  if (!set.length) {
	    this.regexp = false
	    return this.regexp
	  }
	  var options = this.options

	  var twoStar = options.noglobstar ? star
	    : options.dot ? twoStarDot
	    : twoStarNoDot
	  var flags = options.nocase ? 'i' : ''

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	      : (typeof p === 'string') ? regExpEscape(p)
	      : p._src
	    }).join('\\\/')
	  }).join('|')

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$'

	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$'

	  try {
	    this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    this.regexp = false
	  }
	  return this.regexp
	}

	minimatch.match = function (list, pattern, options) {
	  options = options || {}
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}

	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug('match', f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ''

	  if (f === '/' && partial) return true

	  var options = this.options

	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/')
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, 'split', f)

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set
	  this.debug(this.pattern, 'set', set)

	  // Find the basename of the path by looking for the last non-empty segment
	  var filename
	  var i
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i]
	    if (filename) break
	  }

	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i]
	    var file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename]
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options

	  this.debug('matchOne',
	    { 'this': this, file: file, pattern: pattern })

	  this.debug('matchOne', file.length, pattern.length)

	  for (var fi = 0,
	      pi = 0,
	      fl = file.length,
	      pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi++, pi++) {
	    this.debug('matchOne loop')
	    var p = pattern[pi]
	    var f = file[fi]

	    this.debug(pattern, p, f)

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	      var pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' ||
	            (!options.dot && file[fi].charAt(0) === '.')) return false
	        }
	        return true
	      }

	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr]

	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' ||
	            (!options.dot && swallowee.charAt(0) === '.')) {
	            this.debug('dot detected!', file, fr, pattern, pr)
	            break
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr++
	        }
	      }

	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug('string match', p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug('pattern match', p, f, hit)
	    }

	    if (!hit) return false
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
	    return emptyFileEnd
	  }

	  // should be unreachable.
	  throw new Error('wtf?')
	}

	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, '$1')
	}

	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
	}


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var concatMap = __webpack_require__(44);
	var balanced = __webpack_require__(45);

	module.exports = expandTop;

	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';

	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}


	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m)
	    return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str)
	    return [];

	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function identity(e) {
	  return e;
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];

	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }

	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length
	          ? expand(m.post, false)
	          : [''];
	        return post.map(function(p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }

	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];

	  var N;

	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length)
	    var incr = n.length == 3
	      ? Math.abs(numeric(n[2]))
	      : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);

	    N = [];

	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\')
	          c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0)
	              c = '-' + z + c.slice(1);
	            else
	              c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function(el) { return expand(el, false) });
	  }

	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion)
	        expansions.push(expansion);
	    }
	  }

	  return expansions;
	}



/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);
	        else res.push(x);
	    }
	    return res;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;

	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }

	  return result;
	}


/***/ },
/* 46 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	function posix(path) {
		return path.charAt(0) === '/';
	}

	function win32(path) {
		// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path);
		var device = result[1] || '';
		var isUnc = Boolean(device && device.charAt(1) !== ':');

		// UNC paths are always absolute
		return Boolean(result[2] || isUnc);
	}

	module.exports = process.platform === 'win32' ? win32 : posix;
	module.exports.posix = posix;
	module.exports.win32 = win32;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {module.exports = globSync
	globSync.GlobSync = GlobSync

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var minimatch = __webpack_require__(42)
	var Minimatch = minimatch.Minimatch
	var Glob = __webpack_require__(41).Glob
	var util = __webpack_require__(10)
	var path = __webpack_require__(39)
	var assert = __webpack_require__(9)
	var isAbsolute = __webpack_require__(47)
	var common = __webpack_require__(49)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var childrenIgnored = common.childrenIgnored

	function globSync (pattern, options) {
	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  return new GlobSync(pattern, options).found
	}

	function GlobSync (pattern, options) {
	  if (!pattern)
	    throw new Error('must provide pattern')

	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  if (!(this instanceof GlobSync))
	    return new GlobSync(pattern, options)

	  setopts(this, pattern, options)

	  if (this.noprocess)
	    return this

	  var n = this.minimatch.set.length
	  this.matches = new Array(n)
	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false)
	  }
	  this._finish()
	}

	GlobSync.prototype._finish = function () {
	  assert(this instanceof GlobSync)
	  if (this.realpath) {
	    var self = this
	    this.matches.forEach(function (matchset, index) {
	      var set = self.matches[index] = Object.create(null)
	      for (var p in matchset) {
	        try {
	          p = self._makeAbs(p)
	          var real = fs.realpathSync(p, self.realpathCache)
	          set[real] = true
	        } catch (er) {
	          if (er.syscall === 'stat')
	            set[self._makeAbs(p)] = true
	          else
	            throw er
	        }
	      }
	    })
	  }
	  common.finish(this)
	}


	GlobSync.prototype._process = function (pattern, index, inGlobStar) {
	  assert(this instanceof GlobSync)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // See if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip processing
	  if (childrenIgnored(this, read))
	    return

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
	}


	GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
	  var entries = this._readdir(abs, inGlobStar)

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix.slice(-1) !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this.matches[index][e] = true
	    }
	    // This was the last one, and no stats were needed
	    return
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix)
	      newPattern = [prefix, e]
	    else
	      newPattern = [e]
	    this._process(newPattern.concat(remain), index, inGlobStar)
	  }
	}


	GlobSync.prototype._emitMatch = function (index, e) {
	  var abs = this._makeAbs(e)
	  if (this.mark)
	    e = this._mark(e)

	  if (this.matches[index][e])
	    return

	  if (this.nodir) {
	    var c = this.cache[this._makeAbs(e)]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  this.matches[index][e] = true
	  if (this.stat)
	    this._stat(e)
	}


	GlobSync.prototype._readdirInGlobStar = function (abs) {
	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false)

	  var entries
	  var lstat
	  var stat
	  try {
	    lstat = fs.lstatSync(abs)
	  } catch (er) {
	    // lstat failed, doesn't exist
	    return null
	  }

	  var isSym = lstat.isSymbolicLink()
	  this.symlinks[abs] = isSym

	  // If it's not a symlink or a dir, then it's definitely a regular file.
	  // don't bother doing a readdir in that case.
	  if (!isSym && !lstat.isDirectory())
	    this.cache[abs] = 'FILE'
	  else
	    entries = this._readdir(abs, false)

	  return entries
	}

	GlobSync.prototype._readdir = function (abs, inGlobStar) {
	  var entries

	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return null

	    if (Array.isArray(c))
	      return c
	  }

	  try {
	    return this._readdirEntries(abs, fs.readdirSync(abs))
	  } catch (er) {
	    this._readdirError(abs, er)
	    return null
	  }
	}

	GlobSync.prototype._readdirEntries = function (abs, entries) {
	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries

	  // mark and cache dir-ness
	  return entries
	}

	GlobSync.prototype._readdirError = function (f, er) {
	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE'
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict)
	        throw er
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }
	}

	GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

	  var entries = this._readdir(abs, inGlobStar)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false)

	  var len = entries.length
	  var isSym = this.symlinks[abs]

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true)
	  }
	}

	GlobSync.prototype._processSimple = function (prefix, index) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var exists = this._stat(prefix)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this.matches[index][prefix] = true
	}

	// Returns either 'DIR', 'FILE', or false
	GlobSync.prototype._stat = function (f) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return false

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return c

	    if (needDir && c === 'FILE')
	      return false

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (!stat) {
	    var lstat
	    try {
	      lstat = fs.lstatSync(abs)
	    } catch (er) {
	      return false
	    }

	    if (lstat.isSymbolicLink()) {
	      try {
	        stat = fs.statSync(abs)
	      } catch (er) {
	        stat = lstat
	      }
	    } else {
	      stat = lstat
	    }
	  }

	  this.statCache[abs] = stat

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return false

	  return c
	}

	GlobSync.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	GlobSync.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports.alphasort = alphasort
	exports.alphasorti = alphasorti
	exports.setopts = setopts
	exports.ownProp = ownProp
	exports.makeAbs = makeAbs
	exports.finish = finish
	exports.mark = mark
	exports.isIgnored = isIgnored
	exports.childrenIgnored = childrenIgnored

	function ownProp (obj, field) {
	  return Object.prototype.hasOwnProperty.call(obj, field)
	}

	var path = __webpack_require__(39)
	var minimatch = __webpack_require__(42)
	var isAbsolute = __webpack_require__(47)
	var Minimatch = minimatch.Minimatch

	function alphasorti (a, b) {
	  return a.toLowerCase().localeCompare(b.toLowerCase())
	}

	function alphasort (a, b) {
	  return a.localeCompare(b)
	}

	function setupIgnores (self, options) {
	  self.ignore = options.ignore || []

	  if (!Array.isArray(self.ignore))
	    self.ignore = [self.ignore]

	  if (self.ignore.length) {
	    self.ignore = self.ignore.map(ignoreMap)
	  }
	}

	// ignore patterns are always in dot:true mode.
	function ignoreMap (pattern) {
	  var gmatcher = null
	  if (pattern.slice(-3) === '/**') {
	    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
	    gmatcher = new Minimatch(gpattern, { dot: true })
	  }

	  return {
	    matcher: new Minimatch(pattern, { dot: true }),
	    gmatcher: gmatcher
	  }
	}

	function setopts (self, pattern, options) {
	  if (!options)
	    options = {}

	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar")
	    }
	    pattern = "**/" + pattern
	  }

	  self.silent = !!options.silent
	  self.pattern = pattern
	  self.strict = options.strict !== false
	  self.realpath = !!options.realpath
	  self.realpathCache = options.realpathCache || Object.create(null)
	  self.follow = !!options.follow
	  self.dot = !!options.dot
	  self.mark = !!options.mark
	  self.nodir = !!options.nodir
	  if (self.nodir)
	    self.mark = true
	  self.sync = !!options.sync
	  self.nounique = !!options.nounique
	  self.nonull = !!options.nonull
	  self.nosort = !!options.nosort
	  self.nocase = !!options.nocase
	  self.stat = !!options.stat
	  self.noprocess = !!options.noprocess

	  self.maxLength = options.maxLength || Infinity
	  self.cache = options.cache || Object.create(null)
	  self.statCache = options.statCache || Object.create(null)
	  self.symlinks = options.symlinks || Object.create(null)

	  setupIgnores(self, options)

	  self.changedCwd = false
	  var cwd = process.cwd()
	  if (!ownProp(options, "cwd"))
	    self.cwd = cwd
	  else {
	    self.cwd = options.cwd
	    self.changedCwd = path.resolve(options.cwd) !== cwd
	  }

	  self.root = options.root || path.resolve(self.cwd, "/")
	  self.root = path.resolve(self.root)
	  if (process.platform === "win32")
	    self.root = self.root.replace(/\\/g, "/")

	  self.nomount = !!options.nomount

	  // disable comments and negation in Minimatch.
	  // Note that they are not supported in Glob itself anyway.
	  options.nonegate = true
	  options.nocomment = true

	  self.minimatch = new Minimatch(pattern, options)
	  self.options = self.minimatch.options
	}

	function finish (self) {
	  var nou = self.nounique
	  var all = nou ? [] : Object.create(null)

	  for (var i = 0, l = self.matches.length; i < l; i ++) {
	    var matches = self.matches[i]
	    if (!matches || Object.keys(matches).length === 0) {
	      if (self.nonull) {
	        // do like the shell, and spit out the literal glob
	        var literal = self.minimatch.globSet[i]
	        if (nou)
	          all.push(literal)
	        else
	          all[literal] = true
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches)
	      if (nou)
	        all.push.apply(all, m)
	      else
	        m.forEach(function (m) {
	          all[m] = true
	        })
	    }
	  }

	  if (!nou)
	    all = Object.keys(all)

	  if (!self.nosort)
	    all = all.sort(self.nocase ? alphasorti : alphasort)

	  // at *some* point we statted all of these
	  if (self.mark) {
	    for (var i = 0; i < all.length; i++) {
	      all[i] = self._mark(all[i])
	    }
	    if (self.nodir) {
	      all = all.filter(function (e) {
	        return !(/\/$/.test(e))
	      })
	    }
	  }

	  if (self.ignore.length)
	    all = all.filter(function(m) {
	      return !isIgnored(self, m)
	    })

	  self.found = all
	}

	function mark (self, p) {
	  var abs = makeAbs(self, p)
	  var c = self.cache[abs]
	  var m = p
	  if (c) {
	    var isDir = c === 'DIR' || Array.isArray(c)
	    var slash = p.slice(-1) === '/'

	    if (isDir && !slash)
	      m += '/'
	    else if (!isDir && slash)
	      m = m.slice(0, -1)

	    if (m !== p) {
	      var mabs = makeAbs(self, m)
	      self.statCache[mabs] = self.statCache[abs]
	      self.cache[mabs] = self.cache[abs]
	    }
	  }

	  return m
	}

	// lotta situps...
	function makeAbs (self, f) {
	  var abs = f
	  if (f.charAt(0) === '/') {
	    abs = path.join(self.root, f)
	  } else if (isAbsolute(f) || f === '') {
	    abs = f
	  } else if (self.changedCwd) {
	    abs = path.resolve(self.cwd, f)
	  } else {
	    abs = path.resolve(f)
	  }
	  return abs
	}


	// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
	// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
	function isIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}

	function childrenIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var wrappy = __webpack_require__(51)
	var reqs = Object.create(null)
	var once = __webpack_require__(52)

	module.exports = wrappy(inflight)

	function inflight (key, cb) {
	  if (reqs[key]) {
	    reqs[key].push(cb)
	    return null
	  } else {
	    reqs[key] = [cb]
	    return makeres(key)
	  }
	}

	function makeres (key) {
	  return once(function RES () {
	    var cbs = reqs[key]
	    var len = cbs.length
	    var args = slice(arguments)

	    // XXX It's somewhat ambiguous whether a new callback added in this
	    // pass should be queued for later execution if something in the
	    // list of callbacks throws, or if it should just be discarded.
	    // However, it's such an edge case that it hardly matters, and either
	    // choice is likely as surprising as the other.
	    // As it happens, we do go ahead and schedule it for later execution.
	    try {
	      for (var i = 0; i < len; i++) {
	        cbs[i].apply(null, args)
	      }
	    } finally {
	      if (cbs.length > len) {
	        // added more in the interim.
	        // de-zalgo, just in case, but don't call again.
	        cbs.splice(0, len)
	        process.nextTick(function () {
	          RES.apply(null, args)
	        })
	      } else {
	        delete reqs[key]
	      }
	    }
	  })
	}

	function slice (args) {
	  var length = args.length
	  var array = []

	  for (var i = 0; i < length; i++) array[i] = args[i]
	  return array
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 51 */
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(51)
	module.exports = wrappy(once)
	module.exports.strict = wrappy(onceStrict)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  var name = fn.name || 'Function wrapped with `once`'
	  f.onceError = name + " shouldn't be called more than once"
	  f.called = false
	  return f
	}


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(39);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var _0777 = parseInt('0777', 8);

	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}

	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;

	    p = path.resolve(p);

	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }

	    return made;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = LRUCache

	// This will be a proper iterable 'Map' in engines that support it,
	// or a fakey-fake PseudoMap in older versions.
	var Map = __webpack_require__(55)
	var util = __webpack_require__(10)

	// A linked list to keep track of recently-used-ness
	var Yallist = __webpack_require__(57)

	// use symbols if possible, otherwise just _props
	var symbols = {}
	var hasSymbol = typeof Symbol === 'function'
	var makeSymbol
	/* istanbul ignore if */
	if (hasSymbol) {
	  makeSymbol = function (key) {
	    return Symbol.for(key)
	  }
	} else {
	  makeSymbol = function (key) {
	    return '_' + key
	  }
	}

	function priv (obj, key, val) {
	  var sym
	  if (symbols[key]) {
	    sym = symbols[key]
	  } else {
	    sym = makeSymbol(key)
	    symbols[key] = sym
	  }
	  if (arguments.length === 2) {
	    return obj[sym]
	  } else {
	    obj[sym] = val
	    return val
	  }
	}

	function naiveLength () { return 1 }

	// lruList is a yallist where the head is the youngest
	// item, and the tail is the oldest.  the list contains the Hit
	// objects as the entries.
	// Each Hit object has a reference to its Yallist.Node.  This
	// never changes.
	//
	// cache is a Map (or PseudoMap) that matches the keys to
	// the Yallist.Node object.
	function LRUCache (options) {
	  if (!(this instanceof LRUCache)) {
	    return new LRUCache(options)
	  }

	  if (typeof options === 'number') {
	    options = { max: options }
	  }

	  if (!options) {
	    options = {}
	  }

	  var max = priv(this, 'max', options.max)
	  // Kind of weird to have a default max of Infinity, but oh well.
	  if (!max ||
	      !(typeof max === 'number') ||
	      max <= 0) {
	    priv(this, 'max', Infinity)
	  }

	  var lc = options.length || naiveLength
	  if (typeof lc !== 'function') {
	    lc = naiveLength
	  }
	  priv(this, 'lengthCalculator', lc)

	  priv(this, 'allowStale', options.stale || false)
	  priv(this, 'maxAge', options.maxAge || 0)
	  priv(this, 'dispose', options.dispose)
	  this.reset()
	}

	// resize the cache when the max changes.
	Object.defineProperty(LRUCache.prototype, 'max', {
	  set: function (mL) {
	    if (!mL || !(typeof mL === 'number') || mL <= 0) {
	      mL = Infinity
	    }
	    priv(this, 'max', mL)
	    trim(this)
	  },
	  get: function () {
	    return priv(this, 'max')
	  },
	  enumerable: true
	})

	Object.defineProperty(LRUCache.prototype, 'allowStale', {
	  set: function (allowStale) {
	    priv(this, 'allowStale', !!allowStale)
	  },
	  get: function () {
	    return priv(this, 'allowStale')
	  },
	  enumerable: true
	})

	Object.defineProperty(LRUCache.prototype, 'maxAge', {
	  set: function (mA) {
	    if (!mA || !(typeof mA === 'number') || mA < 0) {
	      mA = 0
	    }
	    priv(this, 'maxAge', mA)
	    trim(this)
	  },
	  get: function () {
	    return priv(this, 'maxAge')
	  },
	  enumerable: true
	})

	// resize the cache when the lengthCalculator changes.
	Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
	  set: function (lC) {
	    if (typeof lC !== 'function') {
	      lC = naiveLength
	    }
	    if (lC !== priv(this, 'lengthCalculator')) {
	      priv(this, 'lengthCalculator', lC)
	      priv(this, 'length', 0)
	      priv(this, 'lruList').forEach(function (hit) {
	        hit.length = priv(this, 'lengthCalculator').call(this, hit.value, hit.key)
	        priv(this, 'length', priv(this, 'length') + hit.length)
	      }, this)
	    }
	    trim(this)
	  },
	  get: function () { return priv(this, 'lengthCalculator') },
	  enumerable: true
	})

	Object.defineProperty(LRUCache.prototype, 'length', {
	  get: function () { return priv(this, 'length') },
	  enumerable: true
	})

	Object.defineProperty(LRUCache.prototype, 'itemCount', {
	  get: function () { return priv(this, 'lruList').length },
	  enumerable: true
	})

	LRUCache.prototype.rforEach = function (fn, thisp) {
	  thisp = thisp || this
	  for (var walker = priv(this, 'lruList').tail; walker !== null;) {
	    var prev = walker.prev
	    forEachStep(this, fn, walker, thisp)
	    walker = prev
	  }
	}

	function forEachStep (self, fn, node, thisp) {
	  var hit = node.value
	  if (isStale(self, hit)) {
	    del(self, node)
	    if (!priv(self, 'allowStale')) {
	      hit = undefined
	    }
	  }
	  if (hit) {
	    fn.call(thisp, hit.value, hit.key, self)
	  }
	}

	LRUCache.prototype.forEach = function (fn, thisp) {
	  thisp = thisp || this
	  for (var walker = priv(this, 'lruList').head; walker !== null;) {
	    var next = walker.next
	    forEachStep(this, fn, walker, thisp)
	    walker = next
	  }
	}

	LRUCache.prototype.keys = function () {
	  return priv(this, 'lruList').toArray().map(function (k) {
	    return k.key
	  }, this)
	}

	LRUCache.prototype.values = function () {
	  return priv(this, 'lruList').toArray().map(function (k) {
	    return k.value
	  }, this)
	}

	LRUCache.prototype.reset = function () {
	  if (priv(this, 'dispose') &&
	      priv(this, 'lruList') &&
	      priv(this, 'lruList').length) {
	    priv(this, 'lruList').forEach(function (hit) {
	      priv(this, 'dispose').call(this, hit.key, hit.value)
	    }, this)
	  }

	  priv(this, 'cache', new Map()) // hash of items by key
	  priv(this, 'lruList', new Yallist()) // list of items in order of use recency
	  priv(this, 'length', 0) // length of items in the list
	}

	LRUCache.prototype.dump = function () {
	  return priv(this, 'lruList').map(function (hit) {
	    if (!isStale(this, hit)) {
	      return {
	        k: hit.key,
	        v: hit.value,
	        e: hit.now + (hit.maxAge || 0)
	      }
	    }
	  }, this).toArray().filter(function (h) {
	    return h
	  })
	}

	LRUCache.prototype.dumpLru = function () {
	  return priv(this, 'lruList')
	}

	LRUCache.prototype.inspect = function (n, opts) {
	  var str = 'LRUCache {'
	  var extras = false

	  var as = priv(this, 'allowStale')
	  if (as) {
	    str += '\n  allowStale: true'
	    extras = true
	  }

	  var max = priv(this, 'max')
	  if (max && max !== Infinity) {
	    if (extras) {
	      str += ','
	    }
	    str += '\n  max: ' + util.inspect(max, opts)
	    extras = true
	  }

	  var maxAge = priv(this, 'maxAge')
	  if (maxAge) {
	    if (extras) {
	      str += ','
	    }
	    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
	    extras = true
	  }

	  var lc = priv(this, 'lengthCalculator')
	  if (lc && lc !== naiveLength) {
	    if (extras) {
	      str += ','
	    }
	    str += '\n  length: ' + util.inspect(priv(this, 'length'), opts)
	    extras = true
	  }

	  var didFirst = false
	  priv(this, 'lruList').forEach(function (item) {
	    if (didFirst) {
	      str += ',\n  '
	    } else {
	      if (extras) {
	        str += ',\n'
	      }
	      didFirst = true
	      str += '\n  '
	    }
	    var key = util.inspect(item.key).split('\n').join('\n  ')
	    var val = { value: item.value }
	    if (item.maxAge !== maxAge) {
	      val.maxAge = item.maxAge
	    }
	    if (lc !== naiveLength) {
	      val.length = item.length
	    }
	    if (isStale(this, item)) {
	      val.stale = true
	    }

	    val = util.inspect(val, opts).split('\n').join('\n  ')
	    str += key + ' => ' + val
	  })

	  if (didFirst || extras) {
	    str += '\n'
	  }
	  str += '}'

	  return str
	}

	LRUCache.prototype.set = function (key, value, maxAge) {
	  maxAge = maxAge || priv(this, 'maxAge')

	  var now = maxAge ? Date.now() : 0
	  var len = priv(this, 'lengthCalculator').call(this, value, key)

	  if (priv(this, 'cache').has(key)) {
	    if (len > priv(this, 'max')) {
	      del(this, priv(this, 'cache').get(key))
	      return false
	    }

	    var node = priv(this, 'cache').get(key)
	    var item = node.value

	    // dispose of the old one before overwriting
	    if (priv(this, 'dispose')) {
	      priv(this, 'dispose').call(this, key, item.value)
	    }

	    item.now = now
	    item.maxAge = maxAge
	    item.value = value
	    priv(this, 'length', priv(this, 'length') + (len - item.length))
	    item.length = len
	    this.get(key)
	    trim(this)
	    return true
	  }

	  var hit = new Entry(key, value, len, now, maxAge)

	  // oversized objects fall out of cache automatically.
	  if (hit.length > priv(this, 'max')) {
	    if (priv(this, 'dispose')) {
	      priv(this, 'dispose').call(this, key, value)
	    }
	    return false
	  }

	  priv(this, 'length', priv(this, 'length') + hit.length)
	  priv(this, 'lruList').unshift(hit)
	  priv(this, 'cache').set(key, priv(this, 'lruList').head)
	  trim(this)
	  return true
	}

	LRUCache.prototype.has = function (key) {
	  if (!priv(this, 'cache').has(key)) return false
	  var hit = priv(this, 'cache').get(key).value
	  if (isStale(this, hit)) {
	    return false
	  }
	  return true
	}

	LRUCache.prototype.get = function (key) {
	  return get(this, key, true)
	}

	LRUCache.prototype.peek = function (key) {
	  return get(this, key, false)
	}

	LRUCache.prototype.pop = function () {
	  var node = priv(this, 'lruList').tail
	  if (!node) return null
	  del(this, node)
	  return node.value
	}

	LRUCache.prototype.del = function (key) {
	  del(this, priv(this, 'cache').get(key))
	}

	LRUCache.prototype.load = function (arr) {
	  // reset the cache
	  this.reset()

	  var now = Date.now()
	  // A previous serialized cache has the most recent items first
	  for (var l = arr.length - 1; l >= 0; l--) {
	    var hit = arr[l]
	    var expiresAt = hit.e || 0
	    if (expiresAt === 0) {
	      // the item was created without expiration in a non aged cache
	      this.set(hit.k, hit.v)
	    } else {
	      var maxAge = expiresAt - now
	      // dont add already expired items
	      if (maxAge > 0) {
	        this.set(hit.k, hit.v, maxAge)
	      }
	    }
	  }
	}

	LRUCache.prototype.prune = function () {
	  var self = this
	  priv(this, 'cache').forEach(function (value, key) {
	    get(self, key, false)
	  })
	}

	function get (self, key, doUse) {
	  var node = priv(self, 'cache').get(key)
	  if (node) {
	    var hit = node.value
	    if (isStale(self, hit)) {
	      del(self, node)
	      if (!priv(self, 'allowStale')) hit = undefined
	    } else {
	      if (doUse) {
	        priv(self, 'lruList').unshiftNode(node)
	      }
	    }
	    if (hit) hit = hit.value
	  }
	  return hit
	}

	function isStale (self, hit) {
	  if (!hit || (!hit.maxAge && !priv(self, 'maxAge'))) {
	    return false
	  }
	  var stale = false
	  var diff = Date.now() - hit.now
	  if (hit.maxAge) {
	    stale = diff > hit.maxAge
	  } else {
	    stale = priv(self, 'maxAge') && (diff > priv(self, 'maxAge'))
	  }
	  return stale
	}

	function trim (self) {
	  if (priv(self, 'length') > priv(self, 'max')) {
	    for (var walker = priv(self, 'lruList').tail;
	         priv(self, 'length') > priv(self, 'max') && walker !== null;) {
	      // We know that we're about to delete this one, and also
	      // what the next least recently used key will be, so just
	      // go ahead and set it now.
	      var prev = walker.prev
	      del(self, walker)
	      walker = prev
	    }
	  }
	}

	function del (self, node) {
	  if (node) {
	    var hit = node.value
	    if (priv(self, 'dispose')) {
	      priv(self, 'dispose').call(this, hit.key, hit.value)
	    }
	    priv(self, 'length', priv(self, 'length') - hit.length)
	    priv(self, 'cache').delete(hit.key)
	    priv(self, 'lruList').removeNode(node)
	  }
	}

	// classy, since V8 prefers predictable objects.
	function Entry (key, value, length, now, maxAge) {
	  this.key = key
	  this.value = value
	  this.length = length
	  this.now = now
	  this.maxAge = maxAge || 0
	}


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {if (process.env.npm_package_name === 'pseudomap' &&
	    process.env.npm_lifecycle_script === 'test')
	  process.env.TEST_PSEUDOMAP = 'true'

	if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
	  module.exports = Map
	} else {
	  module.exports = __webpack_require__(56)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 56 */
/***/ function(module, exports) {

	var hasOwnProperty = Object.prototype.hasOwnProperty

	module.exports = PseudoMap

	function PseudoMap (set) {
	  if (!(this instanceof PseudoMap)) // whyyyyyyy
	    throw new TypeError("Constructor PseudoMap requires 'new'")

	  this.clear()

	  if (set) {
	    if ((set instanceof PseudoMap) ||
	        (typeof Map === 'function' && set instanceof Map))
	      set.forEach(function (value, key) {
	        this.set(key, value)
	      }, this)
	    else if (Array.isArray(set))
	      set.forEach(function (kv) {
	        this.set(kv[0], kv[1])
	      }, this)
	    else
	      throw new TypeError('invalid argument')
	  }
	}

	PseudoMap.prototype.forEach = function (fn, thisp) {
	  thisp = thisp || this
	  Object.keys(this._data).forEach(function (k) {
	    if (k !== 'size')
	      fn.call(thisp, this._data[k].value, this._data[k].key)
	  }, this)
	}

	PseudoMap.prototype.has = function (k) {
	  return !!find(this._data, k)
	}

	PseudoMap.prototype.get = function (k) {
	  var res = find(this._data, k)
	  return res && res.value
	}

	PseudoMap.prototype.set = function (k, v) {
	  set(this._data, k, v)
	}

	PseudoMap.prototype.delete = function (k) {
	  var res = find(this._data, k)
	  if (res) {
	    delete this._data[res._index]
	    this._data.size--
	  }
	}

	PseudoMap.prototype.clear = function () {
	  var data = Object.create(null)
	  data.size = 0

	  Object.defineProperty(this, '_data', {
	    value: data,
	    enumerable: false,
	    configurable: true,
	    writable: false
	  })
	}

	Object.defineProperty(PseudoMap.prototype, 'size', {
	  get: function () {
	    return this._data.size
	  },
	  set: function (n) {},
	  enumerable: true,
	  configurable: true
	})

	PseudoMap.prototype.values =
	PseudoMap.prototype.keys =
	PseudoMap.prototype.entries = function () {
	  throw new Error('iterators are not implemented in this version')
	}

	// Either identical, or both NaN
	function same (a, b) {
	  return a === b || a !== a && b !== b
	}

	function Entry (k, v, i) {
	  this.key = k
	  this.value = v
	  this._index = i
	}

	function find (data, k) {
	  for (var i = 0, s = '_' + k, key = s;
	       hasOwnProperty.call(data, key);
	       key = s + i++) {
	    if (same(data[key].key, k))
	      return data[key]
	  }
	}

	function set (data, k, v) {
	  for (var i = 0, s = '_' + k, key = s;
	       hasOwnProperty.call(data, key);
	       key = s + i++) {
	    if (same(data[key].key, k)) {
	      data[key].value = v
	      return
	    }
	  }
	  data.size++
	  data[key] = new Entry(k, v, key)
	}


/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = Yallist

	Yallist.Node = Node
	Yallist.create = Yallist

	function Yallist (list) {
	  var self = this
	  if (!(self instanceof Yallist)) {
	    self = new Yallist()
	  }

	  self.tail = null
	  self.head = null
	  self.length = 0

	  if (list && typeof list.forEach === 'function') {
	    list.forEach(function (item) {
	      self.push(item)
	    })
	  } else if (arguments.length > 0) {
	    for (var i = 0, l = arguments.length; i < l; i++) {
	      self.push(arguments[i])
	    }
	  }

	  return self
	}

	Yallist.prototype.removeNode = function (node) {
	  if (node.list !== this) {
	    throw new Error('removing node which does not belong to this list')
	  }

	  var next = node.next
	  var prev = node.prev

	  if (next) {
	    next.prev = prev
	  }

	  if (prev) {
	    prev.next = next
	  }

	  if (node === this.head) {
	    this.head = next
	  }
	  if (node === this.tail) {
	    this.tail = prev
	  }

	  node.list.length --
	  node.next = null
	  node.prev = null
	  node.list = null
	}

	Yallist.prototype.unshiftNode = function (node) {
	  if (node === this.head) {
	    return
	  }

	  if (node.list) {
	    node.list.removeNode(node)
	  }

	  var head = this.head
	  node.list = this
	  node.next = head
	  if (head) {
	    head.prev = node
	  }

	  this.head = node
	  if (!this.tail) {
	    this.tail = node
	  }
	  this.length ++
	}

	Yallist.prototype.pushNode = function (node) {
	  if (node === this.tail) {
	    return
	  }

	  if (node.list) {
	    node.list.removeNode(node)
	  }

	  var tail = this.tail
	  node.list = this
	  node.prev = tail
	  if (tail) {
	    tail.next = node
	  }

	  this.tail = node
	  if (!this.head) {
	    this.head = node
	  }
	  this.length ++
	}

	Yallist.prototype.push = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    push(this, arguments[i])
	  }
	  return this.length
	}

	Yallist.prototype.unshift = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    unshift(this, arguments[i])
	  }
	  return this.length
	}

	Yallist.prototype.pop = function () {
	  if (!this.tail)
	    return undefined

	  var res = this.tail.value
	  this.tail = this.tail.prev
	  this.tail.next = null
	  this.length --
	  return res
	}

	Yallist.prototype.shift = function () {
	  if (!this.head)
	    return undefined

	  var res = this.head.value
	  this.head = this.head.next
	  this.head.prev = null
	  this.length --
	  return res
	}

	Yallist.prototype.forEach = function (fn, thisp) {
	  thisp = thisp || this
	  for (var walker = this.head, i = 0; walker !== null; i++) {
	    fn.call(thisp, walker.value, i, this)
	    walker = walker.next
	  }
	}

	Yallist.prototype.forEachReverse = function (fn, thisp) {
	  thisp = thisp || this
	  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
	    fn.call(thisp, walker.value, i, this)
	    walker = walker.prev
	  }
	}

	Yallist.prototype.get = function (n) {
	  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
	    // abort out of the list early if we hit a cycle
	    walker = walker.next
	  }
	  if (i === n && walker !== null) {
	    return walker.value
	  }
	}

	Yallist.prototype.getReverse = function (n) {
	  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
	    // abort out of the list early if we hit a cycle
	    walker = walker.prev
	  }
	  if (i === n && walker !== null) {
	    return walker.value
	  }
	}

	Yallist.prototype.map = function (fn, thisp) {
	  thisp = thisp || this
	  var res = new Yallist()
	  for (var walker = this.head; walker !== null; ) {
	    res.push(fn.call(thisp, walker.value, this))
	    walker = walker.next
	  }
	  return res
	}

	Yallist.prototype.mapReverse = function (fn, thisp) {
	  thisp = thisp || this
	  var res = new Yallist()
	  for (var walker = this.tail; walker !== null;) {
	    res.push(fn.call(thisp, walker.value, this))
	    walker = walker.prev
	  }
	  return res
	}

	Yallist.prototype.reduce = function (fn, initial) {
	  var acc
	  var walker = this.head
	  if (arguments.length > 1) {
	    acc = initial
	  } else if (this.head) {
	    walker = this.head.next
	    acc = this.head.value
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value')
	  }

	  for (var i = 0; walker !== null; i++) {
	    acc = fn(acc, walker.value, i)
	    walker = walker.next
	  }

	  return acc
	}

	Yallist.prototype.reduceReverse = function (fn, initial) {
	  var acc
	  var walker = this.tail
	  if (arguments.length > 1) {
	    acc = initial
	  } else if (this.tail) {
	    walker = this.tail.prev
	    acc = this.tail.value
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value')
	  }

	  for (var i = this.length - 1; walker !== null; i--) {
	    acc = fn(acc, walker.value, i)
	    walker = walker.prev
	  }

	  return acc
	}

	Yallist.prototype.toArray = function () {
	  var arr = new Array(this.length)
	  for (var i = 0, walker = this.head; walker !== null; i++) {
	    arr[i] = walker.value
	    walker = walker.next
	  }
	  return arr
	}

	Yallist.prototype.toArrayReverse = function () {
	  var arr = new Array(this.length)
	  for (var i = 0, walker = this.tail; walker !== null; i++) {
	    arr[i] = walker.value
	    walker = walker.prev
	  }
	  return arr
	}

	Yallist.prototype.slice = function (from, to) {
	  to = to || this.length
	  if (to < 0) {
	    to += this.length
	  }
	  from = from || 0
	  if (from < 0) {
	    from += this.length
	  }
	  var ret = new Yallist()
	  if (to < from || to < 0) {
	    return ret
	  }
	  if (from < 0) {
	    from = 0
	  }
	  if (to > this.length) {
	    to = this.length
	  }
	  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
	    walker = walker.next
	  }
	  for (; walker !== null && i < to; i++, walker = walker.next) {
	    ret.push(walker.value)
	  }
	  return ret
	}

	Yallist.prototype.sliceReverse = function (from, to) {
	  to = to || this.length
	  if (to < 0) {
	    to += this.length
	  }
	  from = from || 0
	  if (from < 0) {
	    from += this.length
	  }
	  var ret = new Yallist()
	  if (to < from || to < 0) {
	    return ret
	  }
	  if (from < 0) {
	    from = 0
	  }
	  if (to > this.length) {
	    to = this.length
	  }
	  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
	    walker = walker.prev
	  }
	  for (; walker !== null && i > from; i--, walker = walker.prev) {
	    ret.push(walker.value)
	  }
	  return ret
	}

	Yallist.prototype.reverse = function () {
	  var head = this.head
	  var tail = this.tail
	  for (var walker = head; walker !== null; walker = walker.prev) {
	    var p = walker.prev
	    walker.prev = walker.next
	    walker.next = p
	  }
	  this.head = tail
	  this.tail = head
	  return this
	}

	function push (self, item) {
	  self.tail = new Node(item, self.tail, null, self)
	  if (!self.head) {
	    self.head = self.tail
	  }
	  self.length ++
	}

	function unshift (self, item) {
	  self.head = new Node(item, null, self.head, self)
	  if (!self.tail) {
	    self.tail = self.head
	  }
	  self.length ++
	}

	function Node (value, prev, next, list) {
	  if (!(this instanceof Node)) {
	    return new Node(value, prev, next, list)
	  }

	  this.list = list
	  this.value = value

	  if (prev) {
	    prev.next = this
	    this.prev = prev
	  } else {
	    this.prev = null
	  }

	  if (next) {
	    next.prev = this
	    this.next = next
	  } else {
	    this.next = null
	  }
	}


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Buffer) {//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php

	/*global window, require, define */
	(function(_window) {
	  'use strict';

	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;

	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }

	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }

	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }

	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(59).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }

	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }

	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }

	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;

	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });

	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }

	    return buf;
	  }

	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }

	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html

	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();

	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];

	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;

	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];

	    options = options || {};

	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }

	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }

	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }

	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;

	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;

	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;

	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;

	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;

	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;

	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;

	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }

	    return buf ? buf : unparse(b);
	  }

	  // **`v4()` - Generate random UUID**

	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;

	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};

	    var rnds = options.random || (options.rng || _rng)();

	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;

	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }

	    return buf || unparse(rnds);
	  }

	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;

	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;

	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };

	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(60)

	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}

	exports.createHash = __webpack_require__(62)

	exports.createHmac = __webpack_require__(71)

	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}

	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}

	var p = __webpack_require__(72)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync


	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(61)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5).Buffer))

/***/ },
/* 61 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(63)

	var md5 = toConstructor(__webpack_require__(68))
	var rmd160 = toConstructor(__webpack_require__(70))

	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}

	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}

	var Buffer = __webpack_require__(5).Buffer
	var Hash   = __webpack_require__(64)(Buffer)

	exports.sha1 = __webpack_require__(65)(Buffer, Hash)
	exports.sha256 = __webpack_require__(66)(Buffer, Hash)
	exports.sha512 = __webpack_require__(67)(Buffer, Hash)


/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }

	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }

	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)

	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }

	      s += ch
	      f += ch

	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s

	    return this
	  }

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)

	    var hash = this._update(this._block) || this._hash()

	    return enc ? hash.toString(enc) : hash
	  }

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }

	  return Hash
	}


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(10).inherits

	module.exports = function (Buffer, Hash) {

	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

	  var POOL = []

	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()

	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)

	    this._h = null
	    this.init()
	  }

	  inherits(Sha1, Hash)

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0

	    Hash.prototype.init.call(this)
	    return this
	  }

	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e

	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e

	    var w = this._w

	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )

	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }

	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }

	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }

	  return Sha1
	}


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(10).inherits

	module.exports = function (Buffer, Hash) {

	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]

	  var W = new Array(64)

	  function Sha256() {
	    this.init()

	    this._w = W //new Array(64)

	    Hash.call(this, 16*4, 14*4)
	  }

	  inherits(Sha256, Hash)

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }

	  function R (X, n) {
	    return (X >>> n);
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }

	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }

	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }

	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }

	  Sha256.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }

	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0

	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)

	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)

	    return H
	  }

	  return Sha256

	}


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(10).inherits

	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]

	  var W = new Array(160)

	  function Sha512() {
	    this.init()
	    this._w = W

	    Hash.call(this, 128, 112)
	  }

	  inherits(Sha512, Hash)

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  Sha512.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2

	      var Wi, Wil

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]

	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]

	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

	        W[j] = Wi
	        W[j + 1] = Wil
	      }

	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]

	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)

	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }

	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0

	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }

	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)

	    return H
	  }

	  return Sha512

	}


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(69);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160



	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};

	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function (H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};

	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}

	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}

	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}

	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}

	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}

	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );

	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(62)

	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)

	module.exports = Hmac

	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg

	  var blocksize = (alg === 'sha512') ? 128 : 64

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(73)

	module.exports = function (crypto, exports) {
	  exports = exports || {}

	  var exported = pbkdf2Export(crypto)

	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync

	  return exports
	}


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }

	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')

	    setTimeout(function() {
	      var result

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }

	      callback(undefined, result)
	    })
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')

	    if (iterations < 0)
	      throw new TypeError('Bad iterations')

	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')

	    if (keylen < 0)
	      throw new TypeError('Bad key length')

	    digest = digest || 'sha1'

	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)

	      var U = crypto.createHmac(digest, password).update(block1).digest()

	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen

	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }

	      U.copy(T, 0, 0, hLen)

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }

	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }

	    return DK
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var HttpClient = __webpack_require__(75);
	var JsonClient = __webpack_require__(114);
	var StringClient = __webpack_require__(115);


	///--- Exports

	module.exports = {
	    HttpClient: HttpClient,
	    JsonClient: JsonClient,
	    StringClient: StringClient
	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, __dirname, Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var EventEmitter = __webpack_require__(14).EventEmitter;
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var http = __webpack_require__(76);
	var https = __webpack_require__(87);
	var os = __webpack_require__(33);
	var path = __webpack_require__(39);
	var querystring = __webpack_require__(88);
	var url = __webpack_require__(81);
	var util = __webpack_require__(10);

	var assert = __webpack_require__(4);
	var backoff = __webpack_require__(91);
	var mime = __webpack_require__(100);
	var once = __webpack_require__(52);
	var tunnelAgent = __webpack_require__(102);

	var dtrace = __webpack_require__(103);
	var errors = __webpack_require__(105);
	var bunyan = __webpack_require__(31);

	// Use native KeepAlive in Node as of 0.11.6
	var semver = __webpack_require__(112);
	var nodeVersion = process.version;
	var nativeKeepAlive = semver.satisfies(nodeVersion, '>=0.11.6');
	var KeepAliveAgent;
	var KeepAliveAgentSecure;
	var httpMaxSockets = http.globalAgent.maxSockets;
	var httpsMaxSockets = https.globalAgent.maxSockets;

	if (!nativeKeepAlive) {
	    KeepAliveAgent = __webpack_require__(113);
	    KeepAliveAgentSecure = KeepAliveAgent.Secure;
	} else {
	    KeepAliveAgent = http.Agent;
	    KeepAliveAgentSecure = https.Agent;

	    // maxSockets defaults to Infinity, but that doesn't
	    // lend itself well to KeepAlive, since sockets will
	    // never be reused.
	    httpMaxSockets = Math.min(httpMaxSockets, 1024);
	    httpsMaxSockets = Math.min(httpsMaxSockets, 1024);
	}

	///--- Globals

	// jscs:disable maximumLineLength
	var VERSION = JSON.parse(fs.readFileSync(path.normalize(__dirname + '/../../package.json'), 'utf8')).version;
	// jscs:enable maximumLineLength

	///--- Helpers

	function cloneRetryOptions(options, defaults) {
	    if (options === false) {
	        return (false);
	    }

	    assert.optionalObject(options, 'options.retry');
	    var r = options || {};
	    assert.optionalNumber(r.minTimeout, 'options.retry.minTimeout');
	    assert.optionalNumber(r.maxTimeout, 'options.retry.maxTimeout');
	    assert.optionalNumber(r.retries, 'options.retry.retries');
	    assert.optionalObject(defaults, 'defaults');
	    defaults = defaults || {};

	    return ({
	        minTimeout: r.minTimeout || defaults.minTimeout || 1000,
	        maxTimeout: r.maxTimeout || defaults.maxTimeout || Infinity,
	        retries: r.retries || defaults.retries || 4
	    });
	}


	function defaultUserAgent() {
	    var UA = 'restify/' + VERSION +
	        ' (' + os.arch() + '-' + os.platform() + '; ' +
	        'v8/' + process.versions.v8 + '; ' +
	        'OpenSSL/' + process.versions.openssl + ') ' +
	        'node/' + process.versions.node;

	    return (UA);
	}


	function ConnectTimeoutError(ms) {
	    if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, ConnectTimeoutError);
	    }

	    this.message = 'connect timeout after ' + ms + 'ms';
	    this.name = 'ConnectTimeoutError';
	}
	util.inherits(ConnectTimeoutError, Error);

	function RequestTimeoutError(ms) {
	    if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, RequestTimeoutError);
	    }

	    this.message = 'request timeout after ' + ms + 'ms';
	    this.name = 'RequestTimeoutError';
	}
	util.inherits(RequestTimeoutError, Error);

	function rawRequest(opts, cb) {
	    assert.object(opts, 'options');
	    assert.object(opts.log, 'options.log');
	    assert.func(cb, 'callback');

	    cb = once(cb);

	    var id = dtrace.nextId();
	    var log = opts.log;
	    var proto = opts.protocol === 'https:' ? https : http;
	    var connectionTimer;
	    var requestTimer;
	    var req;

	    if (opts.cert && opts.key) {
	        opts.agent = false;
	    }

	    if (opts.connectTimeout) {
	        connectionTimer = setTimeout(function connectTimeout() {
	            connectionTimer = null;

	            if (req) {
	                req.abort();
	            }

	            var err = new ConnectTimeoutError(opts.connectTimeout);
	            dtrace._rstfy_probes['client-error'].fire(function () {
	                return ([id, err.toString()]);
	            });
	            cb(err, req);
	        }, opts.connectTimeout);
	    }

	    dtrace._rstfy_probes['client-request'].fire(function () {
	        return ([
	            opts.method,
	            opts.path,
	            opts.headers,
	            id
	        ]);
	    });

	    var emit_result = once(function _emit_result(_err, _req, _res) {
	        _req.emit('result', _err, _res);
	    });

	    req = proto.request(opts, function onResponse(res) {
	        clearTimeout(connectionTimer);
	        clearTimeout(requestTimer);

	        dtrace._rstfy_probes['client-response'].fire(function () {
	            return ([ id, res.statusCode, res.headers ]);
	        });
	        log.trace({client_res: res}, 'Response received');

	        res.log = log;

	        var err;

	        if (res.statusCode >= 400) {
	            err = errors.codeToHttpError(res.statusCode);
	        }

	        req.removeAllListeners('socket');

	        emit_result((err || null), req, res);
	    });
	    req.log = log;

	    req.on('error', function onError(err) {
	        dtrace._rstfy_probes['client-error'].fire(function () {
	            return ([id, (err || {}).toString()]);
	        });
	        log.trace({err: err}, 'Request failed');
	        clearTimeout(connectionTimer);
	        clearTimeout(requestTimer);

	        cb(err, req);

	        if (req) {
	            process.nextTick(function () {
	                emit_result(err, req, null);
	            });
	        }
	    });

	    req.once('upgrade', function onUpgrade(res, socket, _head) {
	        clearTimeout(connectionTimer);
	        clearTimeout(requestTimer);
	        dtrace._rstfy_probes['client-response'].fire(function () {
	            return ([ id, res.statusCode, res.headers ]);
	        });
	        log.trace({client_res: res}, 'upgrade response received');

	        res.log = log;

	        var err;

	        if (res.statusCode >= 400) {
	            err = errors.codeToHttpError(res.statusCode);
	        }

	        req.removeAllListeners('error');
	        req.removeAllListeners('socket');
	        req.emit('upgradeResult', (err || null), res, socket, _head);
	    });

	    req.once('socket', function onSocket(socket) {
	        var _socket = socket;

	        if (opts.protocol === 'https:' && socket.socket) {
	            _socket = socket.socket;
	        }

	        if (_socket.writable && !_socket._connecting) {
	            clearTimeout(connectionTimer);
	            cb(null, req);
	            return;
	        }

	        _socket.once('connect', function onConnect() {
	            clearTimeout(connectionTimer);

	            if (opts._keep_alive) {
	                _socket.setKeepAlive(true);
	                socket.setKeepAlive(true);
	            }

	            if (opts.requestTimeout) {
	                requestTimer = setTimeout(function requestTimeout() {
	                    requestTimer = null;

	                    var err = new RequestTimeoutError(opts.requestTimeout);
	                    dtrace._rstfy_probes['client-error'].fire(function () {
	                        return ([id, err.toString()]);
	                    });

	                    cb(err, req);

	                    if (req) {
	                        req.abort();
	                        process.nextTick(function () {
	                            req.emit('result', err, null);
	                        });
	                    }
	                }, opts.requestTimeout);
	            }

	            cb(null, req);
	        });
	    });

	    if (opts.signRequest) {
	        opts.signRequest(req);
	    }

	    if (log.trace()) {
	        log.trace({client_req: opts}, 'request sent');
	    }
	} // end `rawRequest`


	//  Check if url is excluded by the no_proxy environment variable
	function isProxyForURL(address) {
	    var noProxy = process.env.NO_PROXY || process.env.no_proxy || null;

	    // wildcard
	    if (noProxy === '*') {
	        return (null);
	    }

	    // otherwise, parse the noProxy value to see if it applies to the URL
	    if (noProxy !== null) {
	        var noProxyItem, hostname, port, noProxyItemParts,
	            noProxyHost, noProxyPort, noProxyList;

	        // canonicalize the hostname
	        /* JSSTYLED */
	        hostname = address.hostname.replace(/^\.*/, '.').toLowerCase();
	        noProxyList = noProxy.split(',');

	        for (var i = 0, len = noProxyList.length; i < len; i++) {
	            noProxyItem = noProxyList[i].trim().toLowerCase();

	            // no_proxy can be granular at the port level
	            if (noProxyItem.indexOf(':') > -1) {
	                noProxyItemParts = noProxyItem.split(':', 2);
	                /* JSSTYLED */
	                noProxyHost = noProxyItemParts[0].replace(/^\.*/, '.');
	                noProxyPort = noProxyItemParts[1];
	                port = address.port ||
	                    (address.protocol === 'https:' ? '443' : '80');

	                // match - ports are same and host ends with no_proxy entry.
	                if (port === noProxyPort &&
	                    hostname.indexOf(noProxyHost) ===
	                    hostname.length - noProxyHost.length) {
	                    return (null);
	                }
	            } else {
	                /* JSSTYLED */
	                noProxyItem = noProxyItem.replace(/^\.*/, '.');
	                var isMatchedAt = hostname.indexOf(noProxyItem);

	                if (isMatchedAt > -1 &&
	                    isMatchedAt === hostname.length - noProxyItem.length) {
	                    return (null);
	                }
	            }
	        }
	    }
	    return (true);
	}
	///--- API

	function HttpClient(options) {
	    assert.object(options, 'options');
	    assert.optionalObject(options.headers, 'options.headers');
	    assert.object(options.log, 'options.log');
	    assert.optionalFunc(options.signRequest, 'options.signRequest');
	    assert.optionalString(options.socketPath, 'options.socketPath');
	    assert.optionalString(options.url, 'options.url');

	    EventEmitter.call(this);

	    var self = this;

	    this.agent = options.agent;
	    this.ca = options.ca;
	    this.cert = options.cert;
	    this.ciphers = options.ciphers;
	    this.connectTimeout = options.connectTimeout || false;
	    this.requestTimeout = options.requestTimeout || false;
	    this.headers = options.headers || {};
	    this.log = options.log;

	    if (!this.log.serializers) {
	        // Ensure logger has a reasonable serializer for `client_res`
	        // and `client_req` logged in this module.
	        this.log = this.log.child({serializers: bunyan.serializers});
	    }
	    this.key = options.key;
	    this.name = options.name || 'HttpClient';
	    this.passphrase = options.passphrase;
	    this.pfx = options.pfx;

	    if (options.rejectUnauthorized !== undefined) {
	        this.rejectUnauthorized = options.rejectUnauthorized;
	    } else {
	        this.rejectUnauthorized = true;
	    }

	    this.retry = cloneRetryOptions(options.retry);
	    this.signRequest = options.signRequest || false;
	    this.socketPath = options.socketPath || false;
	    this.url = options.url ? url.parse(options.url) : {};

	    if (process.env.https_proxy) {
	        this.proxy = url.parse(process.env.https_proxy);
	    } else if (process.env.http_proxy) {
	        this.proxy = url.parse(process.env.http_proxy);
	    } else if (options.proxy) {
	        this.proxy = options.proxy;
	    } else {
	        this.proxy = false;
	    }

	    if (this.proxy && !isProxyForURL(self.url)) {
	        this.proxy = false;
	    }

	    if (options.accept) {
	        if (options.accept.indexOf('/') === -1) {
	            options.accept = mime.lookup(options.accept);
	        }

	        this.headers.accept = options.accept;
	    }

	    if (options.contentType) {
	        if (options.contentType.indexOf('/') === -1) {
	            options.type = mime.lookup(options.contentType);
	        }

	        this.headers['content-type'] = options.contentType;
	    }

	    if (options.userAgent !== false) {
	        this.headers['user-agent'] = options.userAgent ||
	            defaultUserAgent();
	    }

	    if (options.version) {
	        this.headers['accept-version'] = options.version;
	    }

	    if (this.agent === undefined) {
	        var Agent;
	        var maxSockets;

	        if (this.proxy) {
	            if (this.url.protocol === 'https:') {
	                if (this.proxy.protocol === 'https:') {
	                    Agent = tunnelAgent.httpsOverHttps;
	                } else {
	                    Agent = tunnelAgent.httpsOverHttp;
	                }
	            } else {
	                if (this.proxy.protocol === 'https:') {
	                    Agent = tunnelAgent.httpOverHttps;
	                } else {
	                    Agent = tunnelAgent.httpOverHttp;
	                }
	            }
	        } else if (this.url.protocol === 'https:') {
	            Agent = KeepAliveAgentSecure;
	            maxSockets = httpsMaxSockets;
	        } else {
	            Agent = KeepAliveAgent;
	            maxSockets = httpMaxSockets;
	        }

	        if (this.proxy) {
	            this.agent = new Agent({
	                proxy: self.proxy,
	                rejectUnauthorized: self.rejectUnauthorized,
	                ca: self.ca
	            });
	        } else {
	            this.agent = new Agent({
	                cert: self.cert,
	                ca: self.ca,
	                ciphers: self.ciphers,
	                key: self.key,
	                maxSockets: maxSockets,

	                // require('keep-alive-agent')
	                maxKeepAliveRequests: 0,
	                maxKeepAliveTime: 0,

	                // native keepalive
	                keepAliveMsecs: 1000,
	                keepAlive: true,

	                passphrase: self.passphrase,
	                pfx: self.pfx,
	                rejectUnauthorized: self.rejectUnauthorized
	            });
	            this._keep_alive = true;
	        }
	    }
	}
	util.inherits(HttpClient, EventEmitter);

	module.exports = HttpClient;


	HttpClient.prototype.close = function close() {
	    var sockets = this.agent.sockets;
	    Object.keys((sockets || {})).forEach(function (k) {
	        if (Array.isArray(sockets[k])) {
	            sockets[k].forEach(function (s) {
	                s.end();
	            });
	        }
	    });

	    sockets = this.agent.idleSockets || this.agent.freeSockets;
	    Object.keys((sockets || {})).forEach(function (k) {
	        sockets[k].forEach(function (s) {
	            s.end();
	        });
	    });
	};


	HttpClient.prototype.del = function del(options, callback) {
	    var opts = this._options('DELETE', options);

	    return (this.read(opts, callback));
	};


	HttpClient.prototype.get = function get(options, callback) {
	    var opts = this._options('GET', options);

	    return (this.read(opts, callback));
	};


	HttpClient.prototype.head = function head(options, callback) {
	    var opts = this._options('HEAD', options);

	    return (this.read(opts, callback));
	};

	HttpClient.prototype.opts = function http_options(options, callback) {
	    var _opts = this._options('OPTIONS', options);

	    return (this.read(_opts, callback));
	};


	HttpClient.prototype.post = function post(options, callback) {
	    var opts = this._options('POST', options);

	    return (this.request(opts, callback));
	};


	HttpClient.prototype.put = function put(options, callback) {
	    var opts = this._options('PUT', options);

	    return (this.request(opts, callback));
	};


	HttpClient.prototype.patch = function patch(options, callback) {
	    var opts = this._options('PATCH', options);


	    return (this.request(opts, callback));
	};


	HttpClient.prototype.read = function read(options, callback) {
	    var r = this.request(options, function readRequestCallback(err, req) {
	        if (!err) {
	            req.end();
	        }

	        return (callback(err, req));
	    });
	    return (r);
	};


	HttpClient.prototype.basicAuth = function basicAuth(username, password) {
	    if (username === false) {
	        delete this.headers.authorization;
	    } else {
	        assert.string(username, 'username');
	        assert.string(password, 'password');

	        var buffer = new Buffer(username + ':' + password, 'utf8');
	        this.headers.authorization = 'Basic ' +
	            buffer.toString('base64');
	    }

	    return (this);
	};


	HttpClient.prototype.request = function request(opts, cb) {
	    assert.object(opts, 'options');
	    assert.func(cb, 'callback');

	    cb = once(cb);

	    if (opts.retry === false) {
	        rawRequest(opts, cb);
	        return;
	    }

	    var call;
	    var retry = cloneRetryOptions(opts.retry);

	    opts._keep_alive = this._keep_alive;
	    call = backoff.call(rawRequest, opts, cb);
	    call.setStrategy(new backoff.ExponentialStrategy({
	        initialDelay: retry.minTimeout,
	        maxDelay: retry.maxTimeout
	    }));
	    call.failAfter(retry.retries);
	    call.on('backoff', this.emit.bind(this, 'attempt'));

	    call.start();
	};


	HttpClient.prototype._options = function (method, options) {
	    if (typeof (options) !== 'object') {
	        options = { path: options };
	    }

	    var self = this;
	    var opts = {
	        agent: options.agent !== undefined ? options.agent : self.agent,
	        ca: options.ca || self.ca,
	        cert: options.cert || self.cert,
	        ciphers: options.ciphers || self.ciphers,
	        connectTimeout: options.connectTimeout || self.connectTimeout,
	        requestTimeout: options.requestTimeout || self.requestTimeout,
	        headers: options.headers || {},
	        key: options.key || self.key,
	        log: options.log || self.log,
	        method: method,
	        passphrase: options.passphrase || self.passphrase,
	        path: options.path || self.path,
	        pfx: options.pfx || self.pfx,
	        rejectUnauthorized: options.rejectUnauthorized ||
	            self.rejectUnauthorized,
	        retry: options.retry !== false ? options.retry : false,
	        signRequest: options.signRequest || self.signRequest
	    };

	    if (!opts.retry && opts.retry !== false) {
	        opts.retry = self.retry;
	    }


	    // Backwards compatibility with restify < 1.0
	    if (options.query &&
	        Object.keys(options.query).length &&
	        opts.path.indexOf('?') === -1) {
	        opts.path += '?' + querystring.stringify(options.query);
	    }

	    if (this.socketPath) {
	        opts.socketPath = this.socketPath;
	    }

	    Object.keys(this.url).forEach(function (k) {
	        if (!opts[k]) {
	            opts[k] = self.url[k];
	        }
	    });

	    Object.keys(self.headers).forEach(function (k) {
	        if (!opts.headers[k]) {
	            opts.headers[k] = self.headers[k];
	        }
	    });

	    if (!opts.headers.date) {
	        opts.headers.date = new Date().toUTCString();
	    }

	    if (method === 'GET' || method === 'HEAD' || method === 'DELETE') {
	        if (opts.headers['content-type']) {
	            delete opts.headers['content-type'];
	        }

	        if (opts.headers['content-md5']) {
	            delete opts.headers['content-md5'];
	        }

	        if (opts.headers['content-length'] && method !== 'DELETE') {
	            delete opts.headers['content-length'];
	        }

	        if (opts.headers['transfer-encoding']) {
	            delete opts.headers['transfer-encoding'];
	        }
	    }

	    return (opts);
	};

	// vim: set ts=4 sts=4 sw=4 et:

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), "/", __webpack_require__(5).Buffer))

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var http = module.exports;
	var EventEmitter = __webpack_require__(14).EventEmitter;
	var Request = __webpack_require__(77);
	var url = __webpack_require__(81)

	http.request = function (params, cb) {
	    if (typeof params === 'string') {
	        params = url.parse(params)
	    }
	    if (!params) params = {};
	    if (!params.host && !params.port) {
	        params.port = parseInt(window.location.port, 10);
	    }
	    if (!params.host && params.hostname) {
	        params.host = params.hostname;
	    }

	    if (!params.protocol) {
	        if (params.scheme) {
	            params.protocol = params.scheme + ':';
	        } else {
	            params.protocol = window.location.protocol;
	        }
	    }

	    if (!params.host) {
	        params.host = window.location.hostname || window.location.host;
	    }
	    if (/:/.test(params.host)) {
	        if (!params.port) {
	            params.port = params.host.split(':')[1];
	        }
	        params.host = params.host.split(':')[0];
	    }
	    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
	    
	    var req = new Request(new xhrHttp, params);
	    if (cb) req.on('response', cb);
	    return req;
	};

	http.get = function (params, cb) {
	    params.method = 'GET';
	    var req = http.request(params, cb);
	    req.end();
	    return req;
	};

	http.Agent = function () {};
	http.Agent.defaultMaxSockets = 4;

	var xhrHttp = (function () {
	    if (typeof window === 'undefined') {
	        throw new Error('no window object present');
	    }
	    else if (window.XMLHttpRequest) {
	        return window.XMLHttpRequest;
	    }
	    else if (window.ActiveXObject) {
	        var axs = [
	            'Msxml2.XMLHTTP.6.0',
	            'Msxml2.XMLHTTP.3.0',
	            'Microsoft.XMLHTTP'
	        ];
	        for (var i = 0; i < axs.length; i++) {
	            try {
	                var ax = new(window.ActiveXObject)(axs[i]);
	                return function () {
	                    if (ax) {
	                        var ax_ = ax;
	                        ax = null;
	                        return ax_;
	                    }
	                    else {
	                        return new(window.ActiveXObject)(axs[i]);
	                    }
	                };
	            }
	            catch (e) {}
	        }
	        throw new Error('ajax not supported in this browser')
	    }
	    else {
	        throw new Error('ajax not supported in this browser');
	    }
	})();

	http.STATUS_CODES = {
	    100 : 'Continue',
	    101 : 'Switching Protocols',
	    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
	    200 : 'OK',
	    201 : 'Created',
	    202 : 'Accepted',
	    203 : 'Non-Authoritative Information',
	    204 : 'No Content',
	    205 : 'Reset Content',
	    206 : 'Partial Content',
	    207 : 'Multi-Status',               // RFC 4918
	    300 : 'Multiple Choices',
	    301 : 'Moved Permanently',
	    302 : 'Moved Temporarily',
	    303 : 'See Other',
	    304 : 'Not Modified',
	    305 : 'Use Proxy',
	    307 : 'Temporary Redirect',
	    400 : 'Bad Request',
	    401 : 'Unauthorized',
	    402 : 'Payment Required',
	    403 : 'Forbidden',
	    404 : 'Not Found',
	    405 : 'Method Not Allowed',
	    406 : 'Not Acceptable',
	    407 : 'Proxy Authentication Required',
	    408 : 'Request Time-out',
	    409 : 'Conflict',
	    410 : 'Gone',
	    411 : 'Length Required',
	    412 : 'Precondition Failed',
	    413 : 'Request Entity Too Large',
	    414 : 'Request-URI Too Large',
	    415 : 'Unsupported Media Type',
	    416 : 'Requested Range Not Satisfiable',
	    417 : 'Expectation Failed',
	    418 : 'I\'m a teapot',              // RFC 2324
	    422 : 'Unprocessable Entity',       // RFC 4918
	    423 : 'Locked',                     // RFC 4918
	    424 : 'Failed Dependency',          // RFC 4918
	    425 : 'Unordered Collection',       // RFC 4918
	    426 : 'Upgrade Required',           // RFC 2817
	    428 : 'Precondition Required',      // RFC 6585
	    429 : 'Too Many Requests',          // RFC 6585
	    431 : 'Request Header Fields Too Large',// RFC 6585
	    500 : 'Internal Server Error',
	    501 : 'Not Implemented',
	    502 : 'Bad Gateway',
	    503 : 'Service Unavailable',
	    504 : 'Gateway Time-out',
	    505 : 'HTTP Version Not Supported',
	    506 : 'Variant Also Negotiates',    // RFC 2295
	    507 : 'Insufficient Storage',       // RFC 4918
	    509 : 'Bandwidth Limit Exceeded',
	    510 : 'Not Extended',               // RFC 2774
	    511 : 'Network Authentication Required' // RFC 6585
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(13);
	var Response = __webpack_require__(78);
	var Base64 = __webpack_require__(79);
	var inherits = __webpack_require__(80);

	var Request = module.exports = function (xhr, params) {
	    var self = this;
	    self.writable = true;
	    self.xhr = xhr;
	    self.body = [];
	    
	    self.uri = (params.protocol || 'http:') + '//'
	        + params.host
	        + (params.port ? ':' + params.port : '')
	        + (params.path || '/')
	    ;
	    
	    if (typeof params.withCredentials === 'undefined') {
	        params.withCredentials = true;
	    }

	    try { xhr.withCredentials = params.withCredentials }
	    catch (e) {}
	    
	    if (params.responseType) try { xhr.responseType = params.responseType }
	    catch (e) {}
	    
	    xhr.open(
	        params.method || 'GET',
	        self.uri,
	        true
	    );

	    xhr.onerror = function(event) {
	        self.emit('error', new Error('Network error'));
	    };

	    self._headers = {};
	    
	    if (params.headers) {
	        var keys = objectKeys(params.headers);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (!self.isSafeRequestHeader(key)) continue;
	            var value = params.headers[key];
	            self.setHeader(key, value);
	        }
	    }
	    
	    if (params.auth) {
	        //basic auth
	        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
	    }

	    var res = new Response;
	    res.on('close', function () {
	        self.emit('close');
	    });
	    
	    res.on('ready', function () {
	        self.emit('response', res);
	    });

	    res.on('error', function (err) {
	        self.emit('error', err);
	    });
	    
	    xhr.onreadystatechange = function () {
	        // Fix for IE9 bug
	        // SCRIPT575: Could not complete the operation due to error c00c023f
	        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
	        if (xhr.__aborted) return;
	        res.handle(xhr);
	    };
	};

	inherits(Request, Stream);

	Request.prototype.setHeader = function (key, value) {
	    this._headers[key.toLowerCase()] = value
	};

	Request.prototype.getHeader = function (key) {
	    return this._headers[key.toLowerCase()]
	};

	Request.prototype.removeHeader = function (key) {
	    delete this._headers[key.toLowerCase()]
	};

	Request.prototype.write = function (s) {
	    this.body.push(s);
	};

	Request.prototype.destroy = function (s) {
	    this.xhr.__aborted = true;
	    this.xhr.abort();
	    this.emit('close');
	};

	Request.prototype.end = function (s) {
	    if (s !== undefined) this.body.push(s);

	    var keys = objectKeys(this._headers);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = this._headers[key];
	        if (isArray(value)) {
	            for (var j = 0; j < value.length; j++) {
	                this.xhr.setRequestHeader(key, value[j]);
	            }
	        }
	        else this.xhr.setRequestHeader(key, value)
	    }

	    if (this.body.length === 0) {
	        this.xhr.send('');
	    }
	    else if (typeof this.body[0] === 'string') {
	        this.xhr.send(this.body.join(''));
	    }
	    else if (isArray(this.body[0])) {
	        var body = [];
	        for (var i = 0; i < this.body.length; i++) {
	            body.push.apply(body, this.body[i]);
	        }
	        this.xhr.send(body);
	    }
	    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
	        var len = 0;
	        for (var i = 0; i < this.body.length; i++) {
	            len += this.body[i].length;
	        }
	        var body = new(this.body[0].constructor)(len);
	        var k = 0;
	        
	        for (var i = 0; i < this.body.length; i++) {
	            var b = this.body[i];
	            for (var j = 0; j < b.length; j++) {
	                body[k++] = b[j];
	            }
	        }
	        this.xhr.send(body);
	    }
	    else if (isXHR2Compatible(this.body[0])) {
	        this.xhr.send(this.body[0]);
	    }
	    else {
	        var body = '';
	        for (var i = 0; i < this.body.length; i++) {
	            body += this.body[i].toString();
	        }
	        this.xhr.send(body);
	    }
	};

	// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
	Request.unsafeHeaders = [
	    "accept-charset",
	    "accept-encoding",
	    "access-control-request-headers",
	    "access-control-request-method",
	    "connection",
	    "content-length",
	    "cookie",
	    "cookie2",
	    "content-transfer-encoding",
	    "date",
	    "expect",
	    "host",
	    "keep-alive",
	    "origin",
	    "referer",
	    "te",
	    "trailer",
	    "transfer-encoding",
	    "upgrade",
	    "user-agent",
	    "via"
	];

	Request.prototype.isSafeRequestHeader = function (headerName) {
	    if (!headerName) return false;
	    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
	};

	var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    return keys;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};

	var indexOf = function (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0; i < xs.length; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	};

	var isXHR2Compatible = function (obj) {
	    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
	    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
	    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(13);
	var util = __webpack_require__(10);

	var Response = module.exports = function (res) {
	    this.offset = 0;
	    this.readable = true;
	};

	util.inherits(Response, Stream);

	var capable = {
	    streaming : true,
	    status2 : true
	};

	function parseHeaders (res) {
	    var lines = res.getAllResponseHeaders().split(/\r?\n/);
	    var headers = {};
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	        if (line === '') continue;
	        
	        var m = line.match(/^([^:]+):\s*(.*)/);
	        if (m) {
	            var key = m[1].toLowerCase(), value = m[2];
	            
	            if (headers[key] !== undefined) {
	            
	                if (isArray(headers[key])) {
	                    headers[key].push(value);
	                }
	                else {
	                    headers[key] = [ headers[key], value ];
	                }
	            }
	            else {
	                headers[key] = value;
	            }
	        }
	        else {
	            headers[line] = true;
	        }
	    }
	    return headers;
	}

	Response.prototype.getResponse = function (xhr) {
	    var respType = String(xhr.responseType).toLowerCase();
	    if (respType === 'blob') return xhr.responseBlob || xhr.response;
	    if (respType === 'arraybuffer') return xhr.response;
	    return xhr.responseText;
	}

	Response.prototype.getHeader = function (key) {
	    return this.headers[key.toLowerCase()];
	};

	Response.prototype.handle = function (res) {
	    if (res.readyState === 2 && capable.status2) {
	        try {
	            this.statusCode = res.status;
	            this.headers = parseHeaders(res);
	        }
	        catch (err) {
	            capable.status2 = false;
	        }
	        
	        if (capable.status2) {
	            this.emit('ready');
	        }
	    }
	    else if (capable.streaming && res.readyState === 3) {
	        try {
	            if (!this.statusCode) {
	                this.statusCode = res.status;
	                this.headers = parseHeaders(res);
	                this.emit('ready');
	            }
	        }
	        catch (err) {}
	        
	        try {
	            this._emitData(res);
	        }
	        catch (err) {
	            capable.streaming = false;
	        }
	    }
	    else if (res.readyState === 4) {
	        if (!this.statusCode) {
	            this.statusCode = res.status;
	            this.emit('ready');
	        }
	        this._emitData(res);
	        
	        if (res.error) {
	            this.emit('error', this.getResponse(res));
	        }
	        else this.emit('end');
	        
	        this.emit('close');
	    }
	};

	Response.prototype._emitData = function (res) {
	    var respBody = this.getResponse(res);
	    if (respBody.toString().match(/ArrayBuffer/)) {
	        this.emit('data', new Uint8Array(respBody, this.offset));
	        this.offset = respBody.byteLength;
	        return;
	    }
	    if (respBody.length > this.offset) {
	        this.emit('data', respBody.slice(this.offset));
	        this.offset = respBody.length;
	    }
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	;(function () {

	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error;
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (
	  object.btoa = function (input) {
	    for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next input index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      input.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	    ) {
	      charCode = input.charCodeAt(idx += 3/4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });

	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (
	  object.atob = function (input) {
	    input = input.replace(/=+$/, '');
	    if (input.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      buffer = input.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	        // and if not first of each 4 characters,
	        // convert the first 8 bits to one ascii character
	        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	    ) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });

	}());


/***/ },
/* 80 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(82);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(84);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(83)(module), (function() { return this; }())))

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(85);
	exports.encode = exports.stringify = __webpack_require__(86);


/***/ },
/* 85 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 86 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var http = __webpack_require__(76);

	var https = module.exports;

	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};

	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    return http.request.call(this, params, cb);
	}


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(89);
	exports.encode = exports.stringify = __webpack_require__(90);


/***/ },
/* 89 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};

	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 90 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return map(objectKeys(obj), function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (isArray(obj[k])) {
	        return map(obj[k], function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};

	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};

	function map (xs, f) {
	  if (xs.map) return xs.map(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    res.push(f(xs[i], i));
	  }
	  return res;
	}

	var objectKeys = Object.keys || function (obj) {
	  var res = [];
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
	  }
	  return res;
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	//      Copyright (c) 2012 Mathieu Turcotte
	//      Licensed under the MIT license.

	var Backoff = __webpack_require__(92);
	var ExponentialBackoffStrategy = __webpack_require__(96);
	var FibonacciBackoffStrategy = __webpack_require__(98);
	var FunctionCall = __webpack_require__(99);

	module.exports.Backoff = Backoff;
	module.exports.FunctionCall = FunctionCall;
	module.exports.FibonacciStrategy = FibonacciBackoffStrategy;
	module.exports.ExponentialStrategy = ExponentialBackoffStrategy;

	// Constructs a Fibonacci backoff.
	module.exports.fibonacci = function(options) {
	    return new Backoff(new FibonacciBackoffStrategy(options));
	};

	// Constructs an exponential backoff.
	module.exports.exponential = function(options) {
	    return new Backoff(new ExponentialBackoffStrategy(options));
	};

	// Constructs a FunctionCall for the given function and arguments.
	module.exports.call = function(fn, vargs, callback) {
	    var args = Array.prototype.slice.call(arguments);
	    fn = args[0];
	    vargs = args.slice(1, args.length - 1);
	    callback = args[args.length - 1];
	    return new FunctionCall(fn, vargs, callback);
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	//      Copyright (c) 2012 Mathieu Turcotte
	//      Licensed under the MIT license.

	var events = __webpack_require__(14);
	var precond = __webpack_require__(93);
	var util = __webpack_require__(10);

	// A class to hold the state of a backoff operation. Accepts a backoff strategy
	// to generate the backoff delays.
	function Backoff(backoffStrategy) {
	    events.EventEmitter.call(this);

	    this.backoffStrategy_ = backoffStrategy;
	    this.maxNumberOfRetry_ = -1;
	    this.backoffNumber_ = 0;
	    this.backoffDelay_ = 0;
	    this.timeoutID_ = -1;

	    this.handlers = {
	        backoff: this.onBackoff_.bind(this)
	    };
	}
	util.inherits(Backoff, events.EventEmitter);

	// Sets a limit, greater than 0, on the maximum number of backoffs. A 'fail'
	// event will be emitted when the limit is reached.
	Backoff.prototype.failAfter = function(maxNumberOfRetry) {
	    precond.checkArgument(maxNumberOfRetry > 0,
	        'Expected a maximum number of retry greater than 0 but got %s.',
	        maxNumberOfRetry);

	    this.maxNumberOfRetry_ = maxNumberOfRetry;
	};

	// Starts a backoff operation. Accepts an optional parameter to let the
	// listeners know why the backoff operation was started.
	Backoff.prototype.backoff = function(err) {
	    precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');

	    if (this.backoffNumber_ === this.maxNumberOfRetry_) {
	        this.emit('fail', err);
	        this.reset();
	    } else {
	        this.backoffDelay_ = this.backoffStrategy_.next();
	        this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);
	        this.emit('backoff', this.backoffNumber_, this.backoffDelay_, err);
	    }
	};

	// Handles the backoff timeout completion.
	Backoff.prototype.onBackoff_ = function() {
	    this.timeoutID_ = -1;
	    this.emit('ready', this.backoffNumber_, this.backoffDelay_);
	    this.backoffNumber_++;
	};

	// Stops any backoff operation and resets the backoff delay to its inital value.
	Backoff.prototype.reset = function() {
	    this.backoffNumber_ = 0;
	    this.backoffStrategy_.reset();
	    clearTimeout(this.timeoutID_);
	    this.timeoutID_ = -1;
	};

	module.exports = Backoff;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2012 Mathieu Turcotte
	 * Licensed under the MIT license.
	 */

	module.exports = __webpack_require__(94);

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2012 Mathieu Turcotte
	 * Licensed under the MIT license.
	 */

	var util = __webpack_require__(10);

	var errors = module.exports = __webpack_require__(95);

	function failCheck(ExceptionConstructor, callee, messageFormat, formatArgs) {
	    messageFormat = messageFormat || '';
	    var message = util.format.apply(this, [messageFormat].concat(formatArgs));
	    var error = new ExceptionConstructor(message);
	    Error.captureStackTrace(error, callee);
	    throw error;
	}

	function failArgumentCheck(callee, message, formatArgs) {
	    failCheck(errors.IllegalArgumentError, callee, message, formatArgs);
	}

	function failStateCheck(callee, message, formatArgs) {
	    failCheck(errors.IllegalStateError, callee, message, formatArgs);
	}

	module.exports.checkArgument = function(value, message) {
	    if (!value) {
	        failArgumentCheck(arguments.callee, message,
	            Array.prototype.slice.call(arguments, 2));
	    }
	};

	module.exports.checkState = function(value, message) {
	    if (!value) {
	        failStateCheck(arguments.callee, message,
	            Array.prototype.slice.call(arguments, 2));
	    }
	};

	module.exports.checkIsDef = function(value, message) {
	    if (value !== undefined) {
	        return value;
	    }

	    failArgumentCheck(arguments.callee, message ||
	        'Expected value to be defined but was undefined.',
	        Array.prototype.slice.call(arguments, 2));
	};

	module.exports.checkIsDefAndNotNull = function(value, message) {
	    // Note that undefined == null.
	    if (value != null) {
	        return value;
	    }

	    failArgumentCheck(arguments.callee, message ||
	        'Expected value to be defined and not null but got "' +
	        typeOf(value) + '".', Array.prototype.slice.call(arguments, 2));
	};

	// Fixed version of the typeOf operator which returns 'null' for null values
	// and 'array' for arrays.
	function typeOf(value) {
	    var s = typeof value;
	    if (s == 'object') {
	        if (!value) {
	            return 'null';
	        } else if (value instanceof Array) {
	            return 'array';
	        }
	    }
	    return s;
	}

	function typeCheck(expect) {
	    return function(value, message) {
	        var type = typeOf(value);

	        if (type == expect) {
	            return value;
	        }

	        failArgumentCheck(arguments.callee, message ||
	            'Expected "' + expect + '" but got "' + type + '".',
	            Array.prototype.slice.call(arguments, 2));
	    };
	}

	module.exports.checkIsString = typeCheck('string');
	module.exports.checkIsArray = typeCheck('array');
	module.exports.checkIsNumber = typeCheck('number');
	module.exports.checkIsBoolean = typeCheck('boolean');
	module.exports.checkIsFunction = typeCheck('function');
	module.exports.checkIsObject = typeCheck('object');


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2012 Mathieu Turcotte
	 * Licensed under the MIT license.
	 */

	var util = __webpack_require__(10);

	function IllegalArgumentError(message) {
	    Error.call(this, message);
	    this.message = message;
	}
	util.inherits(IllegalArgumentError, Error);

	IllegalArgumentError.prototype.name = 'IllegalArgumentError';

	function IllegalStateError(message) {
	    Error.call(this, message);
	    this.message = message;
	}
	util.inherits(IllegalStateError, Error);

	IllegalStateError.prototype.name = 'IllegalStateError';

	module.exports.IllegalStateError = IllegalStateError;
	module.exports.IllegalArgumentError = IllegalArgumentError;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	//      Copyright (c) 2012 Mathieu Turcotte
	//      Licensed under the MIT license.

	var util = __webpack_require__(10);
	var precond = __webpack_require__(93);

	var BackoffStrategy = __webpack_require__(97);

	// Exponential backoff strategy.
	function ExponentialBackoffStrategy(options) {
	    BackoffStrategy.call(this, options);
	    this.backoffDelay_ = 0;
	    this.nextBackoffDelay_ = this.getInitialDelay();
	    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;

	    if (options && options.factor !== undefined) {
	        precond.checkArgument(options.factor > 1,
	            'Exponential factor should be greater than 1 but got %s.',
	            options.factor);
	        this.factor_ = options.factor;
	    }
	}
	util.inherits(ExponentialBackoffStrategy, BackoffStrategy);

	// Default multiplication factor used to compute the next backoff delay from
	// the current one. The value can be overridden by passing a custom factor as
	// part of the options.
	ExponentialBackoffStrategy.DEFAULT_FACTOR = 2;

	ExponentialBackoffStrategy.prototype.next_ = function() {
	    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
	    this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;
	    return this.backoffDelay_;
	};

	ExponentialBackoffStrategy.prototype.reset_ = function() {
	    this.backoffDelay_ = 0;
	    this.nextBackoffDelay_ = this.getInitialDelay();
	};

	module.exports = ExponentialBackoffStrategy;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	//      Copyright (c) 2012 Mathieu Turcotte
	//      Licensed under the MIT license.

	var events = __webpack_require__(14);
	var util = __webpack_require__(10);

	function isDef(value) {
	    return value !== undefined && value !== null;
	}

	// Abstract class defining the skeleton for the backoff strategies. Accepts an
	// object holding the options for the backoff strategy:
	//
	//  * `randomisationFactor`: The randomisation factor which must be between 0
	//     and 1 where 1 equates to a randomization factor of 100% and 0 to no
	//     randomization.
	//  * `initialDelay`: The backoff initial delay in milliseconds.
	//  * `maxDelay`: The backoff maximal delay in milliseconds.
	function BackoffStrategy(options) {
	    options = options || {};

	    if (isDef(options.initialDelay) && options.initialDelay < 1) {
	        throw new Error('The initial timeout must be greater than 0.');
	    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {
	        throw new Error('The maximal timeout must be greater than 0.');
	    }

	    this.initialDelay_ = options.initialDelay || 100;
	    this.maxDelay_ = options.maxDelay || 10000;

	    if (this.maxDelay_ <= this.initialDelay_) {
	        throw new Error('The maximal backoff delay must be ' +
	                        'greater than the initial backoff delay.');
	    }

	    if (isDef(options.randomisationFactor) &&
	        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {
	        throw new Error('The randomisation factor must be between 0 and 1.');
	    }

	    this.randomisationFactor_ = options.randomisationFactor || 0;
	}

	// Gets the maximal backoff delay.
	BackoffStrategy.prototype.getMaxDelay = function() {
	    return this.maxDelay_;
	};

	// Gets the initial backoff delay.
	BackoffStrategy.prototype.getInitialDelay = function() {
	    return this.initialDelay_;
	};

	// Template method that computes and returns the next backoff delay in
	// milliseconds.
	BackoffStrategy.prototype.next = function() {
	    var backoffDelay = this.next_();
	    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;
	    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);
	    return randomizedDelay;
	};

	// Computes and returns the next backoff delay. Intended to be overridden by
	// subclasses.
	BackoffStrategy.prototype.next_ = function() {
	    throw new Error('BackoffStrategy.next_() unimplemented.');
	};

	// Template method that resets the backoff delay to its initial value.
	BackoffStrategy.prototype.reset = function() {
	    this.reset_();
	};

	// Resets the backoff delay to its initial value. Intended to be overridden by
	// subclasses.
	BackoffStrategy.prototype.reset_ = function() {
	    throw new Error('BackoffStrategy.reset_() unimplemented.');
	};

	module.exports = BackoffStrategy;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	//      Copyright (c) 2012 Mathieu Turcotte
	//      Licensed under the MIT license.

	var util = __webpack_require__(10);

	var BackoffStrategy = __webpack_require__(97);

	// Fibonacci backoff strategy.
	function FibonacciBackoffStrategy(options) {
	    BackoffStrategy.call(this, options);
	    this.backoffDelay_ = 0;
	    this.nextBackoffDelay_ = this.getInitialDelay();
	}
	util.inherits(FibonacciBackoffStrategy, BackoffStrategy);

	FibonacciBackoffStrategy.prototype.next_ = function() {
	    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
	    this.nextBackoffDelay_ += this.backoffDelay_;
	    this.backoffDelay_ = backoffDelay;
	    return backoffDelay;
	};

	FibonacciBackoffStrategy.prototype.reset_ = function() {
	    this.nextBackoffDelay_ = this.getInitialDelay();
	    this.backoffDelay_ = 0;
	};

	module.exports = FibonacciBackoffStrategy;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	//      Copyright (c) 2012 Mathieu Turcotte
	//      Licensed under the MIT license.

	var events = __webpack_require__(14);
	var precond = __webpack_require__(93);
	var util = __webpack_require__(10);

	var Backoff = __webpack_require__(92);
	var FibonacciBackoffStrategy = __webpack_require__(98);

	// Wraps a function to be called in a backoff loop.
	function FunctionCall(fn, args, callback) {
	    events.EventEmitter.call(this);

	    precond.checkIsFunction(fn, 'Expected fn to be a function.');
	    precond.checkIsArray(args, 'Expected args to be an array.');
	    precond.checkIsFunction(callback, 'Expected callback to be a function.');

	    this.function_ = fn;
	    this.arguments_ = args;
	    this.callback_ = callback;
	    this.lastResult_ = [];
	    this.numRetries_ = 0;

	    this.backoff_ = null;
	    this.strategy_ = null;
	    this.failAfter_ = -1;
	    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;

	    this.state_ = FunctionCall.State_.PENDING;
	}
	util.inherits(FunctionCall, events.EventEmitter);

	// States in which the call can be.
	FunctionCall.State_ = {
	    // Call isn't started yet.
	    PENDING: 0,
	    // Call is in progress.
	    RUNNING: 1,
	    // Call completed successfully which means that either the wrapped function
	    // returned successfully or the maximal number of backoffs was reached.
	    COMPLETED: 2,
	    // The call was aborted.
	    ABORTED: 3
	};

	// The default retry predicate which considers any error as retriable.
	FunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {
	  return true;
	};

	// Checks whether the call is pending.
	FunctionCall.prototype.isPending = function() {
	    return this.state_ == FunctionCall.State_.PENDING;
	};

	// Checks whether the call is in progress.
	FunctionCall.prototype.isRunning = function() {
	    return this.state_ == FunctionCall.State_.RUNNING;
	};

	// Checks whether the call is completed.
	FunctionCall.prototype.isCompleted = function() {
	    return this.state_ == FunctionCall.State_.COMPLETED;
	};

	// Checks whether the call is aborted.
	FunctionCall.prototype.isAborted = function() {
	    return this.state_ == FunctionCall.State_.ABORTED;
	};

	// Sets the backoff strategy to use. Can only be called before the call is
	// started otherwise an exception will be thrown.
	FunctionCall.prototype.setStrategy = function(strategy) {
	    precond.checkState(this.isPending(), 'FunctionCall in progress.');
	    this.strategy_ = strategy;
	    return this; // Return this for chaining.
	};

	// Sets the predicate which will be used to determine whether the errors
	// returned from the wrapped function should be retried or not, e.g. a
	// network error would be retriable while a type error would stop the
	// function call.
	FunctionCall.prototype.retryIf = function(retryPredicate) {
	    precond.checkState(this.isPending(), 'FunctionCall in progress.');
	    this.retryPredicate_ = retryPredicate;
	    return this;
	};

	// Returns all intermediary results returned by the wrapped function since
	// the initial call.
	FunctionCall.prototype.getLastResult = function() {
	    return this.lastResult_.concat();
	};

	// Returns the number of times the wrapped function call was retried.
	FunctionCall.prototype.getNumRetries = function() {
	    return this.numRetries_;
	};

	// Sets the backoff limit.
	FunctionCall.prototype.failAfter = function(maxNumberOfRetry) {
	    precond.checkState(this.isPending(), 'FunctionCall in progress.');
	    this.failAfter_ = maxNumberOfRetry;
	    return this; // Return this for chaining.
	};

	// Aborts the call.
	FunctionCall.prototype.abort = function() {
	    if (this.isCompleted() || this.isAborted()) {
	      return;
	    }

	    if (this.isRunning()) {
	        this.backoff_.reset();
	    }

	    this.state_ = FunctionCall.State_.ABORTED;
	    this.lastResult_ = [new Error('Backoff aborted.')];
	    this.emit('abort');
	    this.doCallback_();
	};

	// Initiates the call to the wrapped function. Accepts an optional factory
	// function used to create the backoff instance; used when testing.
	FunctionCall.prototype.start = function(backoffFactory) {
	    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');
	    precond.checkState(this.isPending(), 'FunctionCall already started.');

	    var strategy = this.strategy_ || new FibonacciBackoffStrategy();

	    this.backoff_ = backoffFactory ?
	        backoffFactory(strategy) :
	        new Backoff(strategy);

	    this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));
	    this.backoff_.on('fail', this.doCallback_.bind(this));
	    this.backoff_.on('backoff', this.handleBackoff_.bind(this));

	    if (this.failAfter_ > 0) {
	        this.backoff_.failAfter(this.failAfter_);
	    }

	    this.state_ = FunctionCall.State_.RUNNING;
	    this.doCall_(false /* isRetry */);
	};

	// Calls the wrapped function.
	FunctionCall.prototype.doCall_ = function(isRetry) {
	    if (isRetry) {
	        this.numRetries_++;
	    }
	    var eventArgs = ['call'].concat(this.arguments_);
	    events.EventEmitter.prototype.emit.apply(this, eventArgs);
	    var callback = this.handleFunctionCallback_.bind(this);
	    this.function_.apply(null, this.arguments_.concat(callback));
	};

	// Calls the wrapped function's callback with the last result returned by the
	// wrapped function.
	FunctionCall.prototype.doCallback_ = function() {
	    this.callback_.apply(null, this.lastResult_);
	};

	// Handles wrapped function's completion. This method acts as a replacement
	// for the original callback function.
	FunctionCall.prototype.handleFunctionCallback_ = function() {
	    if (this.isAborted()) {
	        return;
	    }

	    var args = Array.prototype.slice.call(arguments);
	    this.lastResult_ = args; // Save last callback arguments.
	    events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));

	    var err = args[0];
	    if (err && this.retryPredicate_(err)) {
	        this.backoff_.backoff(err);
	    } else {
	        this.state_ = FunctionCall.State_.COMPLETED;
	        this.doCallback_();
	    }
	};

	// Handles the backoff event by reemitting it.
	FunctionCall.prototype.handleBackoff_ = function(number, delay, err) {
	    this.emit('backoff', number, delay, err);
	};

	module.exports = FunctionCall;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(39);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	function Mime() {
	  // Map of extension -> mime type
	  this.types = Object.create(null);

	  // Map of mime type -> extension
	  this.extensions = Object.create(null);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * @param map (Object) type definitions
	 */
	Mime.prototype.define = function (map) {
	  for (var type in map) {
	    var exts = map[type];
	    for (var i = 0; i < exts.length; i++) {
	      if (process.env.DEBUG_MIME && this.types[exts]) {
	        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
	          this.types[exts] + ' to ' + type);
	      }

	      this.types[exts[i]] = type;
	    }

	    // Default extension is the first one we encounter
	    if (!this.extensions[type]) {
	      this.extensions[type] = exts[0];
	    }
	  }
	};

	/**
	 * Load an Apache2-style ".types" file
	 *
	 * This may be called multiple times (it's expected).  Where files declare
	 * overlapping types/extensions, the last file wins.
	 *
	 * @param file (String) path of file to load.
	 */
	Mime.prototype.load = function(file) {
	  this._loading = file;
	  // Read file and split into lines
	  var map = {},
	      content = fs.readFileSync(file, 'ascii'),
	      lines = content.split(/[\r\n]+/);

	  lines.forEach(function(line) {
	    // Clean up whitespace/comments, and split into fields
	    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
	    map[fields.shift()] = fields;
	  });

	  this.define(map);

	  this._loading = null;
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.lookup = function(path, fallback) {
	  var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();

	  return this.types[ext] || fallback || this.default_type;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.extension = function(mimeType) {
	  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
	  return this.extensions[type];
	};

	// Default instance
	var mime = new Mime();

	// Define built-in types
	mime.define(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./types.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	// Default type
	mime.default_type = mime.lookup('bin');

	//
	// Additional API specific to the default instance
	//

	mime.Mime = Mime;

	/**
	 * Lookup a charset based on mime type.
	 */
	mime.charsets = {
	  lookup: function(mimeType, fallback) {
	    // Assume text types are utf8
	    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
	  }
	};

	module.exports = mime;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 101 */,
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {'use strict'

	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , tls = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tls\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , http = __webpack_require__(76)
	  , https = __webpack_require__(87)
	  , events = __webpack_require__(14)
	  , assert = __webpack_require__(9)
	  , util = __webpack_require__(10)
	  ;

	exports.httpOverHttp = httpOverHttp
	exports.httpsOverHttp = httpsOverHttp
	exports.httpOverHttps = httpOverHttps
	exports.httpsOverHttps = httpsOverHttps


	function httpOverHttp(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = http.request
	  return agent
	}

	function httpsOverHttp(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = http.request
	  agent.createSocket = createSecureSocket
	  agent.defaultPort = 443
	  return agent
	}

	function httpOverHttps(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = https.request
	  return agent
	}

	function httpsOverHttps(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = https.request
	  agent.createSocket = createSecureSocket
	  agent.defaultPort = 443
	  return agent
	}


	function TunnelingAgent(options) {
	  var self = this
	  self.options = options || {}
	  self.proxyOptions = self.options.proxy || {}
	  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
	  self.requests = []
	  self.sockets = []

	  self.on('free', function onFree(socket, host, port) {
	    for (var i = 0, len = self.requests.length; i < len; ++i) {
	      var pending = self.requests[i]
	      if (pending.host === host && pending.port === port) {
	        // Detect the request to connect same origin server,
	        // reuse the connection.
	        self.requests.splice(i, 1)
	        pending.request.onSocket(socket)
	        return
	      }
	    }
	    socket.destroy()
	    self.removeSocket(socket)
	  })
	}
	util.inherits(TunnelingAgent, events.EventEmitter)

	TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
	  var self = this

	   // Legacy API: addRequest(req, host, port, path)
	  if (typeof options === 'string') {
	    options = {
	      host: options,
	      port: arguments[2],
	      path: arguments[3]
	    };
	  }

	  if (self.sockets.length >= this.maxSockets) {
	    // We are over limit so we'll add it to the queue.
	    self.requests.push({host: options.host, port: options.port, request: req})
	    return
	  }

	  // If we are under maxSockets create a new one.
	  self.createConnection({host: options.host, port: options.port, request: req})
	}

	TunnelingAgent.prototype.createConnection = function createConnection(pending) {
	  var self = this

	  self.createSocket(pending, function(socket) {
	    socket.on('free', onFree)
	    socket.on('close', onCloseOrRemove)
	    socket.on('agentRemove', onCloseOrRemove)
	    pending.request.onSocket(socket)

	    function onFree() {
	      self.emit('free', socket, pending.host, pending.port)
	    }

	    function onCloseOrRemove(err) {
	      self.removeSocket(socket)
	      socket.removeListener('free', onFree)
	      socket.removeListener('close', onCloseOrRemove)
	      socket.removeListener('agentRemove', onCloseOrRemove)
	    }
	  })
	}

	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
	  var self = this
	  var placeholder = {}
	  self.sockets.push(placeholder)

	  var connectOptions = mergeOptions({}, self.proxyOptions, 
	    { method: 'CONNECT'
	    , path: options.host + ':' + options.port
	    , agent: false
	    }
	  )
	  if (connectOptions.proxyAuth) {
	    connectOptions.headers = connectOptions.headers || {}
	    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
	        new Buffer(connectOptions.proxyAuth).toString('base64')
	  }

	  debug('making CONNECT request')
	  var connectReq = self.request(connectOptions)
	  connectReq.useChunkedEncodingByDefault = false // for v0.6
	  connectReq.once('response', onResponse) // for v0.6
	  connectReq.once('upgrade', onUpgrade)   // for v0.6
	  connectReq.once('connect', onConnect)   // for v0.7 or later
	  connectReq.once('error', onError)
	  connectReq.end()

	  function onResponse(res) {
	    // Very hacky. This is necessary to avoid http-parser leaks.
	    res.upgrade = true
	  }

	  function onUpgrade(res, socket, head) {
	    // Hacky.
	    process.nextTick(function() {
	      onConnect(res, socket, head)
	    })
	  }

	  function onConnect(res, socket, head) {
	    connectReq.removeAllListeners()
	    socket.removeAllListeners()

	    if (res.statusCode === 200) {
	      assert.equal(head.length, 0)
	      debug('tunneling connection has established')
	      self.sockets[self.sockets.indexOf(placeholder)] = socket
	      cb(socket)
	    } else {
	      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
	      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
	      error.code = 'ECONNRESET'
	      options.request.emit('error', error)
	      self.removeSocket(placeholder)
	    }
	  }

	  function onError(cause) {
	    connectReq.removeAllListeners()

	    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
	    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
	    error.code = 'ECONNRESET'
	    options.request.emit('error', error)
	    self.removeSocket(placeholder)
	  }
	}

	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
	  var pos = this.sockets.indexOf(socket)
	  if (pos === -1) return
	  
	  this.sockets.splice(pos, 1)

	  var pending = this.requests.shift()
	  if (pending) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createConnection(pending)
	  }
	}

	function createSecureSocket(options, cb) {
	  var self = this
	  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
	    // 0 is dummy port for v0.6
	    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
	      { servername: options.host
	      , socket: socket
	      }
	    ))
	    self.sockets[self.sockets.indexOf(socket)] = secureSocket
	    cb(secureSocket)
	  })
	}


	function mergeOptions(target) {
	  for (var i = 1, len = arguments.length; i < len; ++i) {
	    var overrides = arguments[i]
	    if (typeof overrides === 'object') {
	      var keys = Object.keys(overrides)
	      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
	        var k = keys[j]
	        if (overrides[k] !== undefined) {
	          target[k] = overrides[k]
	        }
	      }
	    }
	  }
	  return target
	}


	var debug
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
	  debug = function() {
	    var args = Array.prototype.slice.call(arguments)
	    if (typeof args[0] === 'string') {
	      args[0] = 'TUNNEL: ' + args[0]
	    } else {
	      args.unshift('TUNNEL:')
	    }
	    console.error.apply(console, args)
	  }
	} else {
	  debug = function() {}
	}
	exports.debug = debug // for test

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(2)))

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.


	///--- Globals

	'use strict';

	var ID = 0;
	var MAX_INT = Math.pow(2, 32) - 1;

	var PROBES = {
	    // server_name, route_name, id, method, url, headers (json)
	    'route-start': ['char *', 'char *', 'int', 'char *', 'char *', 'json'],

	    // server_name, route_name, handler_name, id
	    'handler-start': ['char *', 'char *', 'char *', 'int'],

	    // server_name, route_name, handler_name, id
	    'handler-done': ['char *', 'char *', 'char *', 'int'],

	    // server_name, route_name, id, statusCode, headers (json)
	    'route-done': ['char *', 'char *', 'int', 'int', 'json'],


	    // Client probes
	    // method, url, headers, id
	    'client-request': ['char *', 'char *', 'json', 'int'],

	    // id, statusCode, headers
	    'client-response': ['int', 'int', 'json'],

	    // id, Error.toString()
	    'client-error': ['id', 'char *']
	};
	var PROVIDER;


	///--- API

	module.exports = (function exportStaticProvider() {
	    if (!PROVIDER) {
	        try {
	            var dtrace = __webpack_require__(104);
	            PROVIDER = dtrace.createDTraceProvider('restify');
	        } catch (e) {
	            PROVIDER = {
	                fire: function () {
	                },
	                enable: function () {
	                },
	                addProbe: function () {
	                    var p = {
	                        fire: function () {
	                        }
	                    };
	                    return (p);
	                },
	                removeProbe: function () {
	                },
	                disable: function () {
	                }
	            };
	        }

	        PROVIDER._rstfy_probes = {};

	        Object.keys(PROBES).forEach(function (p) {
	            var args = PROBES[p].splice(0);
	            args.unshift(p);

	            var probe = PROVIDER.addProbe.apply(PROVIDER, args);
	            PROVIDER._rstfy_probes[p] = probe;
	        });

	        PROVIDER.enable();

	        PROVIDER.nextId = function nextId() {
	            if (++ID >= MAX_INT) {
	                ID = 1;
	            }

	            return (ID);
	        };
	    }

	    return (PROVIDER);
	}());


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var DTraceProvider;

	function DTraceProviderStub() {}
	DTraceProviderStub.prototype.addProbe = function(name) {
	    var p = { 'fire': function () {} };
	    this[name] = p;
	    return (p);
	};
	DTraceProviderStub.prototype.enable = function() {};
	DTraceProviderStub.prototype.fire = function() {};
	DTraceProviderStub.prototype.disable = function() {};

	var builds = ['Release', 'default', 'Debug'];

	for (var i in builds) {
	    try {
	        var binding = !(function webpackMissingModule() { var e = new Error("Cannot find module \"./build\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
	        DTraceProvider = binding.DTraceProvider;
	        break;
	    } catch (e) {
	        // if the platform looks like it _should_ have DTrace
	        // available, log a failure to load the bindings.
	        if (process.platform == 'darwin' ||
	            process.platform == 'solaris' ||
	            process.platform == 'freebsd') {
	            console.error(e);
	        }
	    }
	}

	if (!DTraceProvider) {
	    DTraceProvider = DTraceProviderStub;
	}

	exports.DTraceProvider = DTraceProvider;
	exports.createDTraceProvider = function(name, module) {
	    if (arguments.length == 2)
	        return (new exports.DTraceProvider(name, module));
	    return (new exports.DTraceProvider(name));
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var httpErrors = __webpack_require__(106);
	var restErrors = __webpack_require__(111);


	module.exports = {};

	Object.keys(httpErrors).forEach(function (k) {
	    module.exports[k] = httpErrors[k];
	});

	// Note some of the RestErrors overwrite plain HTTP errors.
	Object.keys(restErrors).forEach(function (k) {
	    module.exports[k] = restErrors[k];
	});


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	// Because we are constructing error objects dynamically, we use an anonymous
	// function as the 'base constructor' then use arguments.callee to fill that in.
	// strict mode disallows agruments.callee, disable both of these rules.

	/* eslint-disable strict, no-caller */

	var http = __webpack_require__(76);
	var util = __webpack_require__(10);

	var assert = __webpack_require__(4);
	var WError = __webpack_require__(107).WError;


	///--- Globals

	var slice = Function.prototype.call.bind(Array.prototype.slice);


	///--- Helpers

	/**
	 * used to programatically create http error code names, using the underlying
	 * status codes names exposed via the http module.
	 * @private
	 * @function codeToErrorName
	 * @param    {Number} code the http error code to dynamically create
	 * @returns  {String}
	 */
	function codeToErrorName(code) {
	    code = parseInt(code, 10);
	    var status = http.STATUS_CODES[code];

	    if (!status) {
	        return (false);
	    }


	    var pieces = status.split(/\s+/);
	    var str = '';
	    pieces.forEach(function (s) {
	        str += s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
	    });

	    str = str.replace(/\W+/g, '');

	    if (!/\w+Error$/.test(str)) {
	        str += 'Error';
	    }

	    return (str);
	}


	///--- Error Base class

	/**
	 * HttpError class. inherits from WError.
	 * @public
	 * @class
	 * @param {Object} options an options object
	 */
	function HttpError(options) {
	    assert.object(options, 'options');

	    options.constructorOpt = options.constructorOpt || HttpError;
	    WError.apply(this, arguments);

	    var self = this;
	    var code = parseInt((options.statusCode || 500), 10);
	    this.statusCode = code;
	    this.body = options.body || {
	        code: codeToErrorName(code),
	        message: options.message || self.message
	    };
	    this.message = options.message || self.message;
	}
	util.inherits(HttpError, WError);


	///--- Exports

	module.exports = {

	    HttpError: HttpError,

	    codeToHttpError: function codeToHttpError(code, message, body) {
	        var err;
	        var name = codeToErrorName(code);

	        if (!name) {
	            err = new HttpError({
	                statusCode: code,
	                message: message,
	                body: body
	            });
	            err.name = 'Http' + code + 'Error';
	        } else {
	            err = new module.exports[name]({
	                body: body,
	                message: message,
	                constructorOpt: codeToHttpError,
	                statusCode: code
	            });
	        }

	        return (err);
	    }

	};


	// Export all the 4xx and 5xx HTTP Status codes as Errors
	var codes = Object.keys(http.STATUS_CODES);

	codes.forEach(function (code) {
	    if (code < 400) {
	        return;
	    }

	    var name = codeToErrorName(code);

	    module.exports[name] = function (cause, message) {
	        var index = 1;
	        var opts = {
	            statusCode: code
	        };

	        if (cause && cause instanceof Error) {
	            opts.cause = cause;
	            opts.constructorOpt = arguments.callee;
	        } else if (typeof (cause) === 'object') {
	            opts.body = cause.body;
	            opts.cause = cause.cause;
	            opts.constructorOpt = cause.constructorOpt;
	            opts.message = cause.message;
	            opts.statusCode = cause.statusCode || code;
	        } else {
	            opts.constructorOpt = arguments.callee;
	            index = 0;
	        }

	        var args = slice(arguments, index);
	        args.unshift(opts);
	        HttpError.apply(this, args);
	    };
	    util.inherits(module.exports[name], HttpError);

	    module.exports[name].displayName =
	        module.exports[name].prototype.name =
	            name;
	});


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * verror.js: richer JavaScript errors
	 */

	var mod_assertplus = __webpack_require__(108);
	var mod_util = __webpack_require__(10);

	var mod_extsprintf = __webpack_require__(109);
	var mod_isError = __webpack_require__(110).isError;
	var sprintf = mod_extsprintf.sprintf;

	/*
	 * Public interface
	 */

	/* So you can 'var VError = require('verror')' */
	module.exports = VError;
	/* For compatibility */
	VError.VError = VError;
	/* Other exported classes */
	VError.SError = SError;
	VError.WError = WError;
	VError.MultiError = MultiError;

	/*
	 * Common function used to parse constructor arguments for VError, WError, and
	 * SError.  Named arguments to this function:
	 *
	 *     strict		force strict interpretation of sprintf arguments, even
	 *     			if the options in "argv" don't say so
	 *
	 *     argv		error's constructor arguments, which are to be
	 *     			interpreted as described in README.md.  For quick
	 *     			reference, "argv" has one of the following forms:
	 *
	 *          [ sprintf_args... ]           (argv[0] is a string)
	 *          [ cause, sprintf_args... ]    (argv[0] is an Error)
	 *          [ options, sprintf_args... ]  (argv[0] is an object)
	 *
	 * This function normalizes these forms, producing an object with the following
	 * properties:
	 *
	 *    options           equivalent to "options" in third form.  This will never
	 *    			be a direct reference to what the caller passed in
	 *    			(i.e., it may be a shallow copy), so it can be freely
	 *    			modified.
	 *
	 *    shortmessage      result of sprintf(sprintf_args), taking options.strict
	 *    			into account as described in README.md.
	 */
	function parseConstructorArguments(args)
	{
		var argv, options, sprintf_args, shortmessage, k;

		mod_assertplus.object(args, 'args');
		mod_assertplus.bool(args.strict, 'args.strict');
		mod_assertplus.array(args.argv, 'args.argv');
		argv = args.argv;

		/*
		 * First, figure out which form of invocation we've been given.
		 */
		if (argv.length === 0) {
			options = {};
			sprintf_args = [];
		} else if (mod_isError(argv[0])) {
			options = { 'cause': argv[0] };
			sprintf_args = argv.slice(1);
		} else if (typeof (argv[0]) === 'object') {
			options = {};
			for (k in argv[0]) {
				options[k] = argv[0][k];
			}
			sprintf_args = argv.slice(1);
		} else {
			mod_assertplus.string(argv[0],
			    'first argument to VError, SError, or WError ' +
			    'constructor must be a string, object, or Error');
			options = {};
			sprintf_args = argv;
		}

		/*
		 * Now construct the error's message.
		 *
		 * extsprintf (which we invoke here with our caller's arguments in order
		 * to construct this Error's message) is strict in its interpretation of
		 * values to be processed by the "%s" specifier.  The value passed to
		 * extsprintf must actually be a string or something convertible to a
		 * String using .toString().  Passing other values (notably "null" and
		 * "undefined") is considered a programmer error.  The assumption is
		 * that if you actually want to print the string "null" or "undefined",
		 * then that's easy to do that when you're calling extsprintf; on the
		 * other hand, if you did NOT want that (i.e., there's actually a bug
		 * where the program assumes some variable is non-null and tries to
		 * print it, which might happen when constructing a packet or file in
		 * some specific format), then it's better to stop immediately than
		 * produce bogus output.
		 *
		 * However, sometimes the bug is only in the code calling VError, and a
		 * programmer might prefer to have the error message contain "null" or
		 * "undefined" rather than have the bug in the error path crash the
		 * program (making the first bug harder to identify).  For that reason,
		 * by default VError converts "null" or "undefined" arguments to their
		 * string representations and passes those to extsprintf.  Programmers
		 * desiring the strict behavior can use the SError class or pass the
		 * "strict" option to the VError constructor.
		 */
		mod_assertplus.object(options);
		if (!options.strict && !args.strict) {
			sprintf_args = sprintf_args.map(function (a) {
				return (a === null ? 'null' :
				    a === undefined ? 'undefined' : a);
			});
		}

		if (sprintf_args.length === 0) {
			shortmessage = '';
		} else {
			shortmessage = sprintf.apply(null, sprintf_args);
		}

		return ({
		    'options': options,
		    'shortmessage': shortmessage
		});
	}

	/*
	 * See README.md for reference documentation.
	 */
	function VError()
	{
		var args, obj, parsed, cause, ctor, message, k;

		args = Array.prototype.slice.call(arguments, 0);

		/*
		 * This is a regrettable pattern, but JavaScript's built-in Error class
		 * is defined to work this way, so we allow the constructor to be called
		 * without "new".
		 */
		if (!(this instanceof VError)) {
			obj = Object.create(VError.prototype);
			VError.apply(obj, arguments);
			return (obj);
		}

		/*
		 * For convenience and backwards compatibility, we support several
		 * different calling forms.  Normalize them here.
		 */
		parsed = parseConstructorArguments({
		    'argv': args,
		    'strict': false
		});

		/*
		 * If we've been given a name, apply it now.
		 */
		if (parsed.options.name) {
			mod_assertplus.string(parsed.options.name,
			    'error\'s "name" must be a string');
			this.name = parsed.options.name;
		}

		/*
		 * For debugging, we keep track of the original short message (attached
		 * this Error particularly) separately from the complete message (which
		 * includes the messages of our cause chain).
		 */
		this.jse_shortmsg = parsed.shortmessage;
		message = parsed.shortmessage;

		/*
		 * If we've been given a cause, record a reference to it and update our
		 * message appropriately.
		 */
		cause = parsed.options.cause;
		if (cause) {
			mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
			this.jse_cause = cause;

			if (!parsed.options.skipCauseMessage) {
				message += ': ' + cause.message;
			}
		}

		/*
		 * If we've been given an object with properties, shallow-copy that
		 * here.  We don't want to use a deep copy in case there are non-plain
		 * objects here, but we don't want to use the original object in case
		 * the caller modifies it later.
		 */
		this.jse_info = {};
		if (parsed.options.info) {
			for (k in parsed.options.info) {
				this.jse_info[k] = parsed.options.info[k];
			}
		}

		this.message = message;
		Error.call(this, message);

		if (Error.captureStackTrace) {
			ctor = parsed.options.constructorOpt || this.constructor;
			Error.captureStackTrace(this, ctor);
		}

		return (this);
	}

	mod_util.inherits(VError, Error);
	VError.prototype.name = 'VError';

	VError.prototype.toString = function ve_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;

		return (str);
	};

	/*
	 * This method is provided for compatibility.  New callers should use
	 * VError.cause() instead.  That method also uses the saner `null` return value
	 * when there is no cause.
	 */
	VError.prototype.cause = function ve_cause()
	{
		var cause = VError.cause(this);
		return (cause === null ? undefined : cause);
	};

	/*
	 * Static methods
	 *
	 * These class-level methods are provided so that callers can use them on
	 * instances of Errors that are not VErrors.  New interfaces should be provided
	 * only using static methods to eliminate the class of programming mistake where
	 * people fail to check whether the Error object has the corresponding methods.
	 */

	VError.cause = function (err)
	{
		mod_assertplus.ok(mod_isError(err), 'err must be an Error');
		return (mod_isError(err.jse_cause) ? err.jse_cause : null);
	};

	VError.info = function (err)
	{
		var rv, cause, k;

		mod_assertplus.ok(mod_isError(err), 'err must be an Error');
		cause = VError.cause(err);
		if (cause !== null) {
			rv = VError.info(cause);
		} else {
			rv = {};
		}

		if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
			for (k in err.jse_info) {
				rv[k] = err.jse_info[k];
			}
		}

		return (rv);
	};

	VError.findCauseByName = function (err, name)
	{
		var cause;

		mod_assertplus.ok(mod_isError(err), 'err must be an Error');
		mod_assertplus.string(name);
		mod_assertplus.ok(name.length > 0, 'name cannot be empty');

		for (cause = err; cause !== null; cause = VError.cause(cause)) {
			mod_assertplus.ok(mod_isError(cause));
			if (cause.name == name) {
				return (cause);
			}
		}

		return (null);
	};

	VError.fullStack = function (err)
	{
		mod_assertplus.ok(mod_isError(err), 'err must be an Error');

		var cause = VError.cause(err);

		if (cause) {
			return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
		}

		return (err.stack);
	};


	/*
	 * SError is like VError, but stricter about types.  You cannot pass "null" or
	 * "undefined" as string arguments to the formatter.
	 */
	function SError()
	{
		var args, obj, parsed, options;

		args = Array.prototype.slice.call(arguments, 0);
		if (!(this instanceof SError)) {
			obj = Object.create(SError.prototype);
			SError.apply(obj, arguments);
			return (obj);
		}

		parsed = parseConstructorArguments({
		    'argv': args,
		    'strict': true
		});

		options = parsed.options;
		VError.call(this, options, '%s', parsed.shortmessage);

		return (this);
	}

	/*
	 * We don't bother setting SError.prototype.name because once constructed,
	 * SErrors are just like VErrors.
	 */
	mod_util.inherits(SError, VError);


	/*
	 * Represents a collection of errors for the purpose of consumers that generally
	 * only deal with one error.  Callers can extract the individual errors
	 * contained in this object, but may also just treat it as a normal single
	 * error, in which case a summary message will be printed.
	 */
	function MultiError(errors)
	{
		mod_assertplus.array(errors, 'list of errors');
		mod_assertplus.ok(errors.length > 0, 'must be at least one error');
		this.ase_errors = errors;

		VError.call(this, {
		    'cause': errors[0]
		}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
	}

	mod_util.inherits(MultiError, VError);
	MultiError.prototype.name = 'MultiError';

	MultiError.prototype.errors = function me_errors()
	{
		return (this.ase_errors.slice(0));
	};


	/*
	 * See README.md for reference details.
	 */
	function WError()
	{
		var args, obj, parsed, options;

		args = Array.prototype.slice.call(arguments, 0);
		if (!(this instanceof WError)) {
			obj = Object.create(WError.prototype);
			WError.apply(obj, args);
			return (obj);
		}

		parsed = parseConstructorArguments({
		    'argv': args,
		    'strict': false
		});

		options = parsed.options;
		options['skipCauseMessage'] = true;
		VError.call(this, options, '%s', parsed.shortmessage);

		return (this);
	}

	mod_util.inherits(WError, VError);
	WError.prototype.name = 'WError';

	WError.prototype.toString = function we_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;
		if (this.jse_cause && this.jse_cause.message)
			str += '; caused by ' + this.jse_cause.toString();

		return (str);
	};

	/*
	 * For purely historical reasons, WError's cause() function allows you to set
	 * the cause.
	 */
	WError.prototype.cause = function we_cause(c)
	{
		if (mod_isError(c))
			this.jse_cause = c;

		return (this.jse_cause);
	};


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Copyright (c) 2012, Mark Cavage. All rights reserved.
	// Copyright 2015 Joyent, Inc.

	var assert = __webpack_require__(9);
	var Stream = __webpack_require__(13).Stream;
	var util = __webpack_require__(10);


	///--- Globals

	/* JSSTYLED */
	var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;


	///--- Internal

	function _capitalize(str) {
	    return (str.charAt(0).toUpperCase() + str.slice(1));
	}

	function _toss(name, expected, oper, arg, actual) {
	    throw new assert.AssertionError({
	        message: util.format('%s (%s) is required', name, expected),
	        actual: (actual === undefined) ? typeof (arg) : actual(arg),
	        expected: expected,
	        operator: oper || '===',
	        stackStartFunction: _toss.caller
	    });
	}

	function _getClass(arg) {
	    return (Object.prototype.toString.call(arg).slice(8, -1));
	}

	function noop() {
	    // Why even bother with asserts?
	}


	///--- Exports

	var types = {
	    bool: {
	        check: function (arg) { return typeof (arg) === 'boolean'; }
	    },
	    func: {
	        check: function (arg) { return typeof (arg) === 'function'; }
	    },
	    string: {
	        check: function (arg) { return typeof (arg) === 'string'; }
	    },
	    object: {
	        check: function (arg) {
	            return typeof (arg) === 'object' && arg !== null;
	        }
	    },
	    number: {
	        check: function (arg) {
	            return typeof (arg) === 'number' && !isNaN(arg);
	        }
	    },
	    finite: {
	        check: function (arg) {
	            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
	        }
	    },
	    buffer: {
	        check: function (arg) { return Buffer.isBuffer(arg); },
	        operator: 'Buffer.isBuffer'
	    },
	    array: {
	        check: function (arg) { return Array.isArray(arg); },
	        operator: 'Array.isArray'
	    },
	    stream: {
	        check: function (arg) { return arg instanceof Stream; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    date: {
	        check: function (arg) { return arg instanceof Date; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    regexp: {
	        check: function (arg) { return arg instanceof RegExp; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    uuid: {
	        check: function (arg) {
	            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
	        },
	        operator: 'isUUID'
	    }
	};

	function _setExports(ndebug) {
	    var keys = Object.keys(types);
	    var out;

	    /* re-export standard assert */
	    if (process.env.NODE_NDEBUG) {
	        out = noop;
	    } else {
	        out = function (arg, msg) {
	            if (!arg) {
	                _toss(msg, 'true', arg);
	            }
	        };
	    }

	    /* standard checks */
	    keys.forEach(function (k) {
	        if (ndebug) {
	            out[k] = noop;
	            return;
	        }
	        var type = types[k];
	        out[k] = function (arg, msg) {
	            if (!type.check(arg)) {
	                _toss(msg, k, type.operator, arg, type.actual);
	            }
	        };
	    });

	    /* optional checks */
	    keys.forEach(function (k) {
	        var name = 'optional' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        out[name] = function (arg, msg) {
	            if (arg === undefined || arg === null) {
	                return;
	            }
	            if (!type.check(arg)) {
	                _toss(msg, k, type.operator, arg, type.actual);
	            }
	        };
	    });

	    /* arrayOf checks */
	    keys.forEach(function (k) {
	        var name = 'arrayOf' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        var expected = '[' + k + ']';
	        out[name] = function (arg, msg) {
	            if (!Array.isArray(arg)) {
	                _toss(msg, expected, type.operator, arg, type.actual);
	            }
	            var i;
	            for (i = 0; i < arg.length; i++) {
	                if (!type.check(arg[i])) {
	                    _toss(msg, expected, type.operator, arg, type.actual);
	                }
	            }
	        };
	    });

	    /* optionalArrayOf checks */
	    keys.forEach(function (k) {
	        var name = 'optionalArrayOf' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        var expected = '[' + k + ']';
	        out[name] = function (arg, msg) {
	            if (arg === undefined || arg === null) {
	                return;
	            }
	            if (!Array.isArray(arg)) {
	                _toss(msg, expected, type.operator, arg, type.actual);
	            }
	            var i;
	            for (i = 0; i < arg.length; i++) {
	                if (!type.check(arg[i])) {
	                    _toss(msg, expected, type.operator, arg, type.actual);
	                }
	            }
	        };
	    });

	    /* re-export built-in assertions */
	    Object.keys(assert).forEach(function (k) {
	        if (k === 'AssertionError') {
	            out[k] = assert[k];
	            return;
	        }
	        if (ndebug) {
	            out[k] = noop;
	            return;
	        }
	        out[k] = assert[k];
	    });

	    /* export ourselves (for unit tests _only_) */
	    out._setExports = _setExports;

	    return out;
	}

	module.exports = _setExports(process.env.NODE_NDEBUG);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(2)))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
	 * extsprintf.js: extended POSIX-style sprintf
	 */

	var mod_assert = __webpack_require__(9);
	var mod_util = __webpack_require__(10);

	/*
	 * Public interface
	 */
	exports.sprintf = jsSprintf;
	exports.printf = jsPrintf;

	/*
	 * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
	 * exception when given a format string we don't understand, rather than
	 * ignoring it, so that we won't break existing programs if/when we go implement
	 * the rest of this.
	 *
	 * This implementation currently supports specifying
	 *	- field alignment ('-' flag),
	 * 	- zero-pad ('0' flag)
	 *	- always show numeric sign ('+' flag),
	 *	- field width
	 *	- conversions for strings, decimal integers, and floats (numbers).
	 *	- argument size specifiers.  These are all accepted but ignored, since
	 *	  Javascript has no notion of the physical size of an argument.
	 *
	 * Everything else is currently unsupported, most notably precision, unsigned
	 * numbers, non-decimal numbers, and characters.
	 */
	function jsSprintf(fmt)
	{
		var regex = [
		    '([^%]*)',				/* normal text */
		    '%',				/* start of format */
		    '([\'\\-+ #0]*?)',			/* flags (optional) */
		    '([1-9]\\d*)?',			/* width (optional) */
		    '(\\.([1-9]\\d*))?',		/* precision (optional) */
		    '[lhjztL]*?',			/* length mods (ignored) */
		    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
		].join('');

		var re = new RegExp(regex);
		var args = Array.prototype.slice.call(arguments, 1);
		var flags, width, precision, conversion;
		var left, pad, sign, arg, match;
		var ret = '';
		var argn = 1;

		mod_assert.equal('string', typeof (fmt));

		while ((match = re.exec(fmt)) !== null) {
			ret += match[1];
			fmt = fmt.substring(match[0].length);

			flags = match[2] || '';
			width = match[3] || 0;
			precision = match[4] || '';
			conversion = match[6];
			left = false;
			sign = false;
			pad = ' ';

			if (conversion == '%') {
				ret += '%';
				continue;
			}

			if (args.length === 0)
				throw (new Error('too few args to sprintf'));

			arg = args.shift();
			argn++;

			if (flags.match(/[\' #]/))
				throw (new Error(
				    'unsupported flags: ' + flags));

			if (precision.length > 0)
				throw (new Error(
				    'non-zero precision not supported'));

			if (flags.match(/-/))
				left = true;

			if (flags.match(/0/))
				pad = '0';

			if (flags.match(/\+/))
				sign = true;

			switch (conversion) {
			case 's':
				if (arg === undefined || arg === null)
					throw (new Error('argument ' + argn +
					    ': attempted to print undefined or null ' +
					    'as a string'));
				ret += doPad(pad, width, left, arg.toString());
				break;

			case 'd':
				arg = Math.floor(arg);
				/*jsl:fallthru*/
			case 'f':
				sign = sign && arg > 0 ? '+' : '';
				ret += sign + doPad(pad, width, left,
				    arg.toString());
				break;

			case 'x':
				ret += doPad(pad, width, left, arg.toString(16));
				break;

			case 'j': /* non-standard */
				if (width === 0)
					width = 10;
				ret += mod_util.inspect(arg, false, width);
				break;

			case 'r': /* non-standard */
				ret += dumpException(arg);
				break;

			default:
				throw (new Error('unsupported conversion: ' +
				    conversion));
			}
		}

		ret += fmt;
		return (ret);
	}

	function jsPrintf() {
		process.stdout.write(jsSprintf.apply(this, arguments));
	}

	function doPad(chr, width, left, str)
	{
		var ret = str;

		while (ret.length < width) {
			if (left)
				ret += chr;
			else
				ret = chr + ret;
		}

		return (ret);
	}

	/*
	 * This function dumps long stack traces for exceptions having a cause() method.
	 * See node-verror for an example.
	 */
	function dumpException(ex)
	{
		var ret;

		if (!(ex instanceof Error))
			throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));

		/* Note that V8 prepends "ex.stack" with ex.toString(). */
		ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;

		if (ex.cause && typeof (ex.cause) === 'function') {
			var cex = ex.cause();
			if (cex) {
				ret += '\nCaused by: ' + dumpException(cex);
			}
		}

		return (ret);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	// Because we are constructing error objects dynamically, we use an anonymous
	// function as the 'base constructor' then use arguments.callee to fill that in.
	// strict mode disallows agruments.callee, disable both of these rules.

	/* eslint-disable strict, no-caller */

	var util = __webpack_require__(10);

	var assert = __webpack_require__(4);

	var httpErrors = __webpack_require__(106);


	///--- Globals

	var slice = Function.prototype.call.bind(Array.prototype.slice);

	var HttpError = httpErrors.HttpError;

	var CODES = {
	    BadDigest: 400,
	    BadMethod: 405,
	    Internal: 500, // Don't have InternalErrorError
	    InvalidArgument: 409,
	    InvalidContent: 400,
	    InvalidCredentials: 401,
	    InvalidHeader: 400,
	    InvalidVersion: 400,
	    MissingParameter: 409,
	    NotAuthorized: 403,
	    PreconditionFailed: 412,
	    RequestExpired: 400,
	    RequestThrottled: 429,
	    ResourceNotFound: 404,
	    WrongAccept: 406
	};


	///--- API

	function RestError(options) {
	    assert.object(options, 'options');

	    options.constructorOpt = options.constructorOpt || RestError;
	    HttpError.apply(this, arguments);

	    var self = this;
	    this.restCode = options.restCode || 'Error';
	    this.body = options.body || {
	        code: self.restCode,
	        message: options.message || self.message
	    };
	}
	util.inherits(RestError, HttpError);


	///--- Exports

	module.exports = {
	    RestError: RestError
	};

	Object.keys(CODES).forEach(function (k) {
	    var name = k;

	    if (!/\w+Error$/.test(name)) {
	        name += 'Error';
	    }

	    module.exports[name] = function (cause, message) {
	        var index = 1;
	        var opts = {
	            restCode: (k === 'Internal' ? 'InternalError' : k),
	            statusCode: CODES[k]
	        };

	        opts.constructorOpt = arguments.callee;

	        if (cause && cause instanceof Error) {
	            opts.cause = cause;
	        } else if (typeof (cause) === 'object') {
	            opts.body = cause.body;
	            opts.cause = cause.cause;
	            opts.message = cause.message;
	            opts.statusCode = cause.statusCode || CODES[k];
	        } else {
	            index = 0;
	        }

	        var args = slice(arguments, index);
	        args.unshift(opts);
	        RestError.apply(this, args);
	    };
	    util.inherits(module.exports[name], RestError);
	    module.exports[name].displayName =
	        module.exports[name].prototype.name =
	            name;
	});


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(exports) {

	// export the class if we are in a Node-like system.
	if (typeof module === 'object' && module.exports === exports)
	  exports = module.exports = SemVer;

	// The debug function is excluded entirely from the minified version.

	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	exports.SEMVER_SPEC_VERSION = '2.0.0';

	var MAX_LENGTH = 256;
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

	// The actual regexps go on exports.re
	var re = exports.re = [];
	var src = exports.src = [];
	var R = 0;

	// The following Regular Expressions can be used for tokenizing,
	// validating, and parsing SemVer version strings.

	// ## Numeric Identifier
	// A single `0`, or a non-zero digit followed by zero or more digits.

	var NUMERICIDENTIFIER = R++;
	src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	var NUMERICIDENTIFIERLOOSE = R++;
	src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


	// ## Non-numeric Identifier
	// Zero or more digits, followed by a letter or hyphen, and then zero or
	// more letters, digits, or hyphens.

	var NONNUMERICIDENTIFIER = R++;
	src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


	// ## Main Version
	// Three dot-separated numeric identifiers.

	var MAINVERSION = R++;
	src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')';

	var MAINVERSIONLOOSE = R++;
	src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

	// ## Pre-release Version Identifier
	// A numeric identifier, or a non-numeric identifier.

	var PRERELEASEIDENTIFIER = R++;
	src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
	                            '|' + src[NONNUMERICIDENTIFIER] + ')';

	var PRERELEASEIDENTIFIERLOOSE = R++;
	src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
	                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


	// ## Pre-release Version
	// Hyphen, followed by one or more dot-separated pre-release version
	// identifiers.

	var PRERELEASE = R++;
	src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
	                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

	var PRERELEASELOOSE = R++;
	src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
	                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

	// ## Build Metadata Identifier
	// Any combination of digits, letters, or hyphens.

	var BUILDIDENTIFIER = R++;
	src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

	// ## Build Metadata
	// Plus sign, followed by one or more period-separated build metadata
	// identifiers.

	var BUILD = R++;
	src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
	             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


	// ## Full Version String
	// A main version, followed optionally by a pre-release version and
	// build metadata.

	// Note that the only major, minor, patch, and pre-release sections of
	// the version string are capturing groups.  The build metadata is not a
	// capturing group, because it should not ever be used in version
	// comparison.

	var FULL = R++;
	var FULLPLAIN = 'v?' + src[MAINVERSION] +
	                src[PRERELEASE] + '?' +
	                src[BUILD] + '?';

	src[FULL] = '^' + FULLPLAIN + '$';

	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	// common in the npm registry.
	var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
	                 src[PRERELEASELOOSE] + '?' +
	                 src[BUILD] + '?';

	var LOOSE = R++;
	src[LOOSE] = '^' + LOOSEPLAIN + '$';

	var GTLT = R++;
	src[GTLT] = '((?:<|>)?=?)';

	// Something like "2.*" or "1.2.x".
	// Note that "x.x" is a valid xRange identifer, meaning "any version"
	// Only the first item is strictly required.
	var XRANGEIDENTIFIERLOOSE = R++;
	src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	var XRANGEIDENTIFIER = R++;
	src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

	var XRANGEPLAIN = R++;
	src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:' + src[PRERELEASE] + ')?' +
	                   src[BUILD] + '?' +
	                   ')?)?';

	var XRANGEPLAINLOOSE = R++;
	src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:' + src[PRERELEASELOOSE] + ')?' +
	                        src[BUILD] + '?' +
	                        ')?)?';

	var XRANGE = R++;
	src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
	var XRANGELOOSE = R++;
	src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

	// Tilde ranges.
	// Meaning is "reasonably at or greater than"
	var LONETILDE = R++;
	src[LONETILDE] = '(?:~>?)';

	var TILDETRIM = R++;
	src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
	re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
	var tildeTrimReplace = '$1~';

	var TILDE = R++;
	src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
	var TILDELOOSE = R++;
	src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

	// Caret ranges.
	// Meaning is "at least and backwards compatible with"
	var LONECARET = R++;
	src[LONECARET] = '(?:\\^)';

	var CARETTRIM = R++;
	src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
	re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
	var caretTrimReplace = '$1^';

	var CARET = R++;
	src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
	var CARETLOOSE = R++;
	src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

	// A simple gt/lt/eq thing, or just "" to indicate "any version"
	var COMPARATORLOOSE = R++;
	src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
	var COMPARATOR = R++;
	src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


	// An expression to strip any whitespace between the gtlt and the thing
	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
	var COMPARATORTRIM = R++;
	src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
	                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

	// this one has to use the /g flag
	re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
	var comparatorTrimReplace = '$1$2$3';


	// Something like `1.2.3 - 1.2.4`
	// Note that these all use the loose form, because they'll be
	// checked against either the strict or loose comparator form
	// later.
	var HYPHENRANGE = R++;
	src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
	                   '\\s+-\\s+' +
	                   '(' + src[XRANGEPLAIN] + ')' +
	                   '\\s*$';

	var HYPHENRANGELOOSE = R++;
	src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s+-\\s+' +
	                        '(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s*$';

	// Star ranges basically just allow anything at all.
	var STAR = R++;
	src[STAR] = '(<|>)?=?\\s*\\*';

	// Compile to actual regexp objects.
	// All are flag-free, unless they were created above with a flag.
	for (var i = 0; i < R; i++) {
	  ;
	  if (!re[i])
	    re[i] = new RegExp(src[i]);
	}

	exports.parse = parse;
	function parse(version, loose) {
	  if (version instanceof SemVer)
	    return version;

	  if (typeof version !== 'string')
	    return null;

	  if (version.length > MAX_LENGTH)
	    return null;

	  var r = loose ? re[LOOSE] : re[FULL];
	  if (!r.test(version))
	    return null;

	  try {
	    return new SemVer(version, loose);
	  } catch (er) {
	    return null;
	  }
	}

	exports.valid = valid;
	function valid(version, loose) {
	  var v = parse(version, loose);
	  return v ? v.version : null;
	}


	exports.clean = clean;
	function clean(version, loose) {
	  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
	  return s ? s.version : null;
	}

	exports.SemVer = SemVer;

	function SemVer(version, loose) {
	  if (version instanceof SemVer) {
	    if (version.loose === loose)
	      return version;
	    else
	      version = version.version;
	  } else if (typeof version !== 'string') {
	    throw new TypeError('Invalid Version: ' + version);
	  }

	  if (version.length > MAX_LENGTH)
	    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

	  if (!(this instanceof SemVer))
	    return new SemVer(version, loose);

	  ;
	  this.loose = loose;
	  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

	  if (!m)
	    throw new TypeError('Invalid Version: ' + version);

	  this.raw = version;

	  // these are actually numbers
	  this.major = +m[1];
	  this.minor = +m[2];
	  this.patch = +m[3];

	  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
	    throw new TypeError('Invalid major version')

	  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
	    throw new TypeError('Invalid minor version')

	  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
	    throw new TypeError('Invalid patch version')

	  // numberify any prerelease numeric ids
	  if (!m[4])
	    this.prerelease = [];
	  else
	    this.prerelease = m[4].split('.').map(function(id) {
	      if (/^[0-9]+$/.test(id)) {
	        var num = +id
	        if (num >= 0 && num < MAX_SAFE_INTEGER)
	          return num
	      }
	      return id;
	    });

	  this.build = m[5] ? m[5].split('.') : [];
	  this.format();
	}

	SemVer.prototype.format = function() {
	  this.version = this.major + '.' + this.minor + '.' + this.patch;
	  if (this.prerelease.length)
	    this.version += '-' + this.prerelease.join('.');
	  return this.version;
	};

	SemVer.prototype.inspect = function() {
	  return '<SemVer "' + this + '">';
	};

	SemVer.prototype.toString = function() {
	  return this.version;
	};

	SemVer.prototype.compare = function(other) {
	  ;
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);

	  return this.compareMain(other) || this.comparePre(other);
	};

	SemVer.prototype.compareMain = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);

	  return compareIdentifiers(this.major, other.major) ||
	         compareIdentifiers(this.minor, other.minor) ||
	         compareIdentifiers(this.patch, other.patch);
	};

	SemVer.prototype.comparePre = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);

	  // NOT having a prerelease is > having one
	  if (this.prerelease.length && !other.prerelease.length)
	    return -1;
	  else if (!this.prerelease.length && other.prerelease.length)
	    return 1;
	  else if (!this.prerelease.length && !other.prerelease.length)
	    return 0;

	  var i = 0;
	  do {
	    var a = this.prerelease[i];
	    var b = other.prerelease[i];
	    ;
	    if (a === undefined && b === undefined)
	      return 0;
	    else if (b === undefined)
	      return 1;
	    else if (a === undefined)
	      return -1;
	    else if (a === b)
	      continue;
	    else
	      return compareIdentifiers(a, b);
	  } while (++i);
	};

	// preminor will bump the version up to the next minor release, and immediately
	// down to pre-release. premajor and prepatch work the same way.
	SemVer.prototype.inc = function(release, identifier) {
	  switch (release) {
	    case 'premajor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor = 0;
	      this.major++;
	      this.inc('pre', identifier);
	      break;
	    case 'preminor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor++;
	      this.inc('pre', identifier);
	      break;
	    case 'prepatch':
	      // If this is already a prerelease, it will bump to the next version
	      // drop any prereleases that might already exist, since they are not
	      // relevant at this point.
	      this.prerelease.length = 0;
	      this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;
	    // If the input is a non-prerelease version, this acts the same as
	    // prepatch.
	    case 'prerelease':
	      if (this.prerelease.length === 0)
	        this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;

	    case 'major':
	      // If this is a pre-major version, bump up to the same major version.
	      // Otherwise increment major.
	      // 1.0.0-5 bumps to 1.0.0
	      // 1.1.0 bumps to 2.0.0
	      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
	        this.major++;
	      this.minor = 0;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'minor':
	      // If this is a pre-minor version, bump up to the same minor version.
	      // Otherwise increment minor.
	      // 1.2.0-5 bumps to 1.2.0
	      // 1.2.1 bumps to 1.3.0
	      if (this.patch !== 0 || this.prerelease.length === 0)
	        this.minor++;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'patch':
	      // If this is not a pre-release version, it will increment the patch.
	      // If it is a pre-release it will bump up to the same patch version.
	      // 1.2.0-5 patches to 1.2.0
	      // 1.2.0 patches to 1.2.1
	      if (this.prerelease.length === 0)
	        this.patch++;
	      this.prerelease = [];
	      break;
	    // This probably shouldn't be used publicly.
	    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
	    case 'pre':
	      if (this.prerelease.length === 0)
	        this.prerelease = [0];
	      else {
	        var i = this.prerelease.length;
	        while (--i >= 0) {
	          if (typeof this.prerelease[i] === 'number') {
	            this.prerelease[i]++;
	            i = -2;
	          }
	        }
	        if (i === -1) // didn't increment anything
	          this.prerelease.push(0);
	      }
	      if (identifier) {
	        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	        if (this.prerelease[0] === identifier) {
	          if (isNaN(this.prerelease[1]))
	            this.prerelease = [identifier, 0];
	        } else
	          this.prerelease = [identifier, 0];
	      }
	      break;

	    default:
	      throw new Error('invalid increment argument: ' + release);
	  }
	  this.format();
	  return this;
	};

	exports.inc = inc;
	function inc(version, release, loose, identifier) {
	  if (typeof(loose) === 'string') {
	    identifier = loose;
	    loose = undefined;
	  }

	  try {
	    return new SemVer(version, loose).inc(release, identifier).version;
	  } catch (er) {
	    return null;
	  }
	}

	exports.diff = diff;
	function diff(version1, version2) {
	  if (eq(version1, version2)) {
	    return null;
	  } else {
	    var v1 = parse(version1);
	    var v2 = parse(version2);
	    if (v1.prerelease.length || v2.prerelease.length) {
	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return 'pre'+key;
	          }
	        }
	      }
	      return 'prerelease';
	    }
	    for (var key in v1) {
	      if (key === 'major' || key === 'minor' || key === 'patch') {
	        if (v1[key] !== v2[key]) {
	          return key;
	        }
	      }
	    }
	  }
	}

	exports.compareIdentifiers = compareIdentifiers;

	var numeric = /^[0-9]+$/;
	function compareIdentifiers(a, b) {
	  var anum = numeric.test(a);
	  var bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return (anum && !bnum) ? -1 :
	         (bnum && !anum) ? 1 :
	         a < b ? -1 :
	         a > b ? 1 :
	         0;
	}

	exports.rcompareIdentifiers = rcompareIdentifiers;
	function rcompareIdentifiers(a, b) {
	  return compareIdentifiers(b, a);
	}

	exports.major = major;
	function major(a, loose) {
	  return new SemVer(a, loose).major;
	}

	exports.minor = minor;
	function minor(a, loose) {
	  return new SemVer(a, loose).minor;
	}

	exports.patch = patch;
	function patch(a, loose) {
	  return new SemVer(a, loose).patch;
	}

	exports.compare = compare;
	function compare(a, b, loose) {
	  return new SemVer(a, loose).compare(b);
	}

	exports.compareLoose = compareLoose;
	function compareLoose(a, b) {
	  return compare(a, b, true);
	}

	exports.rcompare = rcompare;
	function rcompare(a, b, loose) {
	  return compare(b, a, loose);
	}

	exports.sort = sort;
	function sort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.compare(a, b, loose);
	  });
	}

	exports.rsort = rsort;
	function rsort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.rcompare(a, b, loose);
	  });
	}

	exports.gt = gt;
	function gt(a, b, loose) {
	  return compare(a, b, loose) > 0;
	}

	exports.lt = lt;
	function lt(a, b, loose) {
	  return compare(a, b, loose) < 0;
	}

	exports.eq = eq;
	function eq(a, b, loose) {
	  return compare(a, b, loose) === 0;
	}

	exports.neq = neq;
	function neq(a, b, loose) {
	  return compare(a, b, loose) !== 0;
	}

	exports.gte = gte;
	function gte(a, b, loose) {
	  return compare(a, b, loose) >= 0;
	}

	exports.lte = lte;
	function lte(a, b, loose) {
	  return compare(a, b, loose) <= 0;
	}

	exports.cmp = cmp;
	function cmp(a, op, b, loose) {
	  var ret;
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a === b;
	      break;
	    case '!==':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a !== b;
	      break;
	    case '': case '=': case '==': ret = eq(a, b, loose); break;
	    case '!=': ret = neq(a, b, loose); break;
	    case '>': ret = gt(a, b, loose); break;
	    case '>=': ret = gte(a, b, loose); break;
	    case '<': ret = lt(a, b, loose); break;
	    case '<=': ret = lte(a, b, loose); break;
	    default: throw new TypeError('Invalid operator: ' + op);
	  }
	  return ret;
	}

	exports.Comparator = Comparator;
	function Comparator(comp, loose) {
	  if (comp instanceof Comparator) {
	    if (comp.loose === loose)
	      return comp;
	    else
	      comp = comp.value;
	  }

	  if (!(this instanceof Comparator))
	    return new Comparator(comp, loose);

	  ;
	  this.loose = loose;
	  this.parse(comp);

	  if (this.semver === ANY)
	    this.value = '';
	  else
	    this.value = this.operator + this.semver.version;

	  ;
	}

	var ANY = {};
	Comparator.prototype.parse = function(comp) {
	  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var m = comp.match(r);

	  if (!m)
	    throw new TypeError('Invalid comparator: ' + comp);

	  this.operator = m[1];
	  if (this.operator === '=')
	    this.operator = '';

	  // if it literally is just '>' or '' then allow anything.
	  if (!m[2])
	    this.semver = ANY;
	  else
	    this.semver = new SemVer(m[2], this.loose);
	};

	Comparator.prototype.inspect = function() {
	  return '<SemVer Comparator "' + this + '">';
	};

	Comparator.prototype.toString = function() {
	  return this.value;
	};

	Comparator.prototype.test = function(version) {
	  ;

	  if (this.semver === ANY)
	    return true;

	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);

	  return cmp(version, this.operator, this.semver, this.loose);
	};


	exports.Range = Range;
	function Range(range, loose) {
	  if ((range instanceof Range) && range.loose === loose)
	    return range;

	  if (!(this instanceof Range))
	    return new Range(range, loose);

	  this.loose = loose;

	  // First, split based on boolean or ||
	  this.raw = range;
	  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
	    return this.parseRange(range.trim());
	  }, this).filter(function(c) {
	    // throw out any that are not relevant for whatever reason
	    return c.length;
	  });

	  if (!this.set.length) {
	    throw new TypeError('Invalid SemVer Range: ' + range);
	  }

	  this.format();
	}

	Range.prototype.inspect = function() {
	  return '<SemVer Range "' + this.range + '">';
	};

	Range.prototype.format = function() {
	  this.range = this.set.map(function(comps) {
	    return comps.join(' ').trim();
	  }).join('||').trim();
	  return this.range;
	};

	Range.prototype.toString = function() {
	  return this.range;
	};

	Range.prototype.parseRange = function(range) {
	  var loose = this.loose;
	  range = range.trim();
	  ;
	  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
	  range = range.replace(hr, hyphenReplace);
	  ;
	  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
	  ;

	  // `~ 1.2.3` => `~1.2.3`
	  range = range.replace(re[TILDETRIM], tildeTrimReplace);

	  // `^ 1.2.3` => `^1.2.3`
	  range = range.replace(re[CARETTRIM], caretTrimReplace);

	  // normalize spaces
	  range = range.split(/\s+/).join(' ');

	  // At this point, the range is completely trimmed and
	  // ready to be split into comparators.

	  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var set = range.split(' ').map(function(comp) {
	    return parseComparator(comp, loose);
	  }).join(' ').split(/\s+/);
	  if (this.loose) {
	    // in loose mode, throw out any that are not valid comparators
	    set = set.filter(function(comp) {
	      return !!comp.match(compRe);
	    });
	  }
	  set = set.map(function(comp) {
	    return new Comparator(comp, loose);
	  });

	  return set;
	};

	// Mostly just for testing and legacy API reasons
	exports.toComparators = toComparators;
	function toComparators(range, loose) {
	  return new Range(range, loose).set.map(function(comp) {
	    return comp.map(function(c) {
	      return c.value;
	    }).join(' ').trim().split(' ');
	  });
	}

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	function parseComparator(comp, loose) {
	  ;
	  comp = replaceCarets(comp, loose);
	  ;
	  comp = replaceTildes(comp, loose);
	  ;
	  comp = replaceXRanges(comp, loose);
	  ;
	  comp = replaceStars(comp, loose);
	  ;
	  return comp;
	}

	function isX(id) {
	  return !id || id.toLowerCase() === 'x' || id === '*';
	}

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
	function replaceTildes(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceTilde(comp, loose);
	  }).join(' ');
	}

	function replaceTilde(comp, loose) {
	  var r = loose ? re[TILDELOOSE] : re[TILDE];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    ;
	    var ret;

	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p))
	      // ~1.2 == >=1.2.0- <1.3.0-
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    else if (pr) {
	      ;
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      ret = '>=' + M + '.' + m + '.' + p + pr +
	            ' <' + M + '.' + (+m + 1) + '.0';
	    } else
	      // ~1.2.3 == >=1.2.3 <1.3.0
	      ret = '>=' + M + '.' + m + '.' + p +
	            ' <' + M + '.' + (+m + 1) + '.0';

	    ;
	    return ret;
	  });
	}

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
	// ^1.2.3 --> >=1.2.3 <2.0.0
	// ^1.2.0 --> >=1.2.0 <2.0.0
	function replaceCarets(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceCaret(comp, loose);
	  }).join(' ');
	}

	function replaceCaret(comp, loose) {
	  ;
	  var r = loose ? re[CARETLOOSE] : re[CARET];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    ;
	    var ret;

	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p)) {
	      if (M === '0')
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      else
	        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	    } else if (pr) {
	      ;
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p + pr +
	              ' <' + (+M + 1) + '.0.0';
	    } else {
	      ;
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p +
	              ' <' + (+M + 1) + '.0.0';
	    }

	    ;
	    return ret;
	  });
	}

	function replaceXRanges(comp, loose) {
	  ;
	  return comp.split(/\s+/).map(function(comp) {
	    return replaceXRange(comp, loose);
	  }).join(' ');
	}

	function replaceXRange(comp, loose) {
	  comp = comp.trim();
	  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
	  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
	    ;
	    var xM = isX(M);
	    var xm = xM || isX(m);
	    var xp = xm || isX(p);
	    var anyX = xp;

	    if (gtlt === '=' && anyX)
	      gtlt = '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // replace X with 0
	      if (xm)
	        m = 0;
	      if (xp)
	        p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        // >1.2.3 => >= 1.2.4
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else if (xp) {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<'
	        if (xm)
	          M = +M + 1
	        else
	          m = +m + 1
	      }

	      ret = gtlt + M + '.' + m + '.' + p;
	    } else if (xm) {
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    } else if (xp) {
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    }

	    ;

	    return ret;
	  });
	}

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	function replaceStars(comp, loose) {
	  ;
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp.trim().replace(re[STAR], '');
	}

	// This function is passed to string.replace(re[HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0
	function hyphenReplace($0,
	                       from, fM, fm, fp, fpr, fb,
	                       to, tM, tm, tp, tpr, tb) {

	  if (isX(fM))
	    from = '';
	  else if (isX(fm))
	    from = '>=' + fM + '.0.0';
	  else if (isX(fp))
	    from = '>=' + fM + '.' + fm + '.0';
	  else
	    from = '>=' + from;

	  if (isX(tM))
	    to = '';
	  else if (isX(tm))
	    to = '<' + (+tM + 1) + '.0.0';
	  else if (isX(tp))
	    to = '<' + tM + '.' + (+tm + 1) + '.0';
	  else if (tpr)
	    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
	  else
	    to = '<=' + to;

	  return (from + ' ' + to).trim();
	}


	// if ANY of the sets match ALL of its comparators, then pass
	Range.prototype.test = function(version) {
	  if (!version)
	    return false;

	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);

	  for (var i = 0; i < this.set.length; i++) {
	    if (testSet(this.set[i], version))
	      return true;
	  }
	  return false;
	};

	function testSet(set, version) {
	  for (var i = 0; i < set.length; i++) {
	    if (!set[i].test(version))
	      return false;
	  }

	  if (version.prerelease.length) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (var i = 0; i < set.length; i++) {
	      ;
	      if (set[i].semver === ANY)
	        continue;

	      if (set[i].semver.prerelease.length > 0) {
	        var allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch)
	          return true;
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false;
	  }

	  return true;
	}

	exports.satisfies = satisfies;
	function satisfies(version, range, loose) {
	  try {
	    range = new Range(range, loose);
	  } catch (er) {
	    return false;
	  }
	  return range.test(version);
	}

	exports.maxSatisfying = maxSatisfying;
	function maxSatisfying(versions, range, loose) {
	  return versions.filter(function(version) {
	    return satisfies(version, range, loose);
	  }).sort(function(a, b) {
	    return rcompare(a, b, loose);
	  })[0] || null;
	}

	exports.validRange = validRange;
	function validRange(range, loose) {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, loose).range || '*';
	  } catch (er) {
	    return null;
	  }
	}

	// Determine if version is less than all the versions possible in the range
	exports.ltr = ltr;
	function ltr(version, range, loose) {
	  return outside(version, range, '<', loose);
	}

	// Determine if version is greater than all the versions possible in the range.
	exports.gtr = gtr;
	function gtr(version, range, loose) {
	  return outside(version, range, '>', loose);
	}

	exports.outside = outside;
	function outside(version, range, hilo, loose) {
	  version = new SemVer(version, loose);
	  range = new Range(range, loose);

	  var gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break;
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break;
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"');
	  }

	  // If it satisifes the range it is not outside
	  if (satisfies(version, range, loose)) {
	    return false;
	  }

	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.

	  for (var i = 0; i < range.set.length; ++i) {
	    var comparators = range.set[i];

	    var high = null;
	    var low = null;

	    comparators.forEach(function(comparator) {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0')
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, loose)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, loose)) {
	        low = comparator;
	      }
	    });

	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false;
	    }

	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false;
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false;
	    }
	  }
	  return true;
	}

	// Use the define() function if we're in AMD land
	if (true)
	  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (exports), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	})(
	   true ? exports :
	  typeof define === 'function' && define.amd ? {} :
	  semver = {}
	);


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var
		http = __webpack_require__(76),
		https = __webpack_require__(87),
		util = __webpack_require__(10)
		;

	//----------------------------------------------------------------------------------------

	function KeepAliveAgent(options)
	{
		options = options || {};
		http.Agent.call(this, options);

		// Keys are host:port names, values are lists of sockets.
		this.idleSockets = {};

		// Replace the 'free' listener set up by the default node Agent above.
		this.removeAllListeners('free');
		this.on('free', KeepAliveAgent.prototype.freeHandler.bind(this));

	}
	util.inherits(KeepAliveAgent, http.Agent);

	function buildNameKey(host, port, localAddress)
	{
		var name = host + ':' + port;
		if (localAddress)
			name += ':' + localAddress;

		return name;
	}

	KeepAliveAgent.prototype.freeHandler = function(socket, host, port, localAddress)
	{
		var name = buildNameKey(host, port, localAddress);

		// If the socket is still useful, return it to the idle pool.
		if (this.isSocketUsable(socket))
		{
			socket._requestCount = socket._requestCount ? socket._requestCount + 1 : 1;

			if (!this.idleSockets[name])
				this.idleSockets[name] = [];

			this.idleSockets[name].push(socket);
		}

		// If we had any pending requests for this name, send the next one off now.
		if (this.requests[name] && this.requests[name].length)
		{
			var nextRequest = this.requests[name].shift();

			if (!this.requests[name].length)
				delete this.requests[name];

			this.addRequest(nextRequest, host, port, localAddress);
		}
	};

	KeepAliveAgent.prototype.addRequest = function(request, host, port, localAddress)
	{
		var name = buildNameKey(host, port, localAddress);

		var socket = this.nextIdleSocket(name);
		if (socket)
			request.onSocket(socket);
		else
			return http.Agent.prototype.addRequest.call(this, request, host, port, localAddress);
	};

	KeepAliveAgent.prototype.nextIdleSocket = function(name)
	{
		if (!this.idleSockets[name])
			return null;

		var socket;
		while(socket = this.idleSockets[name].shift())
		{
			// Check that this socket is still healthy after sitting around on the shelf.
			// This check is the reason this module exists.
			if (this.isSocketUsable(socket))
				return socket;
		}

		return null;
	};

	KeepAliveAgent.prototype.isSocketUsable = function(socket)
	{
		return !socket.destroyed;
	};


	KeepAliveAgent.prototype.removeSocket = function(socket, name, host, port, localAddress)
	{
		if (this.idleSockets[name])
		{
			var idx = this.idleSockets[name].indexOf(socket);
			if (idx !== -1)
			{
				this.idleSockets[name].splice(idx, 1);
				if (!this.idleSockets[name].length)
					delete this.idleSockets[name];
			}
		}

		http.Agent.prototype.removeSocket.call(this, socket, name, host, port, localAddress);
	};

	//----------------------------------------------------------------------------------------

	function HTTPSKeepAliveAgent(options)
	{
		KeepAliveAgent.call(this, options);
		this.createConnection = https.globalAgent.createConnection;
	}
	util.inherits(HTTPSKeepAliveAgent, KeepAliveAgent);

	HTTPSKeepAliveAgent.prototype.defaultPort = 443;

	HTTPSKeepAliveAgent.prototype.isSocketUsable = function(socket)
	{
		// TLS sockets null out their secure pair's ssl field in destroy() and
		// do not set a destroyed flag the way non-secure sockets do.
		return socket.pair && socket.pair.ssl;
	};

	//----------------------------------------------------------------------------------------

	module.exports = KeepAliveAgent;
	KeepAliveAgent.Secure = HTTPSKeepAliveAgent;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var util = __webpack_require__(10);

	var assert = __webpack_require__(4);

	var codeToHttpError = __webpack_require__(106).codeToHttpError;
	var RestError = __webpack_require__(105).RestError;
	var StringClient = __webpack_require__(115);


	///--- API

	function JsonClient(options) {
	    assert.object(options, 'options');

	    options.accept = 'application/json';
	    options.name = options.name || 'JsonClient';
	    options.contentType = 'application/json';

	    StringClient.call(this, options);

	    this._super = StringClient.prototype;
	}
	util.inherits(JsonClient, StringClient);

	module.exports = JsonClient;


	JsonClient.prototype.write = function write(options, body, callback) {
	    assert.ok(body !== undefined, 'body');
	    assert.object(body, 'body');

	    body = JSON.stringify(body !== null ? body : {});
	    return (this._super.write.call(this, options, body, callback));
	};


	JsonClient.prototype.parse = function parse(req, callback) {
	    var log = this.log;

	    function parseResponse(err, req2, res, data) {
	        var obj;

	        try {
	            if (data && !/^\s*$/.test(data)) {
	                obj = JSON.parse(data);
	            }
	        } catch (e) {
	            // Not really sure what else we can do here, besides
	            // make the client just keep going.
	            log.trace(e, 'Invalid JSON in response');
	        }
	        obj = obj || {};

	        if (res && res.statusCode >= 400) {
	            // Upcast error to a RestError (if we can)
	            // Be nice and handle errors like
	            // { error: { code: '', message: '' } }
	            // in addition to { code: '', message: '' }.
	            if (obj.code || (obj.error && obj.error.code)) {
	                var _c = obj.code ||
	                    (obj.error ? obj.error.code : '') ||
	                    '';
	                var _m = obj.message ||
	                    (obj.error ? obj.error.message : '') ||
	                    '';

	                err = new RestError({
	                    message: _m,
	                    restCode: _c,
	                    statusCode: res.statusCode
	                });
	                err.name = err.restCode;

	                if (!/Error$/.test(err.name)) {
	                    err.name += 'Error';
	                }
	            } else if (!err) {
	                err = codeToHttpError(res.statusCode,
	                    obj.message || '', data);
	            }
	        }

	        if (err) {
	            err.body = obj;
	        }

	        callback((err || null), req2, res, obj);
	    }

	    return (this._super.parse.call(this, req, parseResponse));
	};


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var crypto = __webpack_require__(59);
	var zlib = __webpack_require__(116);

	var assert = __webpack_require__(4);
	var qs = __webpack_require__(88);
	var util = __webpack_require__(10);

	var HttpClient = __webpack_require__(75);


	///--- Helpers


	///--- API

	function StringClient(options) {
	    assert.object(options, 'options');
	    assert.optionalObject(options.gzip, 'options.gzip');

	    options.accept = options.accept || 'text/plain';
	    options.name = options.name || 'StringClient';
	    options.contentType =
	        options.contentType || 'application/x-www-form-urlencoded';

	    HttpClient.call(this, options);
	    this.gzip = options.gzip;
	}
	util.inherits(StringClient, HttpClient);

	module.exports = StringClient;


	StringClient.prototype.post = function post(options, body, callback) {
	    var opts = this._options('POST', options);

	    if (typeof (body) === 'function') {
	        callback = body;
	        body = null;
	    }

	    return (this.write(opts, body, callback));
	};


	StringClient.prototype.put = function put(options, body, callback) {
	    var opts = this._options('PUT', options);

	    if (typeof (body) === 'function') {
	        callback = body;
	        body = null;
	    }

	    return (this.write(opts, body, callback));
	};


	StringClient.prototype.patch = function patch(options, body, callback) {
	    var opts = this._options('PATCH', options);

	    if (typeof (body) === 'function') {
	        callback = body;
	        body = null;
	    }

	    return (this.write(opts, body, callback));
	};


	StringClient.prototype.read = function read(options, callback) {
	    var self = this;
	    this.request(options, function _parse(err, req) {
	        if (err) {
	            return (callback(err, req));
	        }

	        req.once('result', self.parse(req, callback));
	        return (req.end());
	    });
	    return (this);
	};


	StringClient.prototype.write = function write(options, body, callback) {
	    if (body !== null && typeof (body) !== 'string') {
	        body = qs.stringify(body);
	    }

	    var self = this;

	    function _write(data) {
	        if (data) {
	            var hash = crypto.createHash('md5');
	            hash.update(data, 'utf8');
	            options.headers['content-md5'] = hash.digest('base64');
	        }

	        self.request(options, function (err, req) {
	            if (err) {
	                callback(err, req);
	                return;
	            }

	            req.once('result', self.parse(req, callback));
	            req.end(data);
	        });
	    }

	    options.headers = options.headers || {};

	    if (this.gzip) {
	        options.headers['accept-encoding'] = 'gzip';
	    }

	    if (body) {
	        if (this.gzip) {
	            options.headers['content-encoding'] = 'gzip';
	            zlib.gzip(body, function (err, data) {
	                if (err) {
	                    callback(err, null);
	                    return;
	                }

	                options.headers['content-length'] = data.length;
	                _write(data);
	            });
	        } else {
	            options.headers['content-length'] =
	                Buffer.byteLength(body);
	            _write(body);
	        }
	    } else {
	        _write();
	    }

	    return (this);
	};


	StringClient.prototype.parse = function parse(req, callback) {
	    function parseResponse(err, res) {
	        var body = '';
	        var gz;
	        var hash;
	        var md5;

	        function done() {
	            res.log.trace('body received:\n%s', body);
	            res.body = body;

	            if (hash && md5 !== hash.digest('base64')) {
	                err = new Error('BadDigest');
	                callback(err, req, res);
	                return;
	            }

	            if (err) {
	                err.body = body;
	                err.message = body;
	            }

	            callback(err, req, res, body);
	        }

	        if (res) {
	            md5 = res.headers['content-md5'];

	            if (md5 && req.method !== 'HEAD' && res.statusCode !== 206) {
	                hash = crypto.createHash('md5');
	            }

	            if (res.headers['content-encoding'] === 'gzip') {
	                gz = zlib.createGunzip();
	                gz.on('data', function (chunk) {
	                    body += chunk.toString('utf8');
	                });
	                gz.once('end', done);
	                res.once('end', gz.end.bind(gz));
	            } else {
	                res.setEncoding('utf8');
	                res.once('end', done);
	            }

	            res.on('data', function onData(chunk) {
	                if (hash) {
	                    hash.update(chunk);
	                }

	                if (gz) {
	                    gz.write(chunk);
	                } else {
	                    body += chunk;
	                }
	            });

	        } else {
	            callback(err, req, null, null);
	        }
	    }

	    return (parseResponse);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Transform = __webpack_require__(29);

	var binding = __webpack_require__(117);
	var util = __webpack_require__(10);
	var assert = __webpack_require__(9).ok;

	// zlib doesn't provide these, so kludge them in following the same
	// const naming scheme zlib uses.
	binding.Z_MIN_WINDOWBITS = 8;
	binding.Z_MAX_WINDOWBITS = 15;
	binding.Z_DEFAULT_WINDOWBITS = 15;

	// fewer than 64 bytes per chunk is stupid.
	// technically it could work with as few as 8, but even 64 bytes
	// is absurdly low.  Usually a MB or more is best.
	binding.Z_MIN_CHUNK = 64;
	binding.Z_MAX_CHUNK = Infinity;
	binding.Z_DEFAULT_CHUNK = (16 * 1024);

	binding.Z_MIN_MEMLEVEL = 1;
	binding.Z_MAX_MEMLEVEL = 9;
	binding.Z_DEFAULT_MEMLEVEL = 8;

	binding.Z_MIN_LEVEL = -1;
	binding.Z_MAX_LEVEL = 9;
	binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

	// expose all the zlib constants
	Object.keys(binding).forEach(function(k) {
	  if (k.match(/^Z/)) exports[k] = binding[k];
	});

	// translation table for return codes.
	exports.codes = {
	  Z_OK: binding.Z_OK,
	  Z_STREAM_END: binding.Z_STREAM_END,
	  Z_NEED_DICT: binding.Z_NEED_DICT,
	  Z_ERRNO: binding.Z_ERRNO,
	  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
	  Z_DATA_ERROR: binding.Z_DATA_ERROR,
	  Z_MEM_ERROR: binding.Z_MEM_ERROR,
	  Z_BUF_ERROR: binding.Z_BUF_ERROR,
	  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
	};

	Object.keys(exports.codes).forEach(function(k) {
	  exports.codes[exports.codes[k]] = k;
	});

	exports.Deflate = Deflate;
	exports.Inflate = Inflate;
	exports.Gzip = Gzip;
	exports.Gunzip = Gunzip;
	exports.DeflateRaw = DeflateRaw;
	exports.InflateRaw = InflateRaw;
	exports.Unzip = Unzip;

	exports.createDeflate = function(o) {
	  return new Deflate(o);
	};

	exports.createInflate = function(o) {
	  return new Inflate(o);
	};

	exports.createDeflateRaw = function(o) {
	  return new DeflateRaw(o);
	};

	exports.createInflateRaw = function(o) {
	  return new InflateRaw(o);
	};

	exports.createGzip = function(o) {
	  return new Gzip(o);
	};

	exports.createGunzip = function(o) {
	  return new Gunzip(o);
	};

	exports.createUnzip = function(o) {
	  return new Unzip(o);
	};


	// Convenience methods.
	// compress/decompress a string or buffer in one step.
	exports.deflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Deflate(opts), buffer, callback);
	};

	exports.deflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Deflate(opts), buffer);
	};

	exports.gzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gzip(opts), buffer, callback);
	};

	exports.gzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gzip(opts), buffer);
	};

	exports.deflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
	};

	exports.deflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new DeflateRaw(opts), buffer);
	};

	exports.unzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Unzip(opts), buffer, callback);
	};

	exports.unzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Unzip(opts), buffer);
	};

	exports.inflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Inflate(opts), buffer, callback);
	};

	exports.inflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Inflate(opts), buffer);
	};

	exports.gunzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gunzip(opts), buffer, callback);
	};

	exports.gunzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gunzip(opts), buffer);
	};

	exports.inflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new InflateRaw(opts), buffer, callback);
	};

	exports.inflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new InflateRaw(opts), buffer);
	};

	function zlibBuffer(engine, buffer, callback) {
	  var buffers = [];
	  var nread = 0;

	  engine.on('error', onError);
	  engine.on('end', onEnd);

	  engine.end(buffer);
	  flow();

	  function flow() {
	    var chunk;
	    while (null !== (chunk = engine.read())) {
	      buffers.push(chunk);
	      nread += chunk.length;
	    }
	    engine.once('readable', flow);
	  }

	  function onError(err) {
	    engine.removeListener('end', onEnd);
	    engine.removeListener('readable', flow);
	    callback(err);
	  }

	  function onEnd() {
	    var buf = Buffer.concat(buffers, nread);
	    buffers = [];
	    callback(null, buf);
	    engine.close();
	  }
	}

	function zlibBufferSync(engine, buffer) {
	  if (typeof buffer === 'string')
	    buffer = new Buffer(buffer);
	  if (!Buffer.isBuffer(buffer))
	    throw new TypeError('Not a string or buffer');

	  var flushFlag = binding.Z_FINISH;

	  return engine._processChunk(buffer, flushFlag);
	}

	// generic zlib
	// minimal 2-byte header
	function Deflate(opts) {
	  if (!(this instanceof Deflate)) return new Deflate(opts);
	  Zlib.call(this, opts, binding.DEFLATE);
	}

	function Inflate(opts) {
	  if (!(this instanceof Inflate)) return new Inflate(opts);
	  Zlib.call(this, opts, binding.INFLATE);
	}



	// gzip - bigger header, same deflate compression
	function Gzip(opts) {
	  if (!(this instanceof Gzip)) return new Gzip(opts);
	  Zlib.call(this, opts, binding.GZIP);
	}

	function Gunzip(opts) {
	  if (!(this instanceof Gunzip)) return new Gunzip(opts);
	  Zlib.call(this, opts, binding.GUNZIP);
	}



	// raw - no header
	function DeflateRaw(opts) {
	  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
	  Zlib.call(this, opts, binding.DEFLATERAW);
	}

	function InflateRaw(opts) {
	  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
	  Zlib.call(this, opts, binding.INFLATERAW);
	}


	// auto-detect header.
	function Unzip(opts) {
	  if (!(this instanceof Unzip)) return new Unzip(opts);
	  Zlib.call(this, opts, binding.UNZIP);
	}


	// the Zlib class they all inherit from
	// This thing manages the queue of requests, and returns
	// true or false if there is anything in the queue when
	// you call the .write() method.

	function Zlib(opts, mode) {
	  this._opts = opts = opts || {};
	  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

	  Transform.call(this, opts);

	  if (opts.flush) {
	    if (opts.flush !== binding.Z_NO_FLUSH &&
	        opts.flush !== binding.Z_PARTIAL_FLUSH &&
	        opts.flush !== binding.Z_SYNC_FLUSH &&
	        opts.flush !== binding.Z_FULL_FLUSH &&
	        opts.flush !== binding.Z_FINISH &&
	        opts.flush !== binding.Z_BLOCK) {
	      throw new Error('Invalid flush flag: ' + opts.flush);
	    }
	  }
	  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

	  if (opts.chunkSize) {
	    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
	        opts.chunkSize > exports.Z_MAX_CHUNK) {
	      throw new Error('Invalid chunk size: ' + opts.chunkSize);
	    }
	  }

	  if (opts.windowBits) {
	    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
	        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
	      throw new Error('Invalid windowBits: ' + opts.windowBits);
	    }
	  }

	  if (opts.level) {
	    if (opts.level < exports.Z_MIN_LEVEL ||
	        opts.level > exports.Z_MAX_LEVEL) {
	      throw new Error('Invalid compression level: ' + opts.level);
	    }
	  }

	  if (opts.memLevel) {
	    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
	        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
	      throw new Error('Invalid memLevel: ' + opts.memLevel);
	    }
	  }

	  if (opts.strategy) {
	    if (opts.strategy != exports.Z_FILTERED &&
	        opts.strategy != exports.Z_HUFFMAN_ONLY &&
	        opts.strategy != exports.Z_RLE &&
	        opts.strategy != exports.Z_FIXED &&
	        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
	      throw new Error('Invalid strategy: ' + opts.strategy);
	    }
	  }

	  if (opts.dictionary) {
	    if (!Buffer.isBuffer(opts.dictionary)) {
	      throw new Error('Invalid dictionary: it should be a Buffer instance');
	    }
	  }

	  this._binding = new binding.Zlib(mode);

	  var self = this;
	  this._hadError = false;
	  this._binding.onerror = function(message, errno) {
	    // there is no way to cleanly recover.
	    // continuing only obscures problems.
	    self._binding = null;
	    self._hadError = true;

	    var error = new Error(message);
	    error.errno = errno;
	    error.code = exports.codes[errno];
	    self.emit('error', error);
	  };

	  var level = exports.Z_DEFAULT_COMPRESSION;
	  if (typeof opts.level === 'number') level = opts.level;

	  var strategy = exports.Z_DEFAULT_STRATEGY;
	  if (typeof opts.strategy === 'number') strategy = opts.strategy;

	  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
	                     level,
	                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
	                     strategy,
	                     opts.dictionary);

	  this._buffer = new Buffer(this._chunkSize);
	  this._offset = 0;
	  this._closed = false;
	  this._level = level;
	  this._strategy = strategy;

	  this.once('end', this.close);
	}

	util.inherits(Zlib, Transform);

	Zlib.prototype.params = function(level, strategy, callback) {
	  if (level < exports.Z_MIN_LEVEL ||
	      level > exports.Z_MAX_LEVEL) {
	    throw new RangeError('Invalid compression level: ' + level);
	  }
	  if (strategy != exports.Z_FILTERED &&
	      strategy != exports.Z_HUFFMAN_ONLY &&
	      strategy != exports.Z_RLE &&
	      strategy != exports.Z_FIXED &&
	      strategy != exports.Z_DEFAULT_STRATEGY) {
	    throw new TypeError('Invalid strategy: ' + strategy);
	  }

	  if (this._level !== level || this._strategy !== strategy) {
	    var self = this;
	    this.flush(binding.Z_SYNC_FLUSH, function() {
	      self._binding.params(level, strategy);
	      if (!self._hadError) {
	        self._level = level;
	        self._strategy = strategy;
	        if (callback) callback();
	      }
	    });
	  } else {
	    process.nextTick(callback);
	  }
	};

	Zlib.prototype.reset = function() {
	  return this._binding.reset();
	};

	// This is the _flush function called by the transform class,
	// internally, when the last chunk has been written.
	Zlib.prototype._flush = function(callback) {
	  this._transform(new Buffer(0), '', callback);
	};

	Zlib.prototype.flush = function(kind, callback) {
	  var ws = this._writableState;

	  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
	    callback = kind;
	    kind = binding.Z_FULL_FLUSH;
	  }

	  if (ws.ended) {
	    if (callback)
	      process.nextTick(callback);
	  } else if (ws.ending) {
	    if (callback)
	      this.once('end', callback);
	  } else if (ws.needDrain) {
	    var self = this;
	    this.once('drain', function() {
	      self.flush(callback);
	    });
	  } else {
	    this._flushFlag = kind;
	    this.write(new Buffer(0), '', callback);
	  }
	};

	Zlib.prototype.close = function(callback) {
	  if (callback)
	    process.nextTick(callback);

	  if (this._closed)
	    return;

	  this._closed = true;

	  this._binding.close();

	  var self = this;
	  process.nextTick(function() {
	    self.emit('close');
	  });
	};

	Zlib.prototype._transform = function(chunk, encoding, cb) {
	  var flushFlag;
	  var ws = this._writableState;
	  var ending = ws.ending || ws.ended;
	  var last = ending && (!chunk || ws.length === chunk.length);

	  if (!chunk === null && !Buffer.isBuffer(chunk))
	    return cb(new Error('invalid input'));

	  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
	  // If it's explicitly flushing at some other time, then we use
	  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
	  // goodness.
	  if (last)
	    flushFlag = binding.Z_FINISH;
	  else {
	    flushFlag = this._flushFlag;
	    // once we've flushed the last of the queue, stop flushing and
	    // go back to the normal behavior.
	    if (chunk.length >= ws.length) {
	      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
	    }
	  }

	  var self = this;
	  this._processChunk(chunk, flushFlag, cb);
	};

	Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
	  var availInBefore = chunk && chunk.length;
	  var availOutBefore = this._chunkSize - this._offset;
	  var inOff = 0;

	  var self = this;

	  var async = typeof cb === 'function';

	  if (!async) {
	    var buffers = [];
	    var nread = 0;

	    var error;
	    this.on('error', function(er) {
	      error = er;
	    });

	    do {
	      var res = this._binding.writeSync(flushFlag,
	                                        chunk, // in
	                                        inOff, // in_off
	                                        availInBefore, // in_len
	                                        this._buffer, // out
	                                        this._offset, //out_off
	                                        availOutBefore); // out_len
	    } while (!this._hadError && callback(res[0], res[1]));

	    if (this._hadError) {
	      throw error;
	    }

	    var buf = Buffer.concat(buffers, nread);
	    this.close();

	    return buf;
	  }

	  var req = this._binding.write(flushFlag,
	                                chunk, // in
	                                inOff, // in_off
	                                availInBefore, // in_len
	                                this._buffer, // out
	                                this._offset, //out_off
	                                availOutBefore); // out_len

	  req.buffer = chunk;
	  req.callback = callback;

	  function callback(availInAfter, availOutAfter) {
	    if (self._hadError)
	      return;

	    var have = availOutBefore - availOutAfter;
	    assert(have >= 0, 'have should not go down');

	    if (have > 0) {
	      var out = self._buffer.slice(self._offset, self._offset + have);
	      self._offset += have;
	      // serve some output to the consumer.
	      if (async) {
	        self.push(out);
	      } else {
	        buffers.push(out);
	        nread += out.length;
	      }
	    }

	    // exhausted the output buffer, or used all the input create a new one.
	    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
	      availOutBefore = self._chunkSize;
	      self._offset = 0;
	      self._buffer = new Buffer(self._chunkSize);
	    }

	    if (availOutAfter === 0) {
	      // Not actually done.  Need to reprocess.
	      // Also, update the availInBefore to the availInAfter value,
	      // so that if we have to hit it a third (fourth, etc.) time,
	      // it'll have the correct byte counts.
	      inOff += (availInBefore - availInAfter);
	      availInBefore = availInAfter;

	      if (!async)
	        return true;

	      var newReq = self._binding.write(flushFlag,
	                                       chunk,
	                                       inOff,
	                                       availInBefore,
	                                       self._buffer,
	                                       self._offset,
	                                       self._chunkSize);
	      newReq.callback = callback; // this same function
	      newReq.buffer = chunk;
	      return;
	    }

	    if (!async)
	      return false;

	    // finished with the chunk.
	    cb();
	  }
	};

	util.inherits(Deflate, Zlib);
	util.inherits(Inflate, Zlib);
	util.inherits(Gzip, Zlib);
	util.inherits(Gunzip, Zlib);
	util.inherits(DeflateRaw, Zlib);
	util.inherits(InflateRaw, Zlib);
	util.inherits(Unzip, Zlib);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(2)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {var msg = __webpack_require__(118);
	var zstream = __webpack_require__(119);
	var zlib_deflate = __webpack_require__(120);
	var zlib_inflate = __webpack_require__(125);
	var constants = __webpack_require__(128);

	for (var key in constants) {
	  exports[key] = constants[key];
	}

	// zlib modes
	exports.NONE = 0;
	exports.DEFLATE = 1;
	exports.INFLATE = 2;
	exports.GZIP = 3;
	exports.GUNZIP = 4;
	exports.DEFLATERAW = 5;
	exports.INFLATERAW = 6;
	exports.UNZIP = 7;

	/**
	 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
	 */
	function Zlib(mode) {
	  if (mode < exports.DEFLATE || mode > exports.UNZIP)
	    throw new TypeError("Bad argument");
	    
	  this.mode = mode;
	  this.init_done = false;
	  this.write_in_progress = false;
	  this.pending_close = false;
	  this.windowBits = 0;
	  this.level = 0;
	  this.memLevel = 0;
	  this.strategy = 0;
	  this.dictionary = null;
	}

	Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
	  this.windowBits = windowBits;
	  this.level = level;
	  this.memLevel = memLevel;
	  this.strategy = strategy;
	  // dictionary not supported.
	  
	  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
	    this.windowBits += 16;
	    
	  if (this.mode === exports.UNZIP)
	    this.windowBits += 32;
	    
	  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
	    this.windowBits = -this.windowBits;
	    
	  this.strm = new zstream();
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateInit2(
	        this.strm,
	        this.level,
	        exports.Z_DEFLATED,
	        this.windowBits,
	        this.memLevel,
	        this.strategy
	      );
	      break;
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	    case exports.UNZIP:
	      var status  = zlib_inflate.inflateInit2(
	        this.strm,
	        this.windowBits
	      );
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	    return;
	  }
	  
	  this.write_in_progress = false;
	  this.init_done = true;
	};

	Zlib.prototype.params = function() {
	  throw new Error("deflateParams Not supported");
	};

	Zlib.prototype._writeCheck = function() {
	  if (!this.init_done)
	    throw new Error("write before init");
	    
	  if (this.mode === exports.NONE)
	    throw new Error("already finalized");
	    
	  if (this.write_in_progress)
	    throw new Error("write already in progress");
	    
	  if (this.pending_close)
	    throw new Error("close is pending");
	};

	Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
	  this._writeCheck();
	  this.write_in_progress = true;
	  
	  var self = this;
	  process.nextTick(function() {
	    self.write_in_progress = false;
	    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
	    self.callback(res[0], res[1]);
	    
	    if (self.pending_close)
	      self.close();
	  });
	  
	  return this;
	};

	// set method for Node buffers, used by pako
	function bufferSet(data, offset) {
	  for (var i = 0; i < data.length; i++) {
	    this[offset + i] = data[i];
	  }
	}

	Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this._writeCheck();
	  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
	};

	Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this.write_in_progress = true;
	  
	  if (flush !== exports.Z_NO_FLUSH &&
	      flush !== exports.Z_PARTIAL_FLUSH &&
	      flush !== exports.Z_SYNC_FLUSH &&
	      flush !== exports.Z_FULL_FLUSH &&
	      flush !== exports.Z_FINISH &&
	      flush !== exports.Z_BLOCK) {
	    throw new Error("Invalid flush value");
	  }
	  
	  if (input == null) {
	    input = new Buffer(0);
	    in_len = 0;
	    in_off = 0;
	  }
	  
	  if (out._set)
	    out.set = out._set;
	  else
	    out.set = bufferSet;
	  
	  var strm = this.strm;
	  strm.avail_in = in_len;
	  strm.input = input;
	  strm.next_in = in_off;
	  strm.avail_out = out_len;
	  strm.output = out;
	  strm.next_out = out_off;
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflate(strm, flush);
	      break;
	    case exports.UNZIP:
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflate(strm, flush);
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
	    this._error(status);
	  }
	  
	  this.write_in_progress = false;
	  return [strm.avail_in, strm.avail_out];
	};

	Zlib.prototype.close = function() {
	  if (this.write_in_progress) {
	    this.pending_close = true;
	    return;
	  }
	  
	  this.pending_close = false;
	  
	  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
	    zlib_deflate.deflateEnd(this.strm);
	  } else {
	    zlib_inflate.inflateEnd(this.strm);
	  }
	  
	  this.mode = exports.NONE;
	};

	Zlib.prototype.reset = function() {
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateReset(this.strm);
	      break;
	    case exports.INFLATE:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflateReset(this.strm);
	      break;
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	  }
	};

	Zlib.prototype._error = function(status) {
	  this.onerror(msg[status] + ': ' + this.strm.msg, status);
	  
	  this.write_in_progress = false;
	  if (this.pending_close)
	    this.close();
	};

	exports.Zlib = Zlib;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(5).Buffer))

/***/ },
/* 118 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};


/***/ },
/* 119 */
/***/ function(module, exports) {

	'use strict';


	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	module.exports = ZStream;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils   = __webpack_require__(121);
	var trees   = __webpack_require__(122);
	var adler32 = __webpack_require__(123);
	var crc32   = __webpack_require__(124);
	var msg     = __webpack_require__(118);

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;


	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;


	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED               = 4;
	var Z_DEFAULT_STRATEGY    = 0;

	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;


	/* The deflate compression method */
	var Z_DEFLATED  = 8;

	/*============================================================================*/


	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;


	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES       = 30;
	/* number of distance codes */
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS  = 15;
	/* All codes must not exceed MAX_BITS bits */

	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

	var PRESET_DICT = 0x20;

	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;

	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}

	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}

	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;

	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }

	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}


	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}


	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}


	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}


	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;

	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }

	  strm.avail_in -= len;

	  // zmemcpy(buf, strm->next_in, len);
	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  }

	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }

	  strm.next_in += len;
	  strm.total_in += len;

	  return len;
	}


	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

	  var _win = s.window; // shortcut

	  var wmask = s.w_mask;
	  var prev  = s.prev;

	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */

	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];

	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;

	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */

	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }

	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");

	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);

	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;

	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}


	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;

	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

	  do {
	    more = s.window_size - s.lookahead - s.strstart;

	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}


	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;

	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */

	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);

	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);

	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }

	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;

	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];

	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */

	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}

	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;

	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }

	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {

	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }

	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }

	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");

	    s.strstart += s.lookahead;
	    s.lookahead = 0;

	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;

	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/


	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;

	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }

	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_NEED_MORE;
	}

	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;

	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */

	  var max_insert;

	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH - 1;

	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */

	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH - 1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */

	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH - 1;
	      s.strstart++;

	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }

	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}


	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */

	  var _win = s.window;

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }

	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }

	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	}

	var configuration_table;

	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];


	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;

	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);

	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;

	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}


	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */

	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */

	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */

	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */

	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */

	  this.head = null;   /* Heads of the hash chains or NIL. */

	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */

	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */

	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */

	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */

	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */

	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */

	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */

	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/

	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */

	  this.nice_match = 0; /* Stop searching when current match exceeds this */

	              /* used by trees.c: */

	  /* Didn't use ct_data typedef below to suppress compiler warning */

	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
	  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);

	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */

	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
	  zero(this.heap);

	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */

	  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */

	  this.l_buf = 0;          /* buffer index for literals or lengths */

	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */

	  this.last_lit = 0;      /* running index in l_buf */

	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */

	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */


	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */

	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}


	function deflateResetKeep(strm) {
	  var s;

	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;

	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;

	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}


	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}


	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}


	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;

	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }

	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }

	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }


	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }


	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */

	  var s = new DeflateState();

	  strm.state = s;
	  s.strm = strm;

	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;

	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);

	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */

	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

	  s.pending_buf_size = s.lit_bufsize * 4;

	  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
	  //s->pending_buf = (uchf *) overlay;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);

	  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
	  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
	  s.d_buf = 1 * s.lit_bufsize;

	  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
	  s.l_buf = (1 + 2) * s.lit_bufsize;

	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;

	  return deflateReset(strm);
	}

	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}


	function deflate(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only

	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }

	  s = strm.state;

	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }

	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;

	  /* Write the header */
	  if (s.status === INIT_STATE) {

	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	                );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;

	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);

	      s.status = BUSY_STATE;
	      putShortMSB(s, header);

	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }

	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */

	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif

	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }

	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));

	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero(s.head); // Fill with NIL (= 0);

	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}

	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }

	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }

	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}

	function deflateEnd(strm) {
	  var status;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.state = null;

	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}


	/* =========================================================================
	 * Initializes the compression dictionary from the given byte
	 * sequence without producing any compressed output.
	 */
	function deflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var s;
	  var str, n;
	  var wrap;
	  var avail;
	  var next;
	  var input;
	  var tmpDict;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  s = strm.state;
	  wrap = s.wrap;

	  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
	    return Z_STREAM_ERROR;
	  }

	  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
	  if (wrap === 1) {
	    /* adler32(strm->adler, dictionary, dictLength); */
	    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
	  }

	  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

	  /* if dictionary would fill window, just replace the history */
	  if (dictLength >= s.w_size) {
	    if (wrap === 0) {            /* already empty otherwise */
	      /*** CLEAR_HASH(s); ***/
	      zero(s.head); // Fill with NIL (= 0);
	      s.strstart = 0;
	      s.block_start = 0;
	      s.insert = 0;
	    }
	    /* use the tail */
	    // dictionary = dictionary.slice(dictLength - s.w_size);
	    tmpDict = new utils.Buf8(s.w_size);
	    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
	    dictionary = tmpDict;
	    dictLength = s.w_size;
	  }
	  /* insert dictionary into window and hash */
	  avail = strm.avail_in;
	  next = strm.next_in;
	  input = strm.input;
	  strm.avail_in = dictLength;
	  strm.next_in = 0;
	  strm.input = dictionary;
	  fill_window(s);
	  while (s.lookahead >= MIN_MATCH) {
	    str = s.strstart;
	    n = s.lookahead - (MIN_MATCH - 1);
	    do {
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

	      s.prev[str & s.w_mask] = s.head[s.ins_h];

	      s.head[s.ins_h] = str;
	      str++;
	    } while (--n);
	    s.strstart = str;
	    s.lookahead = MIN_MATCH - 1;
	    fill_window(s);
	  }
	  s.strstart += s.lookahead;
	  s.block_start = s.strstart;
	  s.insert = s.lookahead;
	  s.lookahead = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  strm.next_in = next;
	  strm.input = input;
	  strm.avail_in = avail;
	  s.wrap = wrap;
	  return Z_OK;
	}


	exports.deflateInit = deflateInit;
	exports.deflateInit2 = deflateInit2;
	exports.deflateReset = deflateReset;
	exports.deflateResetKeep = deflateResetKeep;
	exports.deflateSetHeader = deflateSetHeader;
	exports.deflate = deflate;
	exports.deflateEnd = deflateEnd;
	exports.deflateSetDictionary = deflateSetDictionary;
	exports.deflateInfo = 'pako deflate (from Nodeca project)';

	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/


/***/ },
/* 121 */
/***/ function(module, exports) {

	'use strict';


	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');


	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }

	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }

	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }

	  return obj;
	};


	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};


	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    var i, l, len, pos, chunk, result;

	    // calculate data length
	    len = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      len += chunks[i].length;
	    }

	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }

	    return result;
	  }
	};

	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    return [].concat.apply([], chunks);
	  }
	};


	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};

	exports.setTyped(TYPED_OK);


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var utils = __webpack_require__(121);

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;

	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;

	/*============================================================================*/


	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

	// From zutil.h

	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */

	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */

	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */

	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */

	var LITERALS      = 256;
	/* number of literal bytes 0..255 */

	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */

	var D_CODES       = 30;
	/* number of distance codes */

	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */

	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */

	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */

	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */


	/* ===========================================================================
	 * Constants
	 */

	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */

	var END_BLOCK   = 256;
	/* end of block literal code */

	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */

	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */

	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */

	/* eslint-disable comma-spacing,array-bracket-spacing */
	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* eslint-enable comma-spacing,array-bracket-spacing */

	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */

	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */

	// We pre-fill arrays with 0 to avoid uninitialized gaps

	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

	// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */

	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */

	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */

	var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */

	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */

	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */


	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */

	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	}


	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;


	function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	}



	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}


	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}


	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}


	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
	}


	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}


	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;

	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}


	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */

	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }

	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

	  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */

	    if (n > max_code) { continue; } /* not a leaf node */

	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }

	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */

	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);

	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
	        tree[m * 2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}


	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */

	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n * 2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}


	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  // do check in _tr_init()
	  //if (static_init_done) return;

	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/

	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1 << extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;

	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1 << extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }

	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES + 1, bl_count);

	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n * 2 + 1]/*.Len*/ = 5;
	    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
	  }

	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

	  //static_init_done = true;
	}


	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */

	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

	  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}


	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}

	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */

	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}

	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}

	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;

	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}


	// inlined manually
	// var SMALLEST = 1;

	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */

	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;

	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");

	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */

	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");

	    } while (lx < s.last_lit);
	  }

	  send_code(s, END_BLOCK, ltree);
	}


	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */

	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;

	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;

	    } else {
	      tree[n * 2 + 1]/*.Len*/ = 0;
	    }
	  }

	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;

	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;

	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/

	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;

	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);

	  } while (s.heap_len >= 2);

	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);

	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}


	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;

	    } else if (curlen !== 0) {

	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

	    } else {
	      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
	    }

	    count = 0;
	    prevlen = curlen;

	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);

	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);

	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }

	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */

	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */

	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));

	  return max_blindex;
	}


	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */

	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1,   5);
	  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}


	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;

	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }

	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }

	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}


	var static_init_done = false;

	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{

	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }

	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

	  s.bi_buf = 0;
	  s.bi_valid = 0;

	  /* Initialize the first block of the first file: */
	  init_block(s);
	}


	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}


	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}


	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */

	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {

	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }

	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));

	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */

	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);

	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
	    static_lenb = (s.static_len + 3 + 7) >>> 3;

	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));

	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }

	  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */

	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);

	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);

	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);

	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}

	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;

	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;

	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

	    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }

	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility

	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif

	  return (s.last_lit === s.lit_bufsize - 1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}

	exports._tr_init  = _tr_init;
	exports._tr_stored_block = _tr_stored_block;
	exports._tr_flush_block  = _tr_flush_block;
	exports._tr_tally = _tr_tally;
	exports._tr_align = _tr_align;


/***/ },
/* 123 */
/***/ function(module, exports) {

	'use strict';

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.

	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return (s1 | (s2 << 16)) |0;
	}


	module.exports = adler32;


/***/ },
/* 124 */
/***/ function(module, exports) {

	'use strict';

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.


	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];

	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();


	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc ^= -1;

	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return (crc ^ (-1)); // >>> 0;
	}


	module.exports = crc32;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var utils         = __webpack_require__(121);
	var adler32       = __webpack_require__(123);
	var crc32         = __webpack_require__(124);
	var inflate_fast  = __webpack_require__(126);
	var inflate_table = __webpack_require__(127);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED  = 8;


	/* STATES ====================================================================*/
	/* ===========================================================================*/


	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/



	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;


	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}


	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */

	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);

	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}


	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }

	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }

	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}


	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new utils.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}

	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }

	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	    case HEAD:
	      if (state.wrap === 0) {
	        state.mode = TYPEDO;
	        break;
	      }
	      //=== NEEDBITS(16);
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//

	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = FLAGS;
	        break;
	      }
	      state.flags = 0;           /* expect zlib header */
	      if (state.head) {
	        state.head.done = false;
	      }
	      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	        strm.msg = 'incorrect header check';
	        state.mode = BAD;
	        break;
	      }
	      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	      len = (hold & 0x0f)/*BITS(4)*/ + 8;
	      if (state.wbits === 0) {
	        state.wbits = len;
	      }
	      else if (len > state.wbits) {
	        strm.msg = 'invalid window size';
	        state.mode = BAD;
	        break;
	      }
	      state.dmax = 1 << len;
	      //Tracev((stderr, "inflate:   zlib header ok\n"));
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = hold & 0x200 ? DICTID : TYPE;
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      break;
	    case FLAGS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.flags = hold;
	      if ((state.flags & 0xff) !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      if (state.flags & 0xe000) {
	        strm.msg = 'unknown header flags set';
	        state.mode = BAD;
	        break;
	      }
	      if (state.head) {
	        state.head.text = ((hold >> 8) & 1);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = TIME;
	      /* falls through */
	    case TIME:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.time = hold;
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC4(state.check, hold)
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        hbuf[2] = (hold >>> 16) & 0xff;
	        hbuf[3] = (hold >>> 24) & 0xff;
	        state.check = crc32(state.check, hbuf, 4, 0);
	        //===
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = OS;
	      /* falls through */
	    case OS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.xflags = (hold & 0xff);
	        state.head.os = (hold >> 8);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = EXLEN;
	      /* falls through */
	    case EXLEN:
	      if (state.flags & 0x0400) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length = hold;
	        if (state.head) {
	          state.head.extra_len = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      else if (state.head) {
	        state.head.extra = null/*Z_NULL*/;
	      }
	      state.mode = EXTRA;
	      /* falls through */
	    case EXTRA:
	      if (state.flags & 0x0400) {
	        copy = state.length;
	        if (copy > have) { copy = have; }
	        if (copy) {
	          if (state.head) {
	            len = state.head.extra_len - state.length;
	            if (!state.head.extra) {
	              // Use untyped array for more conveniend processing later
	              state.head.extra = new Array(state.head.extra_len);
	            }
	            utils.arraySet(
	              state.head.extra,
	              input,
	              next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len
	            );
	            //zmemcpy(state.head.extra + len, next,
	            //        len + copy > state.head.extra_max ?
	            //        state.head.extra_max - len : copy);
	          }
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          state.length -= copy;
	        }
	        if (state.length) { break inf_leave; }
	      }
	      state.length = 0;
	      state.mode = NAME;
	      /* falls through */
	    case NAME:
	      if (state.flags & 0x0800) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          // TODO: 2 or 1 bytes?
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.name_max*/)) {
	            state.head.name += String.fromCharCode(len);
	          }
	        } while (len && copy < have);

	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.name = null;
	      }
	      state.length = 0;
	      state.mode = COMMENT;
	      /* falls through */
	    case COMMENT:
	      if (state.flags & 0x1000) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.comm_max*/)) {
	            state.head.comment += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.comment = null;
	      }
	      state.mode = HCRC;
	      /* falls through */
	    case HCRC:
	      if (state.flags & 0x0200) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.check & 0xffff)) {
	          strm.msg = 'header crc mismatch';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      if (state.head) {
	        state.head.hcrc = ((state.flags >> 9) & 1);
	        state.head.done = true;
	      }
	      strm.adler = state.check = 0;
	      state.mode = TYPE;
	      break;
	    case DICTID:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      strm.adler = state.check = zswap32(hold);
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = DICT;
	      /* falls through */
	    case DICT:
	      if (state.havedict === 0) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        return Z_NEED_DICT;
	      }
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      /* falls through */
	    case TYPE:
	      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case TYPEDO:
	      if (state.last) {
	        //--- BYTEBITS() ---//
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        state.mode = CHECK;
	        break;
	      }
	      //=== NEEDBITS(3); */
	      while (bits < 3) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.last = (hold & 0x01)/*BITS(1)*/;
	      //--- DROPBITS(1) ---//
	      hold >>>= 1;
	      bits -= 1;
	      //---//

	      switch ((hold & 0x03)/*BITS(2)*/) {
	      case 0:                             /* stored block */
	        //Tracev((stderr, "inflate:     stored block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = STORED;
	        break;
	      case 1:                             /* fixed block */
	        fixedtables(state);
	        //Tracev((stderr, "inflate:     fixed codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = LEN_;             /* decode codes */
	        if (flush === Z_TREES) {
	          //--- DROPBITS(2) ---//
	          hold >>>= 2;
	          bits -= 2;
	          //---//
	          break inf_leave;
	        }
	        break;
	      case 2:                             /* dynamic block */
	        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = TABLE;
	        break;
	      case 3:
	        strm.msg = 'invalid block type';
	        state.mode = BAD;
	      }
	      //--- DROPBITS(2) ---//
	      hold >>>= 2;
	      bits -= 2;
	      //---//
	      break;
	    case STORED:
	      //--- BYTEBITS() ---// /* go to byte boundary */
	      hold >>>= bits & 7;
	      bits -= bits & 7;
	      //---//
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	        strm.msg = 'invalid stored block lengths';
	        state.mode = BAD;
	        break;
	      }
	      state.length = hold & 0xffff;
	      //Tracev((stderr, "inflate:       stored length %u\n",
	      //        state.length));
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = COPY_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case COPY_:
	      state.mode = COPY;
	      /* falls through */
	    case COPY:
	      copy = state.length;
	      if (copy) {
	        if (copy > have) { copy = have; }
	        if (copy > left) { copy = left; }
	        if (copy === 0) { break inf_leave; }
	        //--- zmemcpy(put, next, copy); ---
	        utils.arraySet(output, input, next, copy, put);
	        //---//
	        have -= copy;
	        next += copy;
	        left -= copy;
	        put += copy;
	        state.length -= copy;
	        break;
	      }
	      //Tracev((stderr, "inflate:       stored end\n"));
	      state.mode = TYPE;
	      break;
	    case TABLE:
	      //=== NEEDBITS(14); */
	      while (bits < 14) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	      if (state.nlen > 286 || state.ndist > 30) {
	        strm.msg = 'too many length or distance symbols';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracev((stderr, "inflate:       table sizes ok\n"));
	      state.have = 0;
	      state.mode = LENLENS;
	      /* falls through */
	    case LENLENS:
	      while (state.have < state.ncode) {
	        //=== NEEDBITS(3);
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	        //--- DROPBITS(3) ---//
	        hold >>>= 3;
	        bits -= 3;
	        //---//
	      }
	      while (state.have < 19) {
	        state.lens[order[state.have++]] = 0;
	      }
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      //state.next = state.codes;
	      //state.lencode = state.next;
	      // Switch to use dynamic table
	      state.lencode = state.lendyn;
	      state.lenbits = 7;

	      opts = { bits: state.lenbits };
	      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	      state.lenbits = opts.bits;

	      if (ret) {
	        strm.msg = 'invalid code lengths set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, "inflate:       code lengths ok\n"));
	      state.have = 0;
	      state.mode = CODELENS;
	      /* falls through */
	    case CODELENS:
	      while (state.have < state.nlen + state.ndist) {
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_val < 16) {
	          //--- DROPBITS(here.bits) ---//
	          hold >>>= here_bits;
	          bits -= here_bits;
	          //---//
	          state.lens[state.have++] = here_val;
	        }
	        else {
	          if (here_val === 16) {
	            //=== NEEDBITS(here.bits + 2);
	            n = here_bits + 2;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            if (state.have === 0) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            len = state.lens[state.have - 1];
	            copy = 3 + (hold & 0x03);//BITS(2);
	            //--- DROPBITS(2) ---//
	            hold >>>= 2;
	            bits -= 2;
	            //---//
	          }
	          else if (here_val === 17) {
	            //=== NEEDBITS(here.bits + 3);
	            n = here_bits + 3;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 3 + (hold & 0x07);//BITS(3);
	            //--- DROPBITS(3) ---//
	            hold >>>= 3;
	            bits -= 3;
	            //---//
	          }
	          else {
	            //=== NEEDBITS(here.bits + 7);
	            n = here_bits + 7;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 11 + (hold & 0x7f);//BITS(7);
	            //--- DROPBITS(7) ---//
	            hold >>>= 7;
	            bits -= 7;
	            //---//
	          }
	          if (state.have + copy > state.nlen + state.ndist) {
	            strm.msg = 'invalid bit length repeat';
	            state.mode = BAD;
	            break;
	          }
	          while (copy--) {
	            state.lens[state.have++] = len;
	          }
	        }
	      }

	      /* handle error breaks in while */
	      if (state.mode === BAD) { break; }

	      /* check for end-of-block code (better have one) */
	      if (state.lens[256] === 0) {
	        strm.msg = 'invalid code -- missing end-of-block';
	        state.mode = BAD;
	        break;
	      }

	      /* build code tables -- note: do not change the lenbits or distbits
	         values here (9 and 6) without reading the comments in inftrees.h
	         concerning the ENOUGH constants, which depend on those values */
	      state.lenbits = 9;

	      opts = { bits: state.lenbits };
	      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.lenbits = opts.bits;
	      // state.lencode = state.next;

	      if (ret) {
	        strm.msg = 'invalid literal/lengths set';
	        state.mode = BAD;
	        break;
	      }

	      state.distbits = 6;
	      //state.distcode.copy(state.codes);
	      // Switch to use dynamic table
	      state.distcode = state.distdyn;
	      opts = { bits: state.distbits };
	      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.distbits = opts.bits;
	      // state.distcode = state.next;

	      if (ret) {
	        strm.msg = 'invalid distances set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, 'inflate:       codes ok\n'));
	      state.mode = LEN_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case LEN_:
	      state.mode = LEN;
	      /* falls through */
	    case LEN:
	      if (have >= 6 && left >= 258) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        inflate_fast(strm, _out);
	        //--- LOAD() ---
	        put = strm.next_out;
	        output = strm.output;
	        left = strm.avail_out;
	        next = strm.next_in;
	        input = strm.input;
	        have = strm.avail_in;
	        hold = state.hold;
	        bits = state.bits;
	        //---

	        if (state.mode === TYPE) {
	          state.back = -1;
	        }
	        break;
	      }
	      state.back = 0;
	      for (;;) {
	        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if (here_bits <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if (here_op && (here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.lencode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      state.length = here_val;
	      if (here_op === 0) {
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        state.mode = LIT;
	        break;
	      }
	      if (here_op & 32) {
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.back = -1;
	        state.mode = TYPE;
	        break;
	      }
	      if (here_op & 64) {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break;
	      }
	      state.extra = here_op & 15;
	      state.mode = LENEXT;
	      /* falls through */
	    case LENEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	      //Tracevv((stderr, "inflate:         length %u\n", state.length));
	      state.was = state.length;
	      state.mode = DIST;
	      /* falls through */
	    case DIST:
	      for (;;) {
	        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if ((here_bits) <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if ((here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.distcode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      if (here_op & 64) {
	        strm.msg = 'invalid distance code';
	        state.mode = BAD;
	        break;
	      }
	      state.offset = here_val;
	      state.extra = (here_op) & 15;
	      state.mode = DISTEXT;
	      /* falls through */
	    case DISTEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	//#ifdef INFLATE_STRICT
	      if (state.offset > state.dmax) {
	        strm.msg = 'invalid distance too far back';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	      state.mode = MATCH;
	      /* falls through */
	    case MATCH:
	      if (left === 0) { break inf_leave; }
	      copy = _out - left;
	      if (state.offset > copy) {         /* copy from window */
	        copy = state.offset - copy;
	        if (copy > state.whave) {
	          if (state.sane) {
	            strm.msg = 'invalid distance too far back';
	            state.mode = BAD;
	            break;
	          }
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	        }
	        if (copy > state.wnext) {
	          copy -= state.wnext;
	          from = state.wsize - copy;
	        }
	        else {
	          from = state.wnext - copy;
	        }
	        if (copy > state.length) { copy = state.length; }
	        from_source = state.window;
	      }
	      else {                              /* copy from output */
	        from_source = output;
	        from = put - state.offset;
	        copy = state.length;
	      }
	      if (copy > left) { copy = left; }
	      left -= copy;
	      state.length -= copy;
	      do {
	        output[put++] = from_source[from++];
	      } while (--copy);
	      if (state.length === 0) { state.mode = LEN; }
	      break;
	    case LIT:
	      if (left === 0) { break inf_leave; }
	      output[put++] = state.length;
	      left--;
	      state.mode = LEN;
	      break;
	    case CHECK:
	      if (state.wrap) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          // Use '|' insdead of '+' to make sure that result is signed
	          hold |= input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        _out -= left;
	        strm.total_out += _out;
	        state.total += _out;
	        if (_out) {
	          strm.adler = state.check =
	              /*UPDATE(state.check, put - _out, _out);*/
	              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

	        }
	        _out = left;
	        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	          strm.msg = 'incorrect data check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   check matches trailer\n"));
	      }
	      state.mode = LENGTH;
	      /* falls through */
	    case LENGTH:
	      if (state.wrap && state.flags) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.total & 0xffffffff)) {
	          strm.msg = 'incorrect length check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   length matches trailer\n"));
	      }
	      state.mode = DONE;
	      /* falls through */
	    case DONE:
	      ret = Z_STREAM_END;
	      break inf_leave;
	    case BAD:
	      ret = Z_DATA_ERROR;
	      break inf_leave;
	    case MEM:
	      return Z_MEM_ERROR;
	    case SYNC:
	      /* falls through */
	    default:
	      return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}

	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var state;
	  var dictid;
	  var ret;

	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }

	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}

	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/


/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';

	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;


	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;


	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;

	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var utils = __webpack_require__(121);

	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];

	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];

	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];

	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];

	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */

	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.

	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.

	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.

	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;


	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;

	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.

	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.

	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.

	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.

	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;

	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;

	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */

	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }

	  var i = 0;
	  /* process all codes and make table entries */
	  for (;;) {
	    i++;
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};


/***/ },
/* 128 */
/***/ function(module, exports) {

	'use strict';


	module.exports = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,


	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,

	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var EventEmitter = __webpack_require__(14).EventEmitter;
	var url = __webpack_require__(81);
	var util = __webpack_require__(10);

	var assert = __webpack_require__(4);
	var LRU = __webpack_require__(54);
	var Negotiator = __webpack_require__(130);
	var semver = __webpack_require__(112);

	var cors = __webpack_require__(135);
	var errors = __webpack_require__(105);
	var utils = __webpack_require__(3);


	///--- Globals

	var DEF_CT = 'application/octet-stream';

	var BadRequestError = errors.BadRequestError;
	var InternalError = errors.InternalError;
	var InvalidArgumentError = errors.InvalidArgumentError;
	var InvalidVersionError = errors.InvalidVersionError;
	var MethodNotAllowedError = errors.MethodNotAllowedError;
	var ResourceNotFoundError = errors.ResourceNotFoundError;
	var UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;

	var shallowCopy = utils.shallowCopy;


	///--- Helpers


	/**
	 * given a request, try to match it against the regular expression to
	 * get the route params.
	 * i.e., /foo/:param1/:param2
	 * @private
	 * @function matchURL
	 * @param    {String | RegExp} re   a string or regular expression
	 * @param    {Object}          req  the request object
	 * @returns  {Object}
	 */
	function matchURL(re, req) {
	    var i = 0;
	    var result = re.exec(req.path());
	    var params = {};

	    if (!result) {
	        return (false);
	    }

	    // This means the user original specified a regexp match, not a url
	    // string like /:foo/:bar
	    if (!re.restifyParams) {
	        for (i = 1; i < result.length; i++) {
	            params[(i - 1)] = result[i];
	        }

	        return (params);
	    }

	    // This was a static string, like /foo
	    if (re.restifyParams.length === 0) {
	        return (params);
	    }

	    // This was the "normal" case, of /foo/:id
	    re.restifyParams.forEach(function (p) {
	        if (++i < result.length) {
	            params[p] = decodeURIComponent(result[i]);
	        }
	    });

	    return (params);
	}


	/**
	 * called while installing routes. attempts to compile the passed in string
	 * or regexp and register it.
	 * @private
	 * @function compileURL
	 * @param    {Object} options an options object
	 * @returns  {RegExp}
	 */
	function compileURL(options) {
	    if (options.url instanceof RegExp) {
	        return (options.url);
	    }
	    assert.string(options.url, 'url');

	    var params = [];
	    var pattern = '^';
	    var re;
	    var _url = url.parse(options.url).pathname;
	    _url.split('/').forEach(function (frag) {
	        if (frag.length <= 0) {
	            return (false);
	        }

	        pattern += '\\/+';

	        if (frag.charAt(0) === ':') {
	            var label = frag;
	            var index = frag.indexOf('(');
	            var subexp;

	            if (index === -1) {
	                if (options.urlParamPattern) {
	                    subexp = options.urlParamPattern;
	                } else {
	                    subexp = '[^/]*';
	                }
	            } else {
	                label = frag.substring(0, index);
	                subexp = frag.substring(index + 1, frag.length - 1);
	            }
	            pattern += '(' + subexp + ')';
	            params.push(label.slice(1));
	        } else {
	            pattern += frag;
	        }
	        return (true);
	    });

	    if (pattern === '^') {
	        pattern += '\\/';
	    }
	    pattern += '$';

	    re = new RegExp(pattern, options.flags);
	    re.restifyParams = params;

	    return (re);
	}


	///--- API

	/**
	 * Router class handles mapping of http verbs and a regexp path,
	 * to an array of handler functions.
	 * @class
	 * @public
	 * @param  {Object} options an options object
	 */
	function Router(options) {
	    assert.object(options, 'options');
	    assert.object(options.log, 'options.log');

	    EventEmitter.call(this);

	    this.cache = LRU({max: 100});
	    this.contentType = options.contentType || [];

	    if (!Array.isArray(this.contentType)) {
	        this.contentType = [this.contentType];
	    }
	    assert.arrayOfString(this.contentType, 'options.contentType');

	    this.log = options.log;
	    this.mounts = {};
	    this.name = 'RestifyRouter';

	    // A list of methods to routes
	    this.routes = {
	        DELETE: [],
	        GET: [],
	        HEAD: [],
	        OPTIONS: [],
	        PATCH: [],
	        POST: [],
	        PUT: []
	    };

	    // So we can retrun 405 vs 404, we maintain a reverse mapping of URLs
	    // to method
	    this.reverse = {};

	    this.versions = options.versions || options.version || [];

	    if (!Array.isArray(this.versions)) {
	        this.versions = [this.versions];
	    }
	    assert.arrayOfString(this.versions, 'options.versions');

	    this.versions.forEach(function (v) {
	        if (semver.valid(v)) {
	            return (true);
	        }

	        throw new InvalidArgumentError('%s is not a valid semver', v);
	    });
	    this.versions.sort();

	}
	util.inherits(Router, EventEmitter);

	module.exports = Router;

	/**
	 * takes an object of route params and query params, and 'renders' a URL.
	 * @public
	 * @function render
	 * @param    {String} routeName the route name
	 * @param    {Object} params    an object of route params
	 * @param    {Object} query     an object of query params
	 * @returns  {String}
	 */
	Router.prototype.render = function render(routeName, params, query) {
	    function pathItem(match, key) {
	        if (params.hasOwnProperty(key) === false) {
	            throw new Error('Route <' + routeName +
	                            '> is missing parameter <' +
	                            key + '>');
	        }
	        return ('/' + encodeURIComponent(params[key]));
	    }

	    function queryItem(key) {
	        return (encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));
	    }

	    var routeKey = routeName.replace(/\W/g, '').toLowerCase();
	    var route = this.mounts[routeKey];

	    if (!route) {
	        return (null);
	    }

	    var _path = route.spec.path;
	    var _url = _path.replace(/\/:([A-Za-z0-9_]+)(\([^\\]+?\))?/g, pathItem);
	    var items = Object.keys(query || {}).map(queryItem);
	    var queryString = items.length > 0 ? ('?' + items.join('&')) : '';
	    return (_url + queryString);
	};


	/**
	 * adds a route.
	 * @public
	 * @function mount
	 * @param    {Object} options an options object
	 * @returns  {String}         returns the route name if creation is successful.
	 */
	Router.prototype.mount = function mount(options) {
	    assert.object(options, 'options');
	    assert.string(options.method, 'options.method');
	    assert.string(options.name, 'options.name');

	    var exists;
	    var name = options.name;
	    var route;
	    var routes = this.routes[options.method];
	    var self = this;
	    var type = options.contentType || self.contentType;
	    var versions = options.versions || options.version || self.versions;

	    if (type) {
	        if (!Array.isArray(type)) {
	            type = [type];
	        }
	        type.filter(function (t) {
	            return (t);
	        }).sort().join();
	    }

	    if (versions) {
	        if (!Array.isArray(versions)) {
	            versions = [versions];
	        }
	        versions.sort();
	    }

	    exists = routes.some(function (r) {
	        return (r.name === name);
	    });

	    if (exists) {
	        return (false);
	    }

	    route = {
	        name: name,
	        method: options.method,
	        path: compileURL({
	            url: options.path || options.url,
	            flags: options.flags,
	            urlParamPattern: options.urlParamPattern
	        }),
	        spec: options,
	        types: type,
	        versions: versions
	    };
	    routes.push(route);

	    if (!this.reverse[route.path.source]) {
	        this.reverse[route.path.source] = [];
	    }

	    if (this.reverse[route.path.source].indexOf(route.method) === -1) {
	        this.reverse[route.path.source].push(route.method);
	    }

	    this.mounts[route.name] = route;

	    this.emit('mount',
	        route.method,
	        route.path,
	        route.types,
	        route.versions);

	    return (route.name);
	};


	/**
	 * unmounts a route.
	 * @public
	 * @function unmount
	 * @param    {String} name the route name
	 * @returns  {String}      the name of the deleted route.
	 */
	Router.prototype.unmount = function unmount(name) {
	    var route = this.mounts[name];

	    if (!route) {
	        this.log.warn('router.unmount(%s): route does not exist', name);
	        return (false);
	    }

	    var reverse = this.reverse[route.path.source];
	    var routes = this.routes[route.method];
	    this.routes[route.method] = routes.filter(function (r) {
	        return (r.name !== route.name);
	    });

	    this.reverse[route.path.source] = reverse.filter(function (r) {
	        return (r !== route.method);
	    });

	    if (this.reverse[route.path.source].length === 0) {
	        delete this.reverse[route.path.source];
	    }

	    delete this.mounts[name];

	    return (name);
	};


	/**
	 * get a route from the router.
	 * @public
	 * @function get
	 * @param    {String}    name the name of the route to retrieve
	 * @param    {Object}    req  the request object
	 * @param    {Function}  cb   callback function
	 * @returns  {undefined}
	 */
	Router.prototype.get = function get(name, req, cb) {
	    var params;
	    var route = false;
	    var routes = this.routes[req.method] || [];

	    var routeName = name.replace(/\W/g, '').toLowerCase();

	    for (var i = 0; i < routes.length; i++) {
	        if (routes[i].name === routeName) {
	            route = routes[i];

	            try {
	                params = matchURL(route.path, req);
	            } catch (e) {
	                // if we couldn't match the URL, log it out.
	                console.log(e);
	            }
	            break;
	        }
	    }

	    if (route) {
	        cb(null, route, params || {});
	    } else {
	        cb(new InternalError());
	    }
	};


	/**
	 * find a route from inside the router, handles versioned routes.
	 * @public
	 * @function find
	 * @param    {Object}   req      the request object
	 * @param    {Object}   res      the response object
	 * @param    {Function} callback callback function
	 * @returns  {undefined}
	 */
	Router.prototype.find = function find(req, res, callback) {
	    var candidates = [];
	    var ct = req.headers['content-type'] || DEF_CT;
	    var cacheKey = req.method + req.url + req.version() + ct;
	    var cacheVal;
	    var neg;
	    var params;
	    var r;
	    var reverse;
	    var routes = this.routes[req.method] || [];
	    var typed;
	    var versioned;
	    var maxV;

	    if ((cacheVal = this.cache.get(cacheKey))) {
	        res.methods = cacheVal.methods.slice();
	        req._matchedVersion = cacheVal.matchedVersion;
	        callback(null, cacheVal, shallowCopy(cacheVal.params));
	        return;
	    }

	    for (var i = 0; i < routes.length; i++) {
	        try {
	            params = matchURL(routes[i].path, req);
	        } catch (e) {
	            this.log.trace({err: e}, 'error parsing URL');
	            callback(new BadRequestError(e.message));
	            return;
	        }

	        if (params === false) {
	            continue;
	        }

	        reverse = this.reverse[routes[i].path.source];

	        if (routes[i].types.length && req.isUpload()) {
	            candidates.push({
	                p: params,
	                r: routes[i]
	            });
	            typed = true;
	            continue;
	        }

	        // GH-283: we want to find the latest version for a given route,
	        // not the first one.  However, if neither the client nor
	        // server specified any version, we're done, because neither
	        // cared
	        if (routes[i].versions.length === 0 && req.version() === '*') {
	            r = routes[i];
	            break;
	        }

	        if (routes[i].versions.length > 0) {
	            candidates.push({
	                p: params,
	                r: routes[i]
	            });
	            versioned = true;
	        }
	    }

	    if (!r) {
	        // If upload and typed
	        if (typed) {
	            var _t = ct.split(/\s*,\s*/);
	            candidates = candidates.filter(function (c) {
	                neg = new Negotiator({
	                    headers: {
	                        accept: c.r.types.join(', ')
	                    }
	                });
	                var tmp = neg.preferredMediaType(_t);
	                return (tmp && tmp.length);
	            });

	            // Pick the first one in case not versioned
	            if (candidates.length) {
	                r = candidates[0].r;
	                params = candidates[0].p;
	            }
	        }

	        if (versioned) {
	            candidates.forEach(function (c) {
	                var k = c.r.versions;
	                var v = semver.maxSatisfying(k, req.version());

	                if (v) {
	                    if (!r || semver.gt(v, maxV)) {
	                        r = c.r;
	                        params = c.p;
	                        maxV = v;
	                    }
	                }
	            });
	        }
	    }

	    // In order, we check if the route exists, in which case, we're good.
	    // Otherwise we look to see if ver was set to false; that would tell us
	    // we indeed did find a matching route (method+url), but the version
	    // field didn't line up, so we return bad version.  If no route and no
	    // version, we now need to go walk the reverse map and look at whether
	    // we should return 405 or 404.  If it was an OPTIONS request, we need
	    // to handle this having been a preflight request.
	    if (params && r) {
	        cacheVal = {
	            methods: reverse,
	            name: r.name,
	            params: params,
	            spec: r.spec
	        };

	        if (versioned) {
	            req._matchedVersion = maxV;
	            cacheVal.matchedVersion = maxV;
	        }

	        this.cache.set(cacheKey, cacheVal);
	        res.methods = reverse.slice();
	        callback(null, cacheVal, shallowCopy(params));
	        return;
	    }

	    if (typed) {
	        callback(new UnsupportedMediaTypeError(ct));
	        return;
	    }

	    if (versioned) {
	        callback(new InvalidVersionError('%s is not supported by %s %s',
	            req.version() || '?',
	            req.method,
	            req.path()));
	        return;
	    }

	    //Checks if header is in cors.ALLOWED_HEADERS
	    function inAllowedHeaders(header) {
	        header = header.toLowerCase();
	        return (cors.ALLOW_HEADERS.indexOf(header) !== -1);
	    }

	    // This is a very generic preflight handler - it does
	    // not handle requiring authentication, nor does it do
	    // any special checking for extra user headers. The
	    // user will need to defined their own .opts handler to
	    // do that
	    function preflight(methods) {
	        var headers = req.headers['access-control-request-headers'];
	        var method = req.headers['access-control-request-method'];
	        var origin = req.headers.origin;

	        if (req.method !== 'OPTIONS' || !origin || !method ||
	            methods.indexOf(method) === -1) {
	            return (false);
	        }

	        // Last, check request-headers
	        var ok = !headers || headers.split(/\s*,\s*/).every(inAllowedHeaders);

	        if (!ok) {
	            return (false);
	        }

	        // Verify the incoming origin against the whitelist. Pass the origin
	        // through if there is a match.
	        if (cors.matchOrigin(req, cors.origins)) {
	            res.setHeader('Access-Control-Allow-Origin', origin);

	            if (cors.credentials) {
	                res.setHeader('Access-Control-Allow-Credentials', 'true');
	            }
	        } else {
	            res.setHeader('Access-Control-Allow-Origin', '*');
	        }
	        res.setHeader('Access-Control-Allow-Methods',
	            methods.join(', '));
	        res.setHeader('Access-Control-Allow-Headers',
	            cors.ALLOW_HEADERS.join(', '));
	        res.setHeader('Access-Control-Max-Age', 3600);

	        return (true);
	    }

	    // Check for 405 instead of 404
	    var j;
	    var urls = Object.keys(this.reverse);

	    for (j = 0; j < urls.length; j++) {
	        if (matchURL(new RegExp(urls[j]), req)) {
	            res.methods = this.reverse[urls[j]].slice();
	            res.setHeader('Allow', res.methods.join(', '));

	            if (preflight(res.methods)) {
	                callback(null, {name: 'preflight'});
	                return;
	            }
	            var err = new MethodNotAllowedError('%s is not allowed',
	                req.method);
	            callback(err);
	            return;
	        }
	    }

	    // clean up the url in case of potential xss
	    // https://github.com/restify/node-restify/issues/1018
	    var cleanedUrl = url.parse(req.url).pathname;
	    callback(new ResourceNotFoundError(
	        '%s does not exist', cleanedUrl
	    ));
	};


	/**
	 * toString() serialization.
	 * @public
	 * @function toString
	 * @returns  {String}
	 */
	Router.prototype.toString = function toString() {
	    var self = this;
	    var str = this.name + ':\n';

	    Object.keys(this.routes).forEach(function (k) {
	        var routes = self.routes[k].map(function (r) {
	            return (r.name);
	        });

	        str += '\t\t' + k + ': [' + routes.join(', ') + ']\n';
	    });

	    return (str);
	};


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * negotiator
	 * Copyright(c) 2012 Federico Romero
	 * Copyright(c) 2012-2014 Isaac Z. Schlueter
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Cached loaded submodules.
	 * @private
	 */

	var modules = Object.create(null);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Negotiator;
	module.exports.Negotiator = Negotiator;

	/**
	 * Create a Negotiator instance from a request.
	 * @param {object} request
	 * @public
	 */

	function Negotiator(request) {
	  if (!(this instanceof Negotiator)) {
	    return new Negotiator(request);
	  }

	  this.request = request;
	}

	Negotiator.prototype.charset = function charset(available) {
	  var set = this.charsets(available);
	  return set && set[0];
	};

	Negotiator.prototype.charsets = function charsets(available) {
	  var preferredCharsets = loadModule('charset').preferredCharsets;
	  return preferredCharsets(this.request.headers['accept-charset'], available);
	};

	Negotiator.prototype.encoding = function encoding(available) {
	  var set = this.encodings(available);
	  return set && set[0];
	};

	Negotiator.prototype.encodings = function encodings(available) {
	  var preferredEncodings = loadModule('encoding').preferredEncodings;
	  return preferredEncodings(this.request.headers['accept-encoding'], available);
	};

	Negotiator.prototype.language = function language(available) {
	  var set = this.languages(available);
	  return set && set[0];
	};

	Negotiator.prototype.languages = function languages(available) {
	  var preferredLanguages = loadModule('language').preferredLanguages;
	  return preferredLanguages(this.request.headers['accept-language'], available);
	};

	Negotiator.prototype.mediaType = function mediaType(available) {
	  var set = this.mediaTypes(available);
	  return set && set[0];
	};

	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
	  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
	  return preferredMediaTypes(this.request.headers.accept, available);
	};

	// Backwards compatibility
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

	/**
	 * Load the given module.
	 * @private
	 */

	function loadModule(moduleName) {
	  var module = modules[moduleName];

	  if (module !== undefined) {
	    return module;
	  }

	  // This uses a switch for static require analysis
	  switch (moduleName) {
	    case 'charset':
	      module = __webpack_require__(131);
	      break;
	    case 'encoding':
	      module = __webpack_require__(132);
	      break;
	    case 'language':
	      module = __webpack_require__(133);
	      break;
	    case 'mediaType':
	      module = __webpack_require__(134);
	      break;
	    default:
	      throw new Error('Cannot find module \'' + moduleName + '\'');
	  }

	  // Store to prevent invoking require()
	  modules[moduleName] = module;

	  return module;
	}


/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredCharsets;
	module.exports.preferredCharsets = preferredCharsets;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Charset header.
	 * @private
	 */

	function parseAcceptCharset(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var charset = parseCharset(accepts[i].trim(), i);

	    if (charset) {
	      accepts[j++] = charset;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a charset from the Accept-Charset header.
	 * @private
	 */

	function parseCharset(str, i) {
	  var match = simpleCharsetRegExp.exec(str);
	  if (!match) return null;

	  var charset = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';')
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    charset: charset,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a charset.
	 * @private
	 */

	function getCharsetPriority(charset, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(charset, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the charset.
	 * @private
	 */

	function specify(charset, spec, index) {
	  var s = 0;
	  if(spec.charset.toLowerCase() === charset.toLowerCase()){
	    s |= 1;
	  } else if (spec.charset !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	}

	/**
	 * Get the preferred charsets from an Accept-Charset header.
	 * @public
	 */

	function preferredCharsets(accept, provided) {
	  // RFC 2616 sec 14.2: no header = *
	  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all charsets
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullCharset);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getCharsetPriority(type, accepts, index);
	  });

	  // sorted list of accepted charsets
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full charset string.
	 * @private
	 */

	function getFullCharset(spec) {
	  return spec.charset;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 132 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredEncodings;
	module.exports.preferredEncodings = preferredEncodings;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Encoding header.
	 * @private
	 */

	function parseAcceptEncoding(accept) {
	  var accepts = accept.split(',');
	  var hasIdentity = false;
	  var minQuality = 1;

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var encoding = parseEncoding(accepts[i].trim(), i);

	    if (encoding) {
	      accepts[j++] = encoding;
	      hasIdentity = hasIdentity || specify('identity', encoding);
	      minQuality = Math.min(minQuality, encoding.q || 1);
	    }
	  }

	  if (!hasIdentity) {
	    /*
	     * If identity doesn't explicitly appear in the accept-encoding header,
	     * it's added to the list of acceptable encoding with the lowest q
	     */
	    accepts[j++] = {
	      encoding: 'identity',
	      q: minQuality,
	      i: i
	    };
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse an encoding from the Accept-Encoding header.
	 * @private
	 */

	function parseEncoding(str, i) {
	  var match = simpleEncodingRegExp.exec(str);
	  if (!match) return null;

	  var encoding = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';');
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    encoding: encoding,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of an encoding.
	 * @private
	 */

	function getEncodingPriority(encoding, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(encoding, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the encoding.
	 * @private
	 */

	function specify(encoding, spec, index) {
	  var s = 0;
	  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
	    s |= 1;
	  } else if (spec.encoding !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	};

	/**
	 * Get the preferred encodings from an Accept-Encoding header.
	 * @public
	 */

	function preferredEncodings(accept, provided) {
	  var accepts = parseAcceptEncoding(accept || '');

	  if (!provided) {
	    // sorted list of all encodings
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullEncoding);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getEncodingPriority(type, accepts, index);
	  });

	  // sorted list of accepted encodings
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full encoding string.
	 * @private
	 */

	function getFullEncoding(spec) {
	  return spec.encoding;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 133 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredLanguages;
	module.exports.preferredLanguages = preferredLanguages;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Language header.
	 * @private
	 */

	function parseAcceptLanguage(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var langauge = parseLanguage(accepts[i].trim(), i);

	    if (langauge) {
	      accepts[j++] = langauge;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a language from the Accept-Language header.
	 * @private
	 */

	function parseLanguage(str, i) {
	  var match = simpleLanguageRegExp.exec(str);
	  if (!match) return null;

	  var prefix = match[1],
	      suffix = match[2],
	      full = prefix;

	  if (suffix) full += "-" + suffix;

	  var q = 1;
	  if (match[3]) {
	    var params = match[3].split(';')
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].split('=');
	      if (p[0] === 'q') q = parseFloat(p[1]);
	    }
	  }

	  return {
	    prefix: prefix,
	    suffix: suffix,
	    q: q,
	    i: i,
	    full: full
	  };
	}

	/**
	 * Get the priority of a language.
	 * @private
	 */

	function getLanguagePriority(language, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(language, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the language.
	 * @private
	 */

	function specify(language, spec, index) {
	  var p = parseLanguage(language)
	  if (!p) return null;
	  var s = 0;
	  if(spec.full.toLowerCase() === p.full.toLowerCase()){
	    s |= 4;
	  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
	    s |= 2;
	  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
	    s |= 1;
	  } else if (spec.full !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	};

	/**
	 * Get the preferred languages from an Accept-Language header.
	 * @public
	 */

	function preferredLanguages(accept, provided) {
	  // RFC 2616 sec 14.4: no header = *
	  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all languages
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullLanguage);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getLanguagePriority(type, accepts, index);
	  });

	  // sorted list of accepted languages
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full language string.
	 * @private
	 */

	function getFullLanguage(spec) {
	  return spec.full;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredMediaTypes;
	module.exports.preferredMediaTypes = preferredMediaTypes;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept header.
	 * @private
	 */

	function parseAccept(accept) {
	  var accepts = splitMediaTypes(accept);

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var mediaType = parseMediaType(accepts[i].trim(), i);

	    if (mediaType) {
	      accepts[j++] = mediaType;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a media type from the Accept header.
	 * @private
	 */

	function parseMediaType(str, i) {
	  var match = simpleMediaTypeRegExp.exec(str);
	  if (!match) return null;

	  var params = Object.create(null);
	  var q = 1;
	  var subtype = match[2];
	  var type = match[1];

	  if (match[3]) {
	    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

	    for (var j = 0; j < kvps.length; j++) {
	      var pair = kvps[j];
	      var key = pair[0].toLowerCase();
	      var val = pair[1];

	      // get the value, unwrapping quotes
	      var value = val && val[0] === '"' && val[val.length - 1] === '"'
	        ? val.substr(1, val.length - 2)
	        : val;

	      if (key === 'q') {
	        q = parseFloat(value);
	        break;
	      }

	      // store parameter
	      params[key] = value;
	    }
	  }

	  return {
	    type: type,
	    subtype: subtype,
	    params: params,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a media type.
	 * @private
	 */

	function getMediaTypePriority(type, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(type, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the media type.
	 * @private
	 */

	function specify(type, spec, index) {
	  var p = parseMediaType(type);
	  var s = 0;

	  if (!p) {
	    return null;
	  }

	  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
	    s |= 4
	  } else if(spec.type != '*') {
	    return null;
	  }

	  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
	    s |= 2
	  } else if(spec.subtype != '*') {
	    return null;
	  }

	  var keys = Object.keys(spec.params);
	  if (keys.length > 0) {
	    if (keys.every(function (k) {
	      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
	    })) {
	      s |= 1
	    } else {
	      return null
	    }
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s,
	  }
	}

	/**
	 * Get the preferred media types from an Accept header.
	 * @public
	 */

	function preferredMediaTypes(accept, provided) {
	  // RFC 2616 sec 14.2: no header = */*
	  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

	  if (!provided) {
	    // sorted list of all types
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullType);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getMediaTypePriority(type, accepts, index);
	  });

	  // sorted list of accepted types
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full type string.
	 * @private
	 */

	function getFullType(spec) {
	  return spec.type + '/' + spec.subtype;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}

	/**
	 * Count the number of quotes in a string.
	 * @private
	 */

	function quoteCount(string) {
	  var count = 0;
	  var index = 0;

	  while ((index = string.indexOf('"', index)) !== -1) {
	    count++;
	    index++;
	  }

	  return count;
	}

	/**
	 * Split a key value pair.
	 * @private
	 */

	function splitKeyValuePair(str) {
	  var index = str.indexOf('=');
	  var key;
	  var val;

	  if (index === -1) {
	    key = str;
	  } else {
	    key = str.substr(0, index);
	    val = str.substr(index + 1);
	  }

	  return [key, val];
	}

	/**
	 * Split an Accept header into media types.
	 * @private
	 */

	function splitMediaTypes(accept) {
	  var accepts = accept.split(',');

	  for (var i = 1, j = 0; i < accepts.length; i++) {
	    if (quoteCount(accepts[j]) % 2 == 0) {
	      accepts[++j] = accepts[i];
	    } else {
	      accepts[j] += ',' + accepts[i];
	    }
	  }

	  // trim accepts
	  accepts.length = j + 1;

	  return accepts;
	}

	/**
	 * Split a string of parameters.
	 * @private
	 */

	function splitParameters(str) {
	  var parameters = str.split(';');

	  for (var i = 1, j = 0; i < parameters.length; i++) {
	    if (quoteCount(parameters[j]) % 2 == 0) {
	      parameters[++j] = parameters[i];
	    } else {
	      parameters[j] += ';' + parameters[i];
	    }
	  }

	  // trim parameters
	  parameters.length = j + 1;

	  for (var i = 0; i < parameters.length; i++) {
	    parameters[i] = parameters[i].trim();
	  }

	  return parameters;
	}


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2013 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);


	///--- Globals

	var ALLOW_HEADERS = [
	    'accept',
	    'accept-version',
	    'content-type',
	    'request-id',
	    'origin',
	    'x-api-version',
	    'x-request-id'
	];

	var EXPOSE_HEADERS = [
	    'api-version',
	    'content-length',
	    'content-md5',
	    'content-type',
	    'date',
	    'request-id',
	    'response-time'
	];

	// Normal
	var AC_ALLOW_ORIGIN = 'Access-Control-Allow-Origin';
	var AC_ALLOW_CREDS = 'Access-Control-Allow-Credentials';
	var AC_EXPOSE_HEADERS = 'Access-Control-Expose-Headers';


	///--- Internal Functions

	function matchOrigin(req, origins) {
	    var origin = req.headers.origin;

	    function belongs(o) {
	        if (origin === o || o === '*') {
	            origin = o;
	            return (true);
	        }

	        return (false);
	    }

	    return ((origin && origins.some(belongs)) ? origin : false);
	}


	///--- API

	/**
	 * From http://www.w3.org/TR/cors/#resource-processing-model
	 *
	 * If "simple" request (paraphrased):
	 *
	 * 1. If the Origin header is not set, or if the value of Origin is not a
	 *    case-sensitive match to any values listed in `opts.origins`, do not
	 *    send any CORS headers
	 *
	 * 2. If the resource supports credentials add a single
	 *    'Access-Control-Allow-Credentials' header with the value as "true", and
	 *    ensure 'AC-Allow-Origin' is not '*', but is the request header value,
	 *    otherwise add a single Access-Control-Allow-Origin header, with either the
	 *    value of the Origin header or the string "*" as value
	 *
	 * 3. Add Access-Control-Expose-Headers as appropriate
	 *
	 * Pre-flight requests are handled by the router internally
	 *
	 * @public
	 * @function cors
	 * @param    {Object}   opts an options object
	 * @returns  {Function}
	 */
	function cors(opts) {
	    assert.optionalObject(opts, 'options');
	    opts = opts || {};
	    assert.optionalArrayOfString(opts.origins, 'options.origins');
	    assert.optionalBool(opts.credentials, 'options.credentials');
	    assert.optionalArrayOfString(opts.headers, 'options.headers');

	    cors.credentials = opts.credentials;
	    cors.origins = opts.origins || ['*'];

	    var headers = (opts.headers || []).slice(0);
	    var origins = opts.origins || ['*'];

	    EXPOSE_HEADERS.forEach(function (h) {
	        if (headers.indexOf(h) === -1) {
	            headers.push(h);
	        }
	    });

	    // Handler for simple requests
	    function restifyCORSSimple(req, res, next) {
	        var origin;

	        if (!(origin = matchOrigin(req, origins))) {
	            next();
	            return;
	        }

	        function corsOnHeader() {
	            origin = req.headers.origin;

	            if (opts.credentials) {
	                res.setHeader(AC_ALLOW_ORIGIN, origin);
	                res.setHeader(AC_ALLOW_CREDS, 'true');
	            } else {
	                res.setHeader(AC_ALLOW_ORIGIN, origin);
	            }

	            res.setHeader(AC_EXPOSE_HEADERS, headers.join(', '));
	        }

	        res.once('header', corsOnHeader);
	        next();
	    }

	    return (restifyCORSSimple);
	}


	///--- Exports

	module.exports = cors;

	// All of these are needed for the pre-flight code over in lib/router.js
	cors.ALLOW_HEADERS = ALLOW_HEADERS;
	cors.EXPOSE_HEADERS = EXPOSE_HEADERS;
	cors.credentials = false;
	cors.origins = [];
	cors.matchOrigin = matchOrigin;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var domain = __webpack_require__(137);
	var EventEmitter = __webpack_require__(14).EventEmitter;
	var http = __webpack_require__(76);
	var https = __webpack_require__(87);
	var util = __webpack_require__(10);

	var assert = __webpack_require__(4);
	var mime = __webpack_require__(100);
	var once = __webpack_require__(52);
	var spdy = __webpack_require__(138);
	var uuid = __webpack_require__(58);

	var dtrace = __webpack_require__(103);
	var errors = __webpack_require__(105);
	var formatters = __webpack_require__(200);
	var shallowCopy = __webpack_require__(3).shallowCopy;
	var upgrade = __webpack_require__(205);

	var semver = __webpack_require__(112);
	var maxSatisfying = semver.maxSatisfying;

	// Ensure these are loaded
	__webpack_require__(206);
	__webpack_require__(207);


	///--- Globals

	var sprintf = util.format;

	var ResourceNotFoundError = errors.ResourceNotFoundError;

	var PROXY_EVENTS = [
	    'clientError',
	    'close',
	    'connection',
	    'error',
	    'listening',
	    'secureConnection'
	];


	///--- Helpers

	/**
	 * helper function to help verify and flatten an array of arrays.
	 * takes an arguments object and an index frmo which to slice, then
	 * merges that into a single array.
	 * @private
	 * @function argumentsToChain
	 * @throws   {TypeError}
	 * @param    {Object} args  pass through of funcs from server.[method]
	 * @param    {Number} start index of args at which to start working with
	 * @returns  {Array}
	 */
	function argumentsToChain(args, start) {
	    assert.ok(args);

	    args = Array.prototype.slice.call(args, start);

	    if (args.length < 0) {
	        throw new TypeError('handler (function) required');
	    }

	    var chain = [];

	    function process(handlers) {
	        for (var i = 0; i < handlers.length; i++) {
	            if (Array.isArray(handlers[i])) {
	                process(handlers[i], 0);
	            } else {
	                assert.func(handlers[i], 'handler');
	                chain.push(handlers[i]);
	            }
	        }

	        return (chain);
	    }

	    return (process(args));
	}

	/**
	 * merge optional formatters with the default formatters to create a single
	 * formatters object. the passed in optional formatters object looks like:
	 * formatters: {
	 *   'application/foo': function formatFoo(req, res, body) {...}
	 * }
	 * @private
	 * @function mergeFormatters
	 * @param    {Object} fmt user specified formatters object
	 * @returns  {Object}
	 */

	function mergeFormatters(fmt) {
	    var arr = [];
	    var obj = {};

	    function addFormatter(src, k) {
	        assert.func(src[k], 'formatter');

	        var q = 1.0; // RFC 2616 sec14 - The default value is q=1
	        var t = k;

	        if (k.indexOf(';') !== -1) {
	            var tmp = k.split(/\s*;\s*/);
	            t = tmp[0];

	            if (tmp[1].indexOf('q=') !== -1) {
	                q = parseFloat(tmp[1].split('=')[1]);
	            }
	        }

	        if (k.indexOf('/') === -1) {
	            k = mime.lookup(k);
	        }

	        obj[t] = src[k];
	        arr.push({
	            q: q,
	            t: t
	        });
	    }

	    Object.keys(formatters).forEach(addFormatter.bind(this, formatters));
	    Object.keys(fmt || {}).forEach(addFormatter.bind(this, fmt || {}));

	    arr = arr.sort(function (a, b) {
	        return (b.q - a.q);
	    }).map(function (a) {
	            return (a.t);
	        });

	    return ({
	        formatters: obj,
	        acceptable: arr
	    });
	}


	/**
	 * attaches ifError function attached to the `next` function in handler chain.
	 * uses a closure to maintain ref to next.
	 * @private
	 * @function ifError
	 * @param    {Function} n the next function
	 * @returns  {Function}
	 */
	function ifError(n) {
	    /**
	     * @throws   will throw if an error is passed in.
	     * @private
	     * @function _ifError
	     * @param    {Object} err an error object
	     * @returns  {undefined}
	     */
	    function _ifError(err) {
	        if (err) {
	            err._restify_next = n;
	            throw err;
	        }
	    }

	    return (_ifError);
	}


	/**
	 * when an error occurrs, this is used to emit an error to consumers
	 * via EventEmitter.
	 * @private
	 * @function emitRouteError
	 * @param    {Object} server the server object
	 * @param    {Object} req    the request object
	 * @param    {Object} res    the response object
	 * @param    {Object} err    an error object
	 * @returns  {undefined}
	 */
	function emitRouteError(server, req, res, err) {
	    var name;

	    if (err.name === 'ResourceNotFoundError') {
	        name = 'NotFound';
	    } else if (err.name === 'InvalidVersionError') {
	        name = 'VersionNotAllowed';
	    } else {
	        name = err.name.replace(/Error$/, '');
	    }

	    req.log.trace({name: name, err: err}, 'entering emitRouteError');

	    if (server.listeners(name).length > 0) {
	        server.emit(name, req, res, err, once(function () {
	            server.emit('after', req, res, null);
	        }));
	    } else {
	        res.send(err);
	        server.emit('after', req, res, null);
	    }
	}


	/**
	 * returns true if an error generated is for an options request.
	 * @private
	 * @function optionsError
	 * @param    {Object}     err an error object
	 * @param    {Object}     req the request object
	 * @param    {Object}     res the response object
	 * @returns  {Boolean}
	 */
	function optionsError(err, req, res) {
	    var code = err.statusCode;
	    var ok = false;

	    if (code === 404 && req.method === 'OPTIONS' && req.url === '*') {
	        res.send(200);
	        ok = true;
	    }

	    return (ok);
	}


	///--- API

	/**
	 * Creates a new Server.
	 * @public
	 * @class
	 * @param {Object} options an options object
	 */
	function Server(options) {
	    assert.object(options, 'options');
	    assert.object(options.log, 'options.log');
	    assert.object(options.router, 'options.router');

	    var self = this;

	    EventEmitter.call(this);

	    this.before = [];
	    this.chain = [];
	    this.log = options.log;
	    this.name = options.name || 'restify';
	    this.router = options.router;
	    this.routes = {};
	    this.secure = false;
	    this.versions = options.versions || options.version || [];
	    this.socketio = options.socketio || false;

	    var fmt = mergeFormatters(options.formatters);
	    this.acceptable = fmt.acceptable;
	    this.formatters = fmt.formatters;

	    if (options.spdy) {
	        this.spdy = true;
	        this.server = spdy.createServer(options.spdy);
	    } else if ((options.cert || options.certificate) && options.key) {
	        this.ca = options.ca;
	        this.certificate = options.certificate || options.cert;
	        this.key = options.key;
	        this.passphrase = options.passphrase || null;
	        this.secure = true;

	        this.server = https.createServer({
	            ca: self.ca,
	            cert: self.certificate,
	            key: self.key,
	            passphrase: self.passphrase,
	            rejectUnauthorized: options.rejectUnauthorized,
	            requestCert: options.requestCert,
	            ciphers: options.ciphers
	        });
	    } else if (options.httpsServerOptions) {
	        this.server = https.createServer(options.httpsServerOptions);
	    } else {
	        this.server = http.createServer();
	    }

	    this.router.on('mount', this.emit.bind(this, 'mount'));

	    if (!options.handleUpgrades && PROXY_EVENTS.indexOf('upgrade') === -1) {
	        PROXY_EVENTS.push('upgrade');
	    }
	    PROXY_EVENTS.forEach(function (e) {
	        self.server.on(e, self.emit.bind(self, e));
	    });

	    // Now the things we can't blindly proxy
	    this.server.on('checkContinue', function onCheckContinue(req, res) {
	        if (self.listeners('checkContinue').length > 0) {
	            self.emit('checkContinue', req, res);
	            return;
	        }

	        if (!options.noWriteContinue) {
	            res.writeContinue();
	        }

	        self._setupRequest(req, res);
	        self._handle(req, res, true);
	    });

	    if (options.handleUpgrades) {
	        this.server.on('upgrade', function onUpgrade(req, socket, head) {
	            req._upgradeRequest = true;
	            var res = upgrade.createResponse(req, socket, head);
	            self._setupRequest(req, res);
	            self._handle(req, res);
	        });
	    }

	    this.server.on('request', function onRequest(req, res) {
	        self.emit('request', req, res);

	        if (options.socketio && (/^\/socket\.io.*/).test(req.url)) {
	            return;
	        }

	        self._setupRequest(req, res);
	        self._handle(req, res);
	    });

	    this.__defineGetter__('maxHeadersCount', function () {
	        return (self.server.maxHeadersCount);
	    });

	    this.__defineSetter__('maxHeadersCount', function (c) {
	        self.server.maxHeadersCount = c;
	        return (c);
	    });

	    this.__defineGetter__('url', function () {
	        if (self.socketPath) {
	            return ('http://' + self.socketPath);
	        }

	        var addr = self.address();
	        var str = '';

	        if (self.spdy) {
	            str += 'spdy://';
	        } else if (self.secure) {
	            str += 'https://';
	        } else {
	            str += 'http://';
	        }

	        if (addr) {
	            str += addr.family === 'IPv6' ?
	                '[' + addr.address + ']' : addr.address;
	            str += ':';
	            str += addr.port;
	        } else {
	            str += '169.254.0.1:0000';
	        }

	        return (str);
	    });
	}
	util.inherits(Server, EventEmitter);

	module.exports = Server;


	/**
	 * Returns the server address. Wraps node's address().
	 * @public
	 * @function address
	 * @returns  {String}
	 */
	Server.prototype.address = function address() {
	    return (this.server.address());
	};


	/**
	 * Gets the server up and listening. Wraps node's listen().
	 *
	 * You can call like:
	 *  server.listen(80)
	 *  server.listen(80, '127.0.0.1')
	 *  server.listen('/tmp/server.sock')
	 *
	 * @public
	 * @function listen
	 * @throws   {TypeError}
	 * @param    {Function}  callback optionally get notified when listening.
	 * @returns  {undefined}
	 */
	Server.prototype.listen = function listen() {
	    var args = Array.prototype.slice.call(arguments);
	    return (this.server.listen.apply(this.server, args));
	};


	/**
	 * Shuts down this server, and invokes callback (optionally) when done.
	 * Wraps node's close().
	 * @public
	 * @function close
	 * @param    {Function}  callback optional callback to invoke when done.
	 * @returns  {undefined}
	 */
	Server.prototype.close = function close(callback) {
	    if (callback) {
	        assert.func(callback, 'callback');
	    }

	    this.server.once('close', function onClose() {
	        return (callback ? callback() : false);
	    });

	    return (this.server.close());
	};


	// Register all the routing methods
	/**
	 * Mounts a chain on the given path against this HTTP verb
	 *
	 * @public
	 * @function del, get, head, opts, post, put, patch
	 * @param   {String | Object} opts if string, the URL to handle.
	 *                                 if options, the URL to handle, at minimum.
	 * @returns {Route}                the newly created route.
	 */
	[
	    'del',
	    'get',
	    'head',
	    'opts',
	    'post',
	    'put',
	    'patch'
	].forEach(function (method) {
	        Server.prototype[method] = function (opts) {
	            if (opts instanceof RegExp || typeof (opts) === 'string') {
	                opts = {
	                    path: opts
	                };
	            } else if (typeof (opts) === 'object') {
	                opts = shallowCopy(opts);
	            } else {
	                throw new TypeError('path (string) required');
	            }

	            if (arguments.length < 2) {
	                throw new TypeError('handler (function) required');
	            }

	            var chain = [];
	            var route;
	            var self = this;

	            function addHandler(h) {
	                assert.func(h, 'handler');

	                chain.push(h);
	            }

	            if (method === 'del') {
	                method = 'DELETE';
	            }

	            if (method === 'opts') {
	                method = 'OPTIONS';
	            }
	            opts.method = method.toUpperCase();
	            opts.versions = opts.versions || opts.version || self.versions;

	            if (!Array.isArray(opts.versions)) {
	                opts.versions = [opts.versions];
	            }

	            if (!opts.name) {
	                opts.name = method + '-' + (opts.path || opts.url);

	                if (opts.versions.length > 0) {
	                    opts.name += '-' + opts.versions.join('--');
	                }

	                opts.name = opts.name.replace(/\W/g, '').toLowerCase();

	                if (this.router.mounts[opts.name]) { // GH-401
	                    opts.name += uuid.v4().substr(0, 7);
	                }
	            } else {
	                opts.name = opts.name.replace(/\W/g, '').toLowerCase();
	            }


	            if (!(route = this.router.mount(opts))) {
	                return (false);
	            }

	            this.chain.forEach(addHandler);
	            argumentsToChain(arguments, 1).forEach(addHandler);
	            this.routes[route] = chain;

	            return (route);
	        };
	    });


	/**
	 * Minimal port of the functionality offered by Express.js Route Param
	 * Pre-conditions
	 * @link http://expressjs.com/guide.html#route-param%20pre-conditions
	 *
	 * This basically piggy-backs on the `server.use` method. It attaches a
	 * new middleware function that only fires if the specified parameter exists
	 * in req.params
	 *
	 * Exposes an API:
	 *   server.param("user", function (req, res, next) {
	 *     // load the user's information here, always making sure to call next()
	 *   });
	 *
	 * @public
	 * @function param
	 * @param    {String}   name The name of the URL param to respond to
	 * @param    {Function} fn   The middleware function to execute
	 * @returns  {Object}        returns self
	 */
	Server.prototype.param = function param(name, fn) {
	    this.use(function _param(req, res, next) {
	        if (req.params && req.params[name]) {
	            fn.call(this, req, res, next, req.params[name], name);
	        } else {
	            next();
	        }
	    });

	    return (this);
	};


	/**
	 * Piggy-backs on the `server.use` method. It attaches a new middleware
	 * function that only fires if the specified version matchtes the request.
	 *
	 * Note that if the client does not request a specific version, the middleware
	 * function always fires. If you don't want this set a default version with a
	 * pre handler on requests where the client omits one.
	 *
	 * Exposes an API:
	 *   server.versionedUse("version", function (req, res, next, ver) {
	 *     // do stuff that only applies to routes of this API version
	 *   });
	 *
	 * @public
	 * @function versionedUse
	 * @param    {String|Array} versions the version(s) the URL to respond to
	 * @param    {Function}     fn       the middleware function to execute, the
	 *                                   fourth parameter will be the selected
	 *                                   version
	 * @returns  {undefined}
	 */
	Server.prototype.versionedUse = function versionedUse(versions, fn) {
	    if (!Array.isArray(versions)) {
	        versions = [versions];
	    }
	    assert.arrayOfString(versions, 'versions');

	    versions.forEach(function (v) {
	        if (!semver.valid(v)) {
	            throw new TypeError('%s is not a valid semver', v);
	        }
	    });

	    this.use(function _versionedUse(req, res, next) {
	        var ver;

	        if (req.version() === '*' ||
	            (ver = maxSatisfying(versions,
	                req.version()) || false)) {
	            fn.call(this, req, res, next, ver);
	        } else {
	            next();
	        }
	    });

	    return (this);
	};


	/**
	 * Removes a route from the server.
	 * You pass in the route 'blob' you got from a mount call.
	 * @public
	 * @function rm
	 * @throws   {TypeError} on bad input.
	 * @param    {String}    route the route name.
	 * @returns  {Boolean}         true if route was removed, false if not.
	 */
	Server.prototype.rm = function rm(route) {
	    var r = this.router.unmount(route);

	    if (r && this.routes[r]) {
	        delete this.routes[r];
	    }

	    return (r);
	};


	/**
	 * Installs a list of handlers to run _before_ the "normal" handlers of all
	 * routes.
	 *
	 * You can pass in any combination of functions or array of functions.
	 * @public
	 * @function use
	 * @returns {Object} returns self
	 */
	Server.prototype.use = function use() {
	    var self = this;

	    (argumentsToChain(arguments) || []).forEach(function (h) {
	        self.chain.push(h);
	    });

	    return (this);
	};


	/**
	 * Gives you hooks to run _before_ any routes are located.  This gives you
	 * a chance to intercept the request and change headers, etc., that routing
	 * depends on.  Note that req.params will _not_ be set yet.
	 * @public
	 * @function pre
	 * @returns {Object} returns self
	 */
	Server.prototype.pre = function pre() {
	    var self = this;

	    argumentsToChain(arguments).forEach(function (h) {
	        self.before.push(h);
	    });

	    return (this);
	};


	/**
	 * toString() the server for easy reading/output.
	 * @public
	 * @function toString
	 * @returns  {String}
	 */
	Server.prototype.toString = function toString() {
	    var LINE_FMT = '\t%s: %s\n';
	    var SUB_LINE_FMT = '\t\t%s: %s\n';
	    var self = this;
	    var str = '';

	    function handlersToString(arr) {
	        var s = '[' + arr.map(function (b) {
	            return (b.name || 'function');
	        }).join(', ') + ']';

	        return (s);
	    }

	    str += sprintf(LINE_FMT, 'Accepts', this.acceptable.join(', '));
	    str += sprintf(LINE_FMT, 'Name', this.name);
	    str += sprintf(LINE_FMT, 'Pre', handlersToString(this.before));
	    str += sprintf(LINE_FMT, 'Router', this.router.toString());
	    str += sprintf(LINE_FMT, 'Routes', '');
	    Object.keys(this.routes).forEach(function (k) {
	        var handlers = handlersToString(self.routes[k]);
	        str += sprintf(SUB_LINE_FMT, k, handlers);
	    });
	    str += sprintf(LINE_FMT, 'Secure', this.secure);
	    str += sprintf(LINE_FMT, 'Url', this.url);
	    str += sprintf(LINE_FMT, 'Version', Array.isArray(this.versions) ?
	                   this.versions.join() :
	                   this.versions);

	    return (str);
	};


	///--- Private methods

	/**
	 * upon receivng a request, route the request, then run the chain of handlers.
	 * @private
	 * @function _handle
	 * @param    {Object} req the request object
	 * @param    {Object} res the response object
	 * @returns  {undefined}
	 */
	Server.prototype._handle = function _handle(req, res) {
	    var self = this;

	    function routeAndRun() {
	        self._route(req, res, function (route, context) {
	            req.context = req.params = context;
	            req.route = route.spec;

	            var r = route ? route.name : null;
	            var chain = self.routes[r];

	            self._run(req, res, route, chain, function done(e) {
	                self.emit('after', req, res, route, e);
	            });
	        });
	    }

	    if (this.before.length > 0) {
	        this._run(req, res, null, this.before, function (err) {
	            if (!err) {
	                routeAndRun();
	            }
	        });
	    } else {
	        routeAndRun();
	    }
	};


	/**
	 * look into the router, find the route object that should match this request.
	 * @private
	 * @function _route
	 * @param    {Object}    req    the request object
	 * @param    {Object}    res    the response object
	 * @param    {String}    [name] name of the route
	 * @param    {Function}  cb     callback function
	 * @returns  {undefined}
	 */
	Server.prototype._route = function _route(req, res, name, cb) {
	    var self = this;

	    if (typeof (name) === 'function') {
	        cb = name;
	        name = null;

	        this.router.find(req, res, function onRoute(err, route, ctx) {
	            var r = route ? route.name : null;

	            if (err) {
	                if (optionsError(err, req, res)) {
	                    self.emit('after', req, res, err);
	                } else {
	                    emitRouteError(self, req, res, err);
	                }
	            } else if (r === 'preflight') {
	                res.writeHead(200);
	                res.end();
	                self.emit('after', req, res, null);
	            } else if (!r || !self.routes[r]) {
	                err = new ResourceNotFoundError(req.path());
	                emitRouteError(self, res, res, err);
	            } else {
	                cb(route, ctx);
	            }
	        });
	    } else {
	        this.router.get(name, req, function (err, route, ctx) {
	            if (err) {
	                emitRouteError(self, req, res, err);
	            } else {
	                cb(route, ctx);
	            }
	        });
	    }
	};


	/*
	 * The goofy checks in next() are to make sure we fire the DTrace
	 * probes after an error might have been sent, as in a handler
	 * return next(new Error) is basically shorthand for sending an
	 * error via res.send(), so we do that before firing the dtrace
	 * probe (namely so the status codes get updated in the
	 * response).
	 *
	 * Callers can stop the chain from proceding if they do
	 * return next(false); This is useful for non-errors, but where
	 * a response was sent and you don't want the chain to keep
	 * going.
	 *
	 * @private
	 * @function _run
	 * @param    {Object}    req   the request object
	 * @param    {Object}    res   the response object
	 * @param    {Object}    route the route object
	 * @param    {Array}     chain array of handler functions
	 * @param    {Function}  cb    callback function
	 * @returns  {undefined}
	 */
	Server.prototype._run = function _run(req, res, route, chain, cb) {
	    var d;
	    var i = -1;
	    var id = dtrace.nextId();
	    req._dtraceId = id;

	    if (!req._anonFuncCount) {
	        // Counter used to keep track of anonymous functions. Used when a
	        // handler function is anonymous. This ensures we're using a
	        // monotonically increasing int for anonymous handlers through out the
	        // the lifetime of this request
	        req._anonFuncCount = 0;
	    }
	    var log = this.log;
	    var self = this;
	    var handlerName = null;
	    var errName;
	    var emittedError = false;

	    if (cb) {
	        cb = once(cb);
	    }

	    function next(arg) {
	        var done = false;

	        if (arg) {
	            if (arg instanceof Error) {
	                errName = arg.name.replace(/Error$/, '');
	                log.trace({err: arg, errName: errName}, 'next(err=%s)',
	                    (arg.name || 'Error'));

	                if (self.listeners(errName).length > 0) {
	                    self.emit(errName, req, res, arg, once(function () {
	                        res.send(arg);
	                        return (cb ? cb(arg) : true);
	                    }));
	                    emittedError = true;
	                } else {
	                    res.send(arg);
	                }
	                done = true;
	            } else if (typeof (arg) === 'string') { // GH-193, allow redirect
	                if (req._rstfy_chained_route) {
	                    var _e = new errors.InternalError();
	                    log.error({
	                        err: _e
	                    }, 'Multiple next("chain") calls not ' +
	                        'supported');
	                    res.send(_e);
	                    return (false);
	                }

	                // Stop running the rest of this route since we're redirecting
	                return self._route(req, res, arg, function (r, ctx) {
	                    req.context = req.params = ctx;
	                    req.route = r.spec;

	                    var _c = chain.slice(0, i + 1);

	                    function _uniq(fn) {
	                        return (_c.indexOf(fn) === -1);
	                    }

	                    var _routes = self.routes[r.name] || [];
	                    var _chain = _routes.filter(_uniq);

	                    req._rstfy_chained_route = true;

	                    // Need to fire DTrace done for previous handler here too.
	                    if ((i + 1) > 0 && chain[i] && !chain[i]._skip) {
	                        req.endHandlerTimer(handlerName);
	                    }
	                    self._run(req, res, r, _chain, cb);
	                });
	            }
	        }

	        if (arg === false) {
	            done = true;
	        }

	        // Fire DTrace done for the previous handler.
	        if ((i + 1) > 0 && chain[i] && !chain[i]._skip) {
	            req.endHandlerTimer(handlerName);
	        }

	        // Run the next handler up
	        if (!done && chain[++i]) {
	            if (chain[i]._skip) {
	                return (next());
	            }

	            if (log.trace()) {
	                log.trace('running %s', chain[i].name || '?');
	            }

	            req._currentRoute = (route !== null ? route.name : 'pre');
	            handlerName = (chain[i].name ||
	                           ('handler-' + req._anonFuncCount++));
	            req._currentHandler = handlerName;
	            req.startHandlerTimer(handlerName);

	            var n = once(next);
	            n.ifError = ifError(n);
	            return (chain[i].call(self, req, res, n));
	        }

	        dtrace._rstfy_probes['route-done'].fire(function () {
	            return ([
	                self.name,
	                route !== null ? route.name : 'pre',
	                id,
	                res.statusCode || 200,
	                res.headers()
	            ]);
	        });

	        if (route === null) {
	            self.emit('preDone', req, res);
	        } else {
	            self.emit('done', req, res, route);
	        }

	        // Don't return cb here if we emit an error since we will cb after the
	        // handler fires.
	        if (!emittedError) {
	            return (cb ? cb(arg) : true);
	        } else {
	            return (true);
	        }
	    }

	    var n1 = once(next);
	    n1.ifError = ifError(n1);

	    dtrace._rstfy_probes['route-start'].fire(function () {
	        return ([
	            self.name,
	            route !== null ? route.name : 'pre',
	            id,
	            req.method,
	            req.href(),
	            req.headers
	        ]);
	    });

	    d = domain.create();
	    d.add(req);
	    d.add(res);
	    d.on('error', function onError(err) {
	        if (err._restify_next) {
	            err._restify_next(err);
	        } else {
	            log.trace({err: err}, 'uncaughtException');
	            self.emit('uncaughtException', req, res, route, err);
	        }
	    });
	    d.run(n1);
	};


	/**
	 * set up the request by before routing and executing handler chain.
	 * @private
	 * @function _setupRequest
	 * @param    {Object}    req the request object
	 * @param    {Object}    res the response object
	 * @returns  {undefined}
	 */
	Server.prototype._setupRequest = function _setupRequest(req, res) {
	    req.log = res.log = this.log;
	    req._time = res._time = Date.now();
	    req.serverName = this.name;

	    res.acceptable = this.acceptable;
	    res.formatters = this.formatters;
	    res.req = req;
	    res.serverName = this.name;
	    res.version = this.router.versions[this.router.versions.length - 1];
	};


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	// This file should be ES5 compatible
	/* eslint prefer-spread:0, no-var:0, prefer-reflect:0, no-magic-numbers:0 */
	'use strict'
	module.exports = (function () {
		// Import Events
		var events = __webpack_require__(14)

		// Export Domain
		var domain = {}
		domain.createDomain = domain.create = function () {
			var d = new events.EventEmitter()

			function emitError (e) {
				d.emit('error', e)
			}

			d.add = function (emitter) {
				emitter.on('error', emitError)
			}
			d.remove = function (emitter) {
				emitter.removeListener('error', emitError)
			}
			d.bind = function (fn) {
				return function () {
					var args = Array.prototype.slice.call(arguments)
					try {
						fn.apply(null, args)
					}
					catch (err) {
						emitError(err)
					}
				}
			}
			d.intercept = function (fn) {
				return function (err) {
					if ( err ) {
						emitError(err)
					}
					else {
						var args = Array.prototype.slice.call(arguments, 1)
						try {
							fn.apply(null, args)
						}
						catch (err) {
							emitError(err)
						}
					}
				}
			}
			d.run = function (fn) {
				try {
					fn()
				}
				catch (err) {
					emitError(err)
				}
				return this
			}
			d.dispose = function () {
				this.removeAllListeners()
				return this
			}
			d.enter = d.exit = function () {
				return this
			}
			return d
		}
		return domain
	}).call(this)


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var spdy = exports;

	// Export tools
	spdy.handle = __webpack_require__(139);
	spdy.request = __webpack_require__(143);
	spdy.response = __webpack_require__(144);
	spdy.Socket = __webpack_require__(145);

	// Export client
	spdy.agent = __webpack_require__(146);
	spdy.Agent = spdy.agent.Agent;
	spdy.createAgent = spdy.agent.create;

	// Export server
	spdy.server = __webpack_require__(198);
	spdy.Server = spdy.server.Server;
	spdy.PlainServer = spdy.server.PlainServer;
	spdy.createServer = spdy.server.create;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process) {'use strict';

	var assert = __webpack_require__(9);
	var thing = __webpack_require__(140);
	var httpDeceiver = __webpack_require__(142);
	var util = __webpack_require__(10);

	function Handle(options, stream, socket) {
	  var state = {};
	  this._spdyState = state;

	  state.options = options || {};

	  state.stream = stream;
	  state.socket = null;
	  state.rawSocket = socket || stream.connection.socket;
	  state.deceiver = null;
	  state.ending = false;

	  var self = this;
	  thing.call(this, stream, {
	    getPeerName: function() {
	      return self._getPeerName();
	    },
	    close: function(callback) {
	      return self._closeCallback(callback);
	    }
	  });

	  if (!state.stream) {
	    this.on('stream', function(stream) {
	      state.stream = stream;
	    });
	  }
	}
	util.inherits(Handle, thing);
	module.exports = Handle;

	Handle.create = function create(options, stream, socket) {
	  return new Handle(options, stream, socket);
	};

	Handle.prototype._getPeerName = function _getPeerName() {
	  var state = this._spdyState;

	  if (state.rawSocket._getpeername)
	    return state.rawSocket._getpeername();

	  return null;
	};

	Handle.prototype._closeCallback = function _closeCallback(callback) {
	  var state = this._spdyState;
	  var stream = state.stream;

	  if (state.ending) {
	    // The .end() method of the stream may be called by us or by the
	    // .shutdown() method in our super-class. If the latter has already been
	    // called, then calling the .end() method below will have no effect, with
	    // the result that the callback will never get executed, leading to an ever
	    // so subtle memory leak.
	    if (stream._writableState.finished) {
	      // NOTE: it is important to call `setImmediate` instead of `nextTick`,
	      // since this is how regular `handle.close()` works in node.js core.
	      //
	      // Using `nextTick` will lead to `net.Socket` emitting `close` before
	      // `end` on UV_EOF. This results in aborted request without `end` event.
	      setImmediate(callback);
	    } else if (stream._writableState.ending) {
	      stream.once('finish', function() {
	        callback(null);
	      });
	    } else {
	      stream.end(callback);
	    }
	  } else {
	    stream.abort(callback);
	  }

	  // Only a single end is allowed
	  state.ending = false;
	};

	Handle.prototype.getStream = function getStream(callback) {
	  var state = this._spdyState;

	  if (!callback) {
	    assert(state.stream);
	    return state.stream;
	  }

	  if (state.stream) {
	    process.nextTick(function() {
	      callback(state.stream);
	    });
	    return;
	  }

	  this.on('stream', callback);
	};

	Handle.prototype.assignSocket = function assignSocket(socket, options) {
	  var state = this._spdyState;

	  state.socket = socket;
	  state.deceiver = httpDeceiver.create(socket, options);

	  function onStreamError(err) {
	    state.socket.emit('error', err);
	  }

	  this.getStream(function(stream) {
	    stream.on('error', onStreamError);
	  });
	};

	Handle.prototype.assignClientRequest = function assignClientRequest(req) {
	  var state = this._spdyState;
	  var oldEnd = req.end;
	  var oldSend = req._send;

	  // Catch the headers before request will be sent
	  var self = this;

	  // For old nodes
	  if (thing.mode !== 'modern') {
	    req.end = function end() {
	      this.end = oldEnd;

	      this._send('');

	      return this.end.apply(this, arguments);
	    };
	  }

	  req._send = function send(data) {
	    this._headerSent = true;

	    // for v0.10 and below, otherwise it will set `hot = false` and include
	    // headers in first write
	    this._header = 'ignore me';

	    // To prevent exception
	    this.connection = state.socket;

	    // It is very important to leave this here, otherwise it will be executed
	    // on a next tick, after `_send` will perform write
	    self.getStream(function(stream) {
	      stream.send();
	    });

	    // We are ready to create stream
	    self.emit('needStream');

	    req._send = oldSend;

	    // Ignore empty writes
	    if (req.method === 'GET' && data.length === 0)
	      return;

	    return req._send.apply(this, arguments);
	  };

	  // No chunked encoding
	  req.useChunkedEncodingByDefault = false;

	  req.on('finish', function() {
	    req.socket.end();
	  });
	};

	Handle.prototype.assignRequest = function assignRequest(req) {
	  // Emit trailing headers
	  this.getStream(function(stream) {
	    stream.on('headers', function(headers) {
	      req.emit('trailers', headers);
	    });
	  });
	};

	Handle.prototype.assignResponse = function assignResponse(res) {
	  var self = this;

	  res.addTrailers = function addTrailers(headers) {
	    self.getStream(function(stream) {
	      stream.sendHeaders(headers);
	    });
	  };
	};

	Handle.prototype._transformHeaders = function _transformHeaders(kind, headers) {
	  var state = this._spdyState;

	  var res = {};
	  var keys = Object.keys(headers);

	  if (kind === 'request' && state.options['x-forwarded-for']) {
	    var xforwarded = state.stream.connection.getXForwardedFor();
	    if (xforwarded !== null)
	      res['x-forwarded-for'] = xforwarded;
	  }

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var value = headers[key];

	    if (key === ':authority')
	      res.host = value;
	    if (/^:/.test(key))
	      continue;

	    res[key] = value;
	  }
	  return res;
	};

	Handle.prototype.emitRequest = function emitRequest() {
	  var state = this._spdyState;
	  var stream = state.stream;

	  state.deceiver.emitRequest({
	    method: stream.method,
	    path: stream.path,
	    headers: this._transformHeaders('request', stream.headers)
	  });
	};

	Handle.prototype.emitResponse = function emitResponse(status, headers) {
	  var state = this._spdyState;

	  state.deceiver.emitResponse({
	    status: status,
	    headers: this._transformHeaders('response', headers)
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38).setImmediate, __webpack_require__(2)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {var assert = __webpack_require__(9);
	var util = __webpack_require__(10);

	var EventEmitter = __webpack_require__(14).EventEmitter;
	var Buffer = __webpack_require__(5).Buffer;

	var Queue = __webpack_require__(141);

	// Node.js version
	var mode = /^v0\.8\./.test(process.version) ? 'rusty' :
	           /^v0\.(9|10)\./.test(process.version) ? 'old' :
	           'modern';

	function Handle(stream, options) {
	  EventEmitter.call(this);

	  this._stream = stream;
	  this._flowing = false;
	  this._reading = false;
	  this._options = options || {};

	  this.onread = null;

	  // Pending requests
	  this.pending = new Queue();

	  // Start handle once `onread` is set
	  if (mode === 'rusty') {
	    var self = this;
	    Object.defineProperty(this, 'onread', {
	      set: function(value) {
	        Object.defineProperty(self, 'onread', {
	          value: value
	        });
	        process.nextTick(function() {
	          self.readStart();
	        });
	      }
	    });
	  }

	  // NOTE: v0.8 has some odd .pause()/.resume() semantics in http.js
	  if (mode === 'rusty')
	    this.writeQueueSize = 0;
	  else if (mode !== 'modern')
	    this.writeQueueSize = 1;

	  if (mode === 'rusty') {
	    if (this._stream)
	      this._rustyInit();
	    else
	      this.once('stream', this._rustyInit);
	  }
	}
	util.inherits(Handle, EventEmitter);
	module.exports = Handle;

	Handle.mode = mode;

	Handle.create = function create(stream, options) {
	  return new Handle(stream, options);
	};

	Handle.prototype._queueReq = function _queueReq(type, req) {
	  return this.pending.append(type, req);
	};

	Handle.prototype._pendingList = function _pendingList() {
	  var list = [];
	  while (!this.pending.isEmpty())
	    list.push(this.pending.first().dequeue());
	  return list;
	};

	Handle.prototype.setStream = function setStream(stream) {
	  assert(this._stream === null, 'Can\'t set stream two times');
	  this._stream = stream;

	  this.emit('stream', stream);
	};

	Handle.prototype.readStart = function readStart() {
	  this._reading = true;

	  if (!this._stream) {
	    this.once('stream', this.readStart);
	    return 0;
	  }

	  if (!this._flowing) {
	    this._flowing = true;
	    this._flow();
	  }

	  this._stream.resume();
	  return 0;
	};

	Handle.prototype.readStop = function readStop() {
	  this._reading = false;

	  if (!this._stream) {
	    this.once('stream', this.readStop);
	    return 0;
	  }
	  this._stream.pause();
	  return 0;
	};

	if (mode === 'modern') {
	  var uv = process.binding('uv');

	  Handle.prototype._flow = function flow() {
	    var self = this;
	    this._stream.on('data', function(chunk) {
	      self.onread(chunk.length, chunk);
	    });

	    this._stream.on('end', function() {
	      self.onread(uv.UV_EOF, new Buffer(0));
	    });

	    this._stream.on('close', function() {
	      setImmediate(function() {
	        if (self._reading)
	          self.onread(uv.UV_ECONNRESET, new Buffer(0));
	      });
	    });
	  };

	  Handle.prototype._close = function _close() {
	    var list = this._pendingList();

	    var self = this;
	    setImmediate(function() {
	      for (var i = 0; i < list.length; i++) {
	        var req = list[i];
	        req.oncomplete(uv.UV_ECANCELED, self, req);
	      }
	    });

	    this.readStop();
	  };
	} else if (mode === 'old') {
	  Handle.prototype._flow = function flow() {
	    var self = this;
	    this._stream.on('data', function(chunk) {
	      self.onread(chunk, 0, chunk.length);
	    });

	    this._stream.on('end', function() {
	      var errno = process._errno;
	      process._errno = 'EOF';
	      self.onread(null, 0, 0);
	      if (process._errno === 'EOF')
	        process._errno = errno;
	    });

	    this._stream.on('close', function() {
	      setImmediate(function() {
	        if (!self._reading)
	          return;

	        var errno = process._errno;
	        process._errno = 'ECONNRESET';
	        self.onread(null, 0, 0);
	        if (process._errno === 'ECONNRESET')
	          process._errno = errno;
	      });
	    });
	  };

	  Handle.prototype._close = function _close() {
	    var list = this._pendingList();

	    var self = this;
	    setImmediate(function() {
	      for (var i = 0; i < list.length; i++) {
	        process._errno = 'CANCELED';
	        var req = list[i];
	        req.oncomplete(-1, self, req);
	      }
	    });

	    this.readStop();
	  };
	} else {
	  Handle.prototype._rustyInit = function _rustyInit() {
	    var self = this;

	    this._stream.on('close', function() {
	      process.nextTick(function() {
	        if (!self._reading)
	          return;

	        var errno = global.errno;
	        global.errno = 'ECONNRESET';
	        self.onread(null, 0, 0);
	        if (global.errno === 'ECONNRESET')
	          global.errno = errno;
	      });
	    });
	  };

	  Handle.prototype._flow = function flow() {
	    var self = this;
	    this._stream.on('data', function(chunk) {
	      self.onread(chunk, 0, chunk.length);
	    });

	    this._stream.on('end', function() {
	      var errno = global.errno;
	      global.errno = 'EOF';
	      self.onread(null, 0, 0);
	      if (global.errno === 'EOF')
	        global.errno = errno;
	    });
	  };

	  Handle.prototype._close = function _close() {
	    var list = this._pendingList();

	    var self = this;
	    process.nextTick(function() {
	      for (var i = 0; i < list.length; i++) {
	        var req = list[i];
	        global.errno = 'CANCELED';
	        req.oncomplete(-1, self, req);
	      }
	    });

	    this.readStop();
	  };
	}

	if (mode === 'modern') {
	  Handle.prototype.shutdown = function shutdown(req) {
	    var wrap = this._queueReq('shutdown', req);

	    if (!this._stream) {
	      this.once('stream', function() {
	        this._shutdown(wrap);
	      });
	      return 0;
	    }

	    return this._shutdown(wrap);
	  };

	  Handle.prototype._shutdown = function _shutdown(wrap) {
	    var self = this;
	    this._stream.end(function() {
	      var req = wrap.dequeue();
	      if (!req)
	        return;

	      req.oncomplete(0, self, req);
	    });
	    return 0;
	  };
	} else {
	  Handle.prototype.shutdown = function shutdown(req) {
	    if (!req)
	      req = {};

	    var wrap = this._queueReq('shutdown', req);

	    if (!this._stream) {
	      this.once('stream', function() {
	        this._shutdown(wrap);
	      });
	      return req;
	    }

	    this._shutdown(wrap);

	    return req;
	  };

	  Handle.prototype._shutdown = function _shutdown(wrap) {
	    var self = this;
	    this._stream.end(function() {
	      var req = wrap.dequeue();
	      if (!req)
	        return;
	      req.oncomplete(0, self, req);
	    });
	  };
	}

	if (mode !== 'rusty') {
	  Handle.prototype.close = function close(callback) {
	    this._close();

	    if (!this._stream) {
	      this.once('stream', function() {
	        this.close(callback);
	      });
	      return 0;
	    }

	    if (this._options.close)
	      this._options.close(callback);
	    else
	      process.nextTick(callback);

	    return 0;
	  };
	} else {
	  Handle.prototype.close = function close() {
	    this._close();

	    if (!this._stream)
	      this.once('stream', this.close);
	    else if (this._options.close)
	      this._options.close(function() {});

	    return 0;
	  };
	}

	if (mode === 'modern') {
	  Handle.prototype.writeEnc = function writeEnc(req, data, enc) {
	    var wrap = this._queueReq('write', req);

	    if (!this._stream) {
	      this.once('stream', function() {
	        this._writeEnc(wrap, req, data, enc);
	      });

	      return 0;
	    }

	    return this._writeEnc(wrap, req, data, enc);
	  };

	  Handle.prototype._writeEnc = function _writeEnc(wrap, req, data, enc) {
	    var self = this;

	    req.async = true;
	    req.bytes = data.length;

	    if (wrap.isEmpty())
	      return 0;

	    this._stream.write(data, enc, function() {
	      var req = wrap.dequeue();
	      if (!req)
	        return;
	      req.oncomplete(0, self, req);
	    });

	    return 0;
	  };
	} else {
	  Handle.prototype.writeEnc = function writeEnc(data, ignored, enc, req) {
	    if (!req)
	      req = { bytes: data.length };

	    var wrap = this._queueReq('write', req);

	    if (!this._stream) {
	      this.once('stream', function() {
	        this._writeEnc(data, ignored, enc, wrap);
	      });
	      return req;
	    }

	    this._writeEnc(data, ignored, enc, wrap);
	    return req;
	  };

	  Handle.prototype._writeEnc = function _writeEnc(data, ignored, enc, wrap) {
	    var self = this;
	    var buffer = new Buffer(data, enc);

	    if (wrap.isEmpty())
	      return;

	    this._stream.write(buffer, function() {
	      var req = wrap.dequeue();
	      if (!req)
	        return;
	      req.oncomplete(0, self, req);
	    });
	  };
	}

	Handle.prototype.writeBuffer = function writeBuffer(req, data) {
	  return this.writeEnc(req, data, null);
	};

	Handle.prototype.writeAsciiString = function writeAsciiString(req, data) {
	  return this.writeEnc(req, data, 'ascii');
	};

	Handle.prototype.writeUtf8String = function writeUtf8String(req, data) {
	  return this.writeEnc(req, data, 'utf8');
	};

	Handle.prototype.writeUcs2String = function writeUcs2String(req, data) {
	  return this.writeEnc(req, data, 'ucs2');
	};

	Handle.prototype.writeBinaryString = function writeBinaryString(req, data) {
	  return this.writeEnc(req, data, 'binary');
	};

	Handle.prototype.writeLatin1String = function writeLatin1String(req, data) {
	  return this.writeEnc(req, data, 'binary');
	};

	// v0.8
	Handle.prototype.getsockname = function getsockname() {
	  if (this._options.getPeerName)
	    return this._options.getPeerName();
	  return null;
	};

	if (mode === 'modern') {
	  Handle.prototype.getpeername = function getpeername(out) {
	    var res = this.getsockname();
	    if (!res)
	      return -1;

	    Object.keys(res).forEach(function(key) {
	      out[key] = res[key];
	    });

	    return 0;
	  };
	} else {
	  // v0.10
	  Handle.prototype.getpeername = function getpeername() {
	    return this.getsockname();
	  };
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(38).setImmediate, (function() { return this; }())))

/***/ },
/* 141 */
/***/ function(module, exports) {

	function Queue() {
	  this.head = new Item('head', null);
	}
	module.exports = Queue;

	Queue.prototype.append = function append(kind, value) {
	  var item = new Item(kind, value);
	  this.head.prepend(item);
	  return item;
	};

	Queue.prototype.isEmpty = function isEmpty() {
	  return this.head.prev === this.head;
	};

	Queue.prototype.first = function first() {
	  return this.head.next;
	};

	function Item(kind, value) {
	  this.prev = this;
	  this.next = this;
	  this.kind = kind;
	  this.value = value;
	}

	Item.prototype.prepend = function prepend(other) {
	  other.prev = this.prev;
	  other.next = this;
	  other.prev.next = other;
	  other.next.prev = other;
	};

	Item.prototype.dequeue = function dequeue() {
	  var prev = this.prev;
	  var next = this.next;

	  prev.next = next;
	  next.prev = prev;
	  this.prev = this;
	  this.next = this;

	  return this.value;
	};

	Item.prototype.isEmpty = function isEmpty() {
	  return this.prev === this;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(9);
	var util = __webpack_require__(10);

	var Buffer = __webpack_require__(5).Buffer;

	// Node.js version
	var mode = /^v0\.8\./.test(process.version) ? 'rusty' :
	           /^v0\.(9|10)\./.test(process.version) ? 'old' :
	           /^v0\.12\./.test(process.version) ? 'normal' :
	           'modern';

	var HTTPParser;

	var methods;
	var reverseMethods;

	var kOnHeaders;
	var kOnHeadersComplete;
	var kOnMessageComplete;
	var kOnBody;
	if (mode === 'normal' || mode === 'modern') {
	  HTTPParser = process.binding('http_parser').HTTPParser;
	  methods = HTTPParser.methods;

	  // v6
	  if (!methods)
	    methods = process.binding('http_parser').methods;

	  reverseMethods = {};

	  methods.forEach(function(method, index) {
	    reverseMethods[method] = index;
	  });

	  kOnHeaders = HTTPParser.kOnHeaders | 0;
	  kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;
	  kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;
	  kOnBody = HTTPParser.kOnBody | 0;
	} else {
	  kOnHeaders = 'onHeaders';
	  kOnHeadersComplete = 'onHeadersComplete';
	  kOnMessageComplete = 'onMessageComplete';
	  kOnBody = 'onBody';
	}

	function Deceiver(socket, options) {
	  this.socket = socket;
	  this.options = options || {};
	  this.isClient = this.options.isClient;
	}
	module.exports = Deceiver;

	Deceiver.create = function create(stream, options) {
	  return new Deceiver(stream, options);
	};

	Deceiver.prototype._toHeaderList = function _toHeaderList(object) {
	  var out = [];
	  var keys = Object.keys(object);

	  for (var i = 0; i < keys.length; i++)
	    out.push(keys[i], object[keys[i]]);

	  return out;
	};

	Deceiver.prototype._isUpgrade = function _isUpgrade(request) {
	  return request.method === 'CONNECT' ||
	         request.headers.upgrade ||
	         request.headers.connection &&
	            /(^|\W)upgrade(\W|$)/i.test(request.headers.connection);
	};

	// TODO(indutny): support CONNECT
	if (mode === 'modern') {
	  /*
	  function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
	                                   url, statusCode, statusMessage, upgrade,
	                                   shouldKeepAlive) {
	   */
	  Deceiver.prototype.emitRequest = function emitRequest(request) {
	    var parser = this.socket.parser;
	    assert(parser, 'No parser present');

	    parser.execute = null;

	    var self = this;
	    var method = reverseMethods[request.method];
	    parser.execute = function execute() {
	      self._skipExecute(this);
	      this[kOnHeadersComplete](1,
	                               1,
	                               self._toHeaderList(request.headers),
	                               method,
	                               request.path,
	                               0,
	                               '',
	                               self._isUpgrade(request),
	                               true);
	      return 0;
	    };

	    this._emitEmpty();
	  };

	  Deceiver.prototype.emitResponse = function emitResponse(response) {
	    var parser = this.socket.parser;
	    assert(parser, 'No parser present');

	    parser.execute = null;

	    var self = this;
	    parser.execute = function execute() {
	      self._skipExecute(this);
	      this[kOnHeadersComplete](1,
	                               1,
	                               self._toHeaderList(response.headers),
	                               response.path,
	                               response.code,
	                               response.status,
	                               response.reason || '',
	                               self._isUpgrade(response),
	                               true);
	      return 0;
	    };

	    this._emitEmpty();
	  };
	} else {
	  /*
	    `function parserOnHeadersComplete(info) {`

	    info = { .versionMajor, .versionMinor, .url, .headers, .method,
	             .statusCode, .statusMessage, .upgrade, .shouldKeepAlive }
	   */
	  Deceiver.prototype.emitRequest = function emitRequest(request) {
	    var parser = this.socket.parser;
	    assert(parser, 'No parser present');

	    var method = request.method;
	    if (reverseMethods)
	      method = reverseMethods[method];

	    var info = {
	      versionMajor: 1,
	      versionMinor: 1,
	      url: request.path,
	      headers: this._toHeaderList(request.headers),
	      method: method,
	      statusCode: 0,
	      statusMessage: '',
	      upgrade: this._isUpgrade(request),
	      shouldKeepAlive: true
	    };

	    var self = this;
	    parser.execute = function execute() {
	      self._skipExecute(this);
	      this[kOnHeadersComplete](info);
	      return 0;
	    };

	    this._emitEmpty();
	  };

	  Deceiver.prototype.emitResponse = function emitResponse(response) {
	    var parser = this.socket.parser;
	    assert(parser, 'No parser present');

	    var info = {
	      versionMajor: 1,
	      versionMinor: 1,
	      url: response.path,
	      headers: this._toHeaderList(response.headers),
	      method: false,
	      statusCode: response.status,
	      statusMessage: response.reason || '',
	      upgrade: this._isUpgrade(response),
	      shouldKeepAlive: true
	    };

	    var self = this;
	    parser.execute = function execute() {
	      self._skipExecute(this);
	      this[kOnHeadersComplete](info);
	      return 0;
	    };

	    this._emitEmpty();
	  };
	}

	Deceiver.prototype._skipExecute = function _skipExecute(parser) {
	  var self = this;
	  var oldExecute = parser.constructor.prototype.execute;
	  var oldFinish = parser.constructor.prototype.finish;

	  parser.execute = null;
	  parser.finish = null;

	  parser.execute = function execute(buffer, start, len) {
	    // Parser reuse
	    if (this.socket !== self.socket) {
	      this.execute = oldExecute;
	      this.finish = oldFinish;
	      return this.execute(buffer, start, len);
	    }

	    if (start !== undefined)
	      buffer = buffer.slice(start, start + len);
	    self.emitBody(buffer);
	    return len;
	  };

	  parser.finish = function finish() {
	    // Parser reuse
	    if (this.socket !== self.socket) {
	      this.execute = oldExecute;
	      this.finish = oldFinish;
	      return this.finish();
	    }

	    this.execute = oldExecute;
	    this.finish = oldFinish;
	    self.emitMessageComplete();
	  };
	};

	Deceiver.prototype.emitBody = function emitBody(buffer) {
	  var parser = this.socket.parser;
	  assert(parser, 'No parser present');

	  parser[kOnBody](buffer, 0, buffer.length);
	};

	Deceiver.prototype._emitEmpty = function _emitEmpty() {
	  // Emit data to force out handling of UPGRADE
	  var empty = new Buffer(0);
	  if (this.socket.ondata)
	    this.socket.ondata(empty, 0, 0);
	  else
	    this.socket.emit('data', empty);
	};

	Deceiver.prototype.emitMessageComplete = function emitMessageComplete() {
	  var parser = this.socket.parser;
	  assert(parser, 'No parser present');

	  parser[kOnMessageComplete]();
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';

	function attachPush(req) {
	  var handle = req.socket._handle;

	  handle.getStream(function(stream) {
	    stream.on('pushPromise', function(push) {
	      req.emit('push', push);
	    });
	  });
	}

	exports.onNewListener = function onNewListener(type) {
	  var req = this;

	  if (type !== 'push')
	    return;

	  // Not first listener
	  if (req.listeners('push').length !== 0)
	    return;

	  if (!req.socket) {
	    req.on('socket', function() {
	      attachPush(req);
	    });
	    return;
	  }

	  attachPush(req);
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	'use strict';

	// NOTE: Mostly copy paste from node
	exports.writeHead = function writeHead(statusCode, reason, obj) {
	  var headers;

	  if (typeof reason === 'string') {
	    // writeHead(statusCode, reasonPhrase[, headers])
	    this.statusMessage = reason;
	  } else {
	    // writeHead(statusCode[, headers])
	    this.statusMessage =
	      this.statusMessage || 'unknown';
	    obj = reason;
	  }
	  this.statusCode = statusCode;

	  if (this._headers) {
	    // Slow-case: when progressive API and header fields are passed.
	    if (obj) {
	      var keys = Object.keys(obj);
	      for (var i = 0; i < keys.length; i++) {
	        var k = keys[i];
	        if (k) this.setHeader(k, obj[k]);
	      }
	    }
	    // only progressive api is used
	    headers = this._renderHeaders();
	  } else {
	    // only writeHead() called
	    headers = obj;
	  }

	  if (statusCode === 204 || statusCode === 304 ||
	      (100 <= statusCode && statusCode <= 199)) {
	    // RFC 2616, 10.2.5:
	    // The 204 response MUST NOT include a message-body, and thus is always
	    // terminated by the first empty line after the header fields.
	    // RFC 2616, 10.3.5:
	    // The 304 response MUST NOT contain a message-body, and thus is always
	    // terminated by the first empty line after the header fields.
	    // RFC 2616, 10.1 Informational 1xx:
	    // This class of status code indicates a provisional response,
	    // consisting only of the Status-Line and optional headers, and is
	    // terminated by an empty line.
	    this._hasBody = false;
	  }

	  // don't keep alive connections where the client expects 100 Continue
	  // but we sent a final status; they may put extra bytes on the wire.
	  if (this._expect_continue && !this._sent100) {
	    this.shouldKeepAlive = false;
	  }

	  // Implicit headers sent!
	  this._header = true;
	  this._headerSent = true;

	  if (this.socket._handle)
	    this.socket._handle._spdyState.stream.respond(this.statusCode, headers);
	};

	exports.end = function end(data, encoding, callback) {
	  if (!this._headerSent)
	    this.writeHead(this.statusCode);

	  if (!this.socket._handle)
	    return;

	  // Compatibility with Node.js core
	  this.finished = true;

	  var self = this;
	  var handle = this.socket._handle;
	  handle._spdyState.ending = true;
	  this.socket.end(data, encoding, function() {
	    self.constructor.prototype.end.call(self, '', 'utf8', callback);
	  });
	};

	exports.push = function push(path, headers, callback) {
	  var frame = {
	    path: path,
	    method: headers.method ? headers.method.toString() : 'GET',
	    status: headers.status ? parseInt(headers.status, 10) : 200,
	    host: this._req.headers.host,
	    headers: headers.request,
	    response: headers.response
	  };

	  var stream = this.spdyStream;
	  return stream.pushPromise(frame, callback);
	};

	exports.writeContinue = function writeContinue(callback) {
	  if (this.socket._handle)
	    this.socket._handle._spdyState.stream.respond(100, {}, callback);
	};


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(10);
	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	function Socket(parent, options) {
	  net.Socket.call(this, options);

	  var state = {};

	  this._spdyState = state;

	  state.parent = parent;

	  this.servername = parent.servername;
	  this.npnProtocol = parent.npnProtocol;
	  this.alpnProtocol = parent.alpnProtocol;
	  this.authorized = parent.authorized;
	  this.authorizationError = parent.authorizationError;
	  this.encrypted = true;
	}
	util.inherits(Socket, net.Socket);

	module.exports = Socket;

	var methods = [
	  'renegotiate', 'setMaxSendFragment', 'getTLSTicket', 'setServername',
	  'setSession', 'getPeerCertificate', 'getSession', 'isSessionReused',
	  'getCipher', 'getEphemeralKeyInfo'
	];

	methods.forEach(function(method) {
	  Socket.prototype[method] = function methodWrap() {
	    var parent = this._spdyState.parent;
	    return parent[method].apply(parent, arguments);
	  };
	});


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var assert = __webpack_require__(9);
	var http = __webpack_require__(76);
	var https = __webpack_require__(87);
	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var util = __webpack_require__(10);
	var transport = __webpack_require__(147);
	var debug = __webpack_require__(153)('spdy:client');

	var EventEmitter = __webpack_require__(14).EventEmitter;

	var spdy = __webpack_require__(138);

	var mode = /^v0\.8\./.test(process.version) ? 'rusty' :
	           /^v0\.(9|10)\./.test(process.version) ? 'old' :
	           /^v0\.12\./.test(process.version) ? 'normal' :
	           'modern';

	var proto = {};

	function instantiate(base) {
	  function Agent(options) {
	    this._init(base, options);
	  }
	  util.inherits(Agent, base);

	  Agent.create = function create(options) {
	    return new Agent(options);
	  };

	  Object.keys(proto).forEach(function(key) {
	    Agent.prototype[key] = proto[key];
	  });

	  return Agent;
	}

	proto._init = function _init(base, options) {
	  base.call(this, options);

	  var state = {};
	  this._spdyState = state;

	  state.host = options.host;
	  state.options = options.spdy || {};
	  state.secure = this instanceof https.Agent;
	  state.fallback = false;
	  state.createSocket = this._getCreateSocket();
	  state.socket = null;
	  state.connection = null;

	  // No chunked encoding
	  this.keepAlive = false;

	  var self = this;
	  this._connect(options, function(err, connection) {
	    if (err)
	      return self.emit('error', err);

	    state.connection = connection;
	    self.emit('_connect');
	  });
	};

	proto._getCreateSocket = function _getCreateSocket() {
	  // Find super's `createSocket` method
	  var createSocket;
	  var cons = this.constructor.super_;
	  do {
	    createSocket = cons.prototype.createSocket;

	    if (cons.super_ === EventEmitter || !cons.super_)
	      break;
	    cons = cons.super_;
	  } while (!createSocket);
	  if (!createSocket)
	    createSocket = http.Agent.prototype.createSocket;

	  assert(createSocket, '.createSocket() method not found');

	  return createSocket;
	};

	proto._connect = function _connect(options, callback) {
	  var state = this._spdyState;

	  var protocols = state.options.protocols || [
	    'h2',
	    'spdy/3.1', 'spdy/3', 'spdy/2',
	    'http/1.1', 'http/1.0'
	  ];

	  // TODO(indutny): reconnect automatically?
	  var socket = this.createConnection(util._extend({
	    NPNProtocols: protocols,
	    ALPNProtocols: protocols,
	    servername: options.servername || options.host
	  }, options));
	  state.socket = socket;

	  socket.setNoDelay(true);

	  function onError(err) {
	    return callback(err);
	  }
	  socket.on('error', onError);

	  socket.on(state.secure ? 'secureConnect' : 'connect', function() {
	    socket.removeListener('error', onError);

	    var protocol;
	    if (state.secure) {
	      protocol = socket.npnProtocol ||
	                 socket.alpnProtocol ||
	                 state.options.protocol;
	    } else {
	      protocol = state.options.protocol;
	    }

	    // HTTP server - kill socket and switch to the fallback mode
	    if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {
	      debug('activating fallback');
	      socket.destroy();
	      state.fallback = true;
	      return;
	    }

	    debug('connected protocol=%j', protocol);
	    var connection = transport.connection.create(socket, util._extend({
	      protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',
	      isServer: false
	    }, state.options.connection || {}));

	    // Set version when we are certain
	    if (protocol === 'h2') {
	      connection.start(4);
	    } else if (protocol === 'spdy/3.1') {
	      connection.start(3.1);
	    } else if (protocol === 'spdy/3') {
	      connection.start(3);
	    } else if (protocol === 'spdy/2') {
	      connection.start(2);
	    } else {
	      socket.destroy();
	      callback(new Error('Unexpected protocol: ' + protocol));
	      return;
	    }

	    if (state.options['x-forwarded-for'] !== undefined)
	      connection.sendXForwardedFor(state.options['x-forwarded-for']);

	    callback(null, connection);
	  });
	};

	proto._createSocket = function _createSocket(req, options, callback) {
	  var state = this._spdyState;
	  if (state.fallback)
	    return state.createSocket(req, options);

	  var handle = spdy.handle.create(null, null, state.socket);

	  var socketOptions = {
	    handle: handle,
	    allowHalfOpen: true
	  };

	  var socket;
	  if (state.secure)
	    socket = new spdy.Socket(state.socket, socketOptions);
	  else
	    socket = new net.Socket(socketOptions);

	  handle.assignSocket(socket);
	  handle.assignClientRequest(req);

	  // Create stream only once `req.end()` is called
	  var self = this;
	  handle.once('needStream', function() {
	    if (state.connection === null) {
	      self.once('_connect', function() {
	        handle.setStream(self._createStream(req, handle));
	      });
	    } else {
	      handle.setStream(self._createStream(req, handle));
	    }
	  });

	  // Yes, it is in reverse
	  req.on('response', function(res) {
	    handle.assignRequest(res);
	  });
	  handle.assignResponse(req);

	  // Handle PUSH
	  req.addListener('newListener', spdy.request.onNewListener);

	  // For v0.8
	  socket.readable = true;
	  socket.writable = true;

	  if (callback)
	    return callback(null, socket);

	  return socket;
	};

	if (mode === 'modern' || mode === 'normal') {
	  proto.createSocket = proto._createSocket;
	} else {
	  proto.createSocket = function createSocket(name, host, port, addr, req) {
	    var state = this._spdyState;
	    if (state.fallback)
	      return state.createSocket(name, host, port, addr, req);

	    return this._createSocket(req, {
	      host: host,
	      port: port
	    });
	  };
	}

	proto._createStream = function _createStream(req, handle) {
	  var state = this._spdyState;

	  var self = this;
	  return state.connection.reserveStream({
	    method: req.method,
	    path: req.path,
	    headers: req._headers,
	    host: state.host
	  }, function(err, stream) {
	    if (err)
	      return self.emit('error', err);

	    stream.on('response', function(status, headers) {
	      handle.emitResponse(status, headers);
	    });
	  });
	};

	// Public APIs

	proto.close = function close(callback) {
	  var state = this._spdyState;

	  if (state.connection === null) {
	    this.once('_connect', function() {
	      this.close(callback);
	    });
	    return;
	  }

	  state.connection.end(callback);
	};

	exports.Agent = instantiate(https.Agent);
	exports.PlainAgent = instantiate(http.Agent);

	exports.create = function create(base, options) {
	  if (typeof base === 'object') {
	    options = base;
	    base = null;
	  }

	  if (base)
	    return instantiate(base).create(options);

	  if (options.spdy && options.spdy.plain)
	    return exports.PlainAgent.create(options);
	  else
	    return exports.Agent.create(options);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var transport = exports;

	// Exports utils
	transport.utils = __webpack_require__(148);

	// Export parser&framer
	transport.protocol = {};
	transport.protocol.base = __webpack_require__(149);
	transport.protocol.spdy = __webpack_require__(172);
	transport.protocol.http2 = __webpack_require__(180);

	// Window
	transport.Window = __webpack_require__(194);

	// Priority Tree
	transport.Priority = __webpack_require__(195);

	// Export Connection and Stream
	transport.Stream = __webpack_require__(196).Stream;
	transport.Connection = __webpack_require__(197).Connection;

	// Just for `transport.connection.create()`
	transport.connection = transport.Connection;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var util = __webpack_require__(10);

	function QueueItem() {
	  this.prev = null;
	  this.next = null;
	}
	exports.QueueItem = QueueItem;

	function Queue() {
	  QueueItem.call(this);

	  this.prev = this;
	  this.next = this;
	}
	util.inherits(Queue, QueueItem);
	exports.Queue = Queue;

	Queue.prototype.insertTail = function insertTail(item) {
	  item.prev = this.prev;
	  item.next = this;
	  item.prev.next = item;
	  item.next.prev = item;
	};

	Queue.prototype.remove = function remove(item) {
	  var next = item.next;
	  var prev = item.prev;

	  item.next = item;
	  item.prev = item;
	  next.prev = prev;
	  prev.next = next;
	};

	Queue.prototype.head = function head() {
	  return this.next;
	};

	Queue.prototype.tail = function tail() {
	  return this.prev;
	};

	Queue.prototype.isEmpty = function isEmpty() {
	  return this.next === this;
	};

	Queue.prototype.isRoot = function isRoot(item) {
	  return this === item;
	};

	function LockStream(stream) {
	  this.locked = false;
	  this.queue = [];
	  this.stream = stream;
	}
	exports.LockStream = LockStream;

	LockStream.prototype.write = function write(chunks, callback) {
	  var self = this;

	  // Do not let it interleave
	  if (this.locked) {
	    this.queue.push(function() {
	      return self.write(chunks, callback);
	    });
	    return;
	  }

	  this.locked = true;

	  function done(err, chunks) {
	    self.stream.removeListener('error', done);

	    self.locked = false;
	    if (self.queue.length > 0)
	      self.queue.shift()();
	    callback(err, chunks);
	  }

	  this.stream.on('error', done);

	  // Accumulate all output data
	  var output = [];
	  function onData(chunk) {
	    output.push(chunk);
	  }
	  this.stream.on('data', onData);

	  function next(err) {
	    self.stream.removeListener('data', onData);
	    if (err)
	      return done(err);

	    done(null, output);
	  }

	  for (var i = 0; i < chunks.length - 1; i++)
	    this.stream.write(chunks[i]);

	  if (chunks.length > 0)
	    this.stream.write(chunks[i], next);
	  else
	    process.nextTick(next);

	  if (this.stream.execute) {
	    this.stream.execute(function(err) {
	      if (err)
	        return done(err);
	    });
	  }
	};

	// Just finds the place in array to insert
	function binaryLookup(list, item, compare) {
	  var start = 0;
	  var end = list.length;

	  while (start < end) {
	    var pos = (start + end) >> 1;
	    var cmp = compare(item, list[pos]);

	    if (cmp === 0) {
	      start = pos;
	      end = pos;
	      break;
	    } else if (cmp < 0) {
	      end = pos;
	    } else {
	      start = pos + 1;
	    }
	  }

	  return start;
	}
	exports.binaryLookup = binaryLookup;

	function binaryInsert(list, item, compare) {
	  var index = binaryLookup(list, item, compare);

	  list.splice(index, 0, item);
	}
	exports.binaryInsert = binaryInsert;

	function binarySearch(list, item, compare) {
	  var index = binaryLookup(list, item, compare);

	  if (index >= list.length)
	    return -1;

	  if (compare(item, list[index]) === 0)
	    return index;

	  return -1;
	}
	exports.binarySearch = binarySearch;

	function Timeout(object) {
	  this.delay = 0;
	  this.timer = null;
	  this.object = object;
	}
	exports.Timeout = Timeout;

	Timeout.prototype.set = function set(delay, callback) {
	  this.delay = delay;
	  this.reset();
	  if (!callback)
	    return;

	  if (this.delay === 0)
	    this.object.removeListener('timeout', callback);
	  else
	    this.object.once('timeout', callback);
	};

	Timeout.prototype.reset = function reset() {
	  if (this.timer !== null) {
	    clearTimeout(this.timer);
	    this.timer = null;
	  }

	  if (this.delay === 0)
	    return;

	  var self = this;
	  this.timer = setTimeout(function() {
	    self.timer = null;
	    self.object.emit('timeout');
	  }, this.delay);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.utils = __webpack_require__(150);
	exports.constants = __webpack_require__(151);
	exports.Scheduler = __webpack_require__(152);
	exports.Parser = __webpack_require__(169);
	exports.Framer = __webpack_require__(171);


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = exports;

	var util = __webpack_require__(10);

	function ProtocolError(code, message) {
	  this.code = code;
	  this.message = message;
	}
	util.inherits(ProtocolError, Error);
	utils.ProtocolError = ProtocolError;

	utils.error = function error(code, message) {
	  return new ProtocolError(code, message);
	};

	utils.reverse = function reverse(object) {
	  var result = []

	  Object.keys(object).forEach(function(key) {
	    result[object[key] | 0] = key;
	  });

	  return result;
	};

	// weight [1, 36] <=> priority [0, 7]
	// This way weight=16 is preserved and has priority=3
	utils.weightToPriority = function weightToPriority(weight) {
	  return ((Math.min(35, (weight - 1)) / 35) * 7) | 0;
	};

	utils.priorityToWeight = function priorityToWeight(priority) {
	  return (((priority / 7) * 35) | 0) + 1;
	};

	// Copy-Paste from node
	exports.addHeaderLine = function addHeaderLine(field, value, dest) {
	  field = field.toLowerCase();
	  if (/^:/.test(field)) {
	    dest[field] = value;
	    return;
	  }

	  switch (field) {
	    // Array headers:
	    case 'set-cookie':
	      if (dest[field] !== undefined) {
	        dest[field].push(value);
	      } else {
	        dest[field] = [ value ];
	      }
	      break;

	    /* eslint-disable max-len */
	    // list is taken from:
	    /* eslint-enable max-len */
	    case 'content-type':
	    case 'content-length':
	    case 'user-agent':
	    case 'referer':
	    case 'host':
	    case 'authorization':
	    case 'proxy-authorization':
	    case 'if-modified-since':
	    case 'if-unmodified-since':
	    case 'from':
	    case 'location':
	    case 'max-forwards':
	      // drop duplicates
	      if (dest[field] === undefined)
	        dest[field] = value;
	      break;

	    case 'cookie':
	      // make semicolon-separated list
	      if (dest[field] !== undefined) {
	        dest[field] += '; ' + value;
	      } else {
	        dest[field] = value;
	      }
	      break;

	    default:
	      // make comma-separated list
	      if (dest[field] !== undefined) {
	        dest[field] += ', ' + value;
	      } else {
	        dest[field] = value;
	      }
	  }
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	exports.DEFAULT_METHOD = 'GET';
	exports.DEFAULT_HOST = 'localhost';
	exports.MAX_PRIORITY_STREAMS = 100;
	exports.DEFAULT_MAX_CHUNK = 8 * 1024;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var transport = __webpack_require__(147);
	var utils = transport.utils;

	var assert = __webpack_require__(9);
	var util = __webpack_require__(10);
	var debug = __webpack_require__(153)('spdy:scheduler');
	var Readable = __webpack_require__(156).Readable;

	/*
	 * We create following structure in `pending`:
	 * [ [ id = 0 ], [ id = 1 ], [ id = 2 ], [ id = 0 ] ]
	 *     chunks      chunks      chunks      chunks
	 *     chunks                  chunks
	 *     chunks
	 *
	 * Then on the `.tick()` pass we pick one chunks from each item and remove the
	 * item if it is empty:
	 *
	 * [ [ id = 0 ], [ id = 2 ] ]
	 *     chunks      chunks
	 *     chunks
	 *
	 * Writing out: chunks for 0, chunks for 1, chunks for 2, chunks for 0
	 *
	 * This way data is interleaved between the different streams.
	 */

	function Scheduler(options) {
	  Readable.call(this);

	  // Pretty big window by default
	  this.window = 0.25;

	  if (options && options.window)
	    this.window = options.window;

	  this.sync = [];
	  this.list = [];
	  this.count = 0;
	  this.pendingTick = false;
	}
	util.inherits(Scheduler, Readable);
	module.exports = Scheduler;

	// Just for testing, really
	Scheduler.create = function create(options) {
	  return new Scheduler(options);
	};

	function insertCompare(a, b) {
	  return a.priority === b.priority ?
	      a.stream - b.stream :
	      b.priority - a.priority;
	}

	Scheduler.prototype.schedule = function schedule(data) {
	  var priority = data.priority;
	  var stream = data.stream;
	  var chunks = data.chunks;

	  // Synchronous frames should not be interleaved
	  if (priority === false) {
	    debug('queue sync', chunks);
	    this.sync.push(data);
	    this.count += chunks.length;

	    this._read();
	    return;
	  }

	  debug('queue async priority=%d stream=%d', priority, stream, chunks);
	  var item = new SchedulerItem(stream, priority);
	  var index = utils.binaryLookup(this.list, item, insertCompare);

	  // Push new item
	  if (index >= this.list.length || insertCompare(this.list[index], item) !== 0)
	    this.list.splice(index, 0, item);
	  // Coalesce
	  else
	    item = this.list[index];

	  item.push(data);

	  this.count += chunks.length;

	  this._read();
	};

	Scheduler.prototype._read = function _read() {
	  if (this.count === 0)
	    return;

	  if (this.pendingTick)
	    return;
	  this.pendingTick = true;

	  var self = this;
	  process.nextTick(function() {
	    self.pendingTick = false;
	    self.tick();
	  });
	};

	Scheduler.prototype.tick = function tick() {
	  // No luck for async frames
	  if (!this.tickSync())
	    return false;

	  return this.tickAsync();
	};

	Scheduler.prototype.tickSync = function tickSync() {
	  // Empty sync queue first
	  var sync = this.sync;
	  var res = true;
	  this.sync = [];
	  for (var i = 0; i < sync.length; i++) {
	    var item = sync[i];
	    debug('tick sync pending=%d', this.count, item.chunks);
	    for (var j = 0; j < item.chunks.length; j++) {
	      this.count--;
	      res = this.push(item.chunks[j]);
	    }
	    debug('after tick sync pending=%d', this.count);

	    // TODO(indutny): figure out the way to invoke callback on actual write
	    if (item.callback)
	      item.callback(null);
	  }
	  return res;
	};

	Scheduler.prototype.tickAsync = function tickAsync() {
	  var res = true;
	  var list = this.list;
	  if (list.length === 0)
	    return res;

	  var startPriority = list[0].priority;
	  for (var index = 0; list.length > 0; index++) {
	    // Loop index
	    index %= list.length;
	    if (startPriority - list[index].priority > this.window)
	      index = 0;
	    debug('tick async index=%d start=%d', index, startPriority);

	    var current = list[index];
	    var item = current.shift();

	    if (current.isEmpty()) {
	      list.splice(index, 1);
	      if (index === 0 && list.length > 0)
	        startPriority = list[0].priority;
	      index--;
	    }

	    debug('tick async pending=%d', this.count, item.chunks);
	    for (var i = 0; i < item.chunks.length; i++) {
	      this.count--;
	      res = this.push(item.chunks[i]);
	    }
	    debug('after tick pending=%d', this.count);

	    // TODO(indutny): figure out the way to invoke callback on actual write
	    if (item.callback)
	      item.callback(null);
	    if (!res)
	      break;
	  }

	  return res;
	};

	Scheduler.prototype.dump = function dump() {
	  this.tickSync();

	  // Write everything out
	  while (!this.tickAsync()) {
	    // Intentional no-op
	  }
	  assert.equal(this.count, 0);
	};

	function SchedulerItem(stream, priority) {
	  this.stream = stream;
	  this.priority = priority;
	  this.queue = [];
	}

	SchedulerItem.prototype.push = function push(chunks) {
	  this.queue.push(chunks);
	};

	SchedulerItem.prototype.shift = function shift() {
	  return this.queue.shift();
	};

	SchedulerItem.prototype.isEmpty = function isEmpty() {
	  return this.queue.length === 0;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(154);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(155);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(13); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(157);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(164);
	exports.Duplex = __webpack_require__(163);
	exports.Transform = __webpack_require__(167);
	exports.PassThrough = __webpack_require__(168);

	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	module.exports = Readable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(158);
	/*</replacement>*/

	/*<replacement>*/
	var isArray = __webpack_require__(159);
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	var EE = __webpack_require__(14).EventEmitter;

	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(13);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(14).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(5).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(160);
	/*</replacement>*/

	/*<replacement>*/
	var util = __webpack_require__(110);
	util.inherits = __webpack_require__(46);
	/*</replacement>*/

	/*<replacement>*/
	var debugUtil = __webpack_require__(161);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var BufferList = __webpack_require__(162);
	var StringDecoder;

	util.inherits(Readable, Stream);

	function prependListener(emitter, event, fn) {
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}

	var Duplex;
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(163);

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(166).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	var Duplex;
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(163);

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function') this._read = options.read;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }

	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	          if (state.needReadable) emitReadable(stream);
	        }
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(166).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;

	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;

	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }

	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}

	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 159 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var buffer = __webpack_require__(5);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 161 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Buffer = __webpack_require__(5).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(160);
	/*</replacement>*/

	module.exports = BufferList;

	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}

	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};

	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};

	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};

	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};

	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};

	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	'use strict';

	/*<replacement>*/

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/

	module.exports = Duplex;

	/*<replacement>*/
	var processNextTick = __webpack_require__(158);
	/*</replacement>*/

	/*<replacement>*/
	var util = __webpack_require__(110);
	util.inherits = __webpack_require__(46);
	/*</replacement>*/

	var Readable = __webpack_require__(157);
	var Writable = __webpack_require__(164);

	util.inherits(Duplex, Readable);

	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.

	'use strict';

	module.exports = Writable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(158);
	/*</replacement>*/

	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var util = __webpack_require__(110);
	util.inherits = __webpack_require__(46);
	/*</replacement>*/

	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(165)
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(13);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(14).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(5).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(160);
	/*</replacement>*/

	util.inherits(Writable, Stream);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	var Duplex;
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(163);

	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();

	var Duplex;
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(163);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(38).setImmediate))

/***/ },
/* 165 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(5).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	'use strict';

	module.exports = Transform;

	var Duplex = __webpack_require__(163);

	/*<replacement>*/
	var util = __webpack_require__(110);
	util.inherits = __webpack_require__(46);
	/*</replacement>*/

	util.inherits(Transform, Duplex);

	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined) stream.push(data);

	  cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('Not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('Calling transform done when still transforming');

	  return stream.push(null);
	}

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	'use strict';

	module.exports = PassThrough;

	var Transform = __webpack_require__(167);

	/*<replacement>*/
	var util = __webpack_require__(110);
	util.inherits = __webpack_require__(46);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var transport = __webpack_require__(147);

	var util = __webpack_require__(10);
	var utils = __webpack_require__(149).utils;
	var OffsetBuffer = __webpack_require__(170);
	var Transform = __webpack_require__(156).Transform;

	function Parser(options) {
	  Transform.call(this, {
	    readableObjectMode: true
	  });

	  this.buffer = new OffsetBuffer();
	  this.partial = false;
	  this.waiting = 0;

	  this.window = options.window;

	  this.version = null;
	  this.decompress = null;
	  this.dead = false;
	}
	module.exports = Parser;
	util.inherits(Parser, Transform);

	Parser.prototype.error = utils.error;

	Parser.prototype.kill = function kill() {
	  this.dead = true;
	};

	Parser.prototype._transform = function transform(data, encoding, cb) {
	  if (!this.dead)
	    this.buffer.push(data);

	  this._consume(cb);
	};

	Parser.prototype._consume = function _consume(cb) {
	  var self = this;

	  function next(err, frame) {
	    if (err)
	      return cb(err);

	    if (Array.isArray(frame)) {
	      for (var i = 0; i < frame.length; i++)
	        self.push(frame[i]);
	    } else if (frame) {
	      self.push(frame);
	    }

	    // Consume more packets
	    if (!sync)
	      return self._consume(cb);

	    process.nextTick(function() {
	      self._consume(cb);
	    });
	  }

	  if (this.dead)
	    return cb();


	  if (this.buffer.size < this.waiting) {
	    // No data at all
	    if (this.buffer.size === 0)
	      return cb();

	    // Partial DATA frame or something that we can process partially
	    if (this.partial) {
	      var partial = this.buffer.clone(this.buffer.size);
	      this.buffer.skip(partial.size);
	      this.waiting -= partial.size;

	      this.executePartial(partial, next);
	      return;
	    }

	    // We shall not do anything until we get all expected data
	    return cb();
	  }

	  var sync = true;

	  var content = this.buffer.clone(this.waiting);
	  this.buffer.skip(this.waiting);

	  this.execute(content, next);
	  sync = false;
	};

	Parser.prototype.setVersion = function setVersion(version) {
	  this.version = version;
	  this.emit('version', version);
	};

	Parser.prototype.setCompression = function setCompresion(pair) {
	  this.decompress = new transport.utils.LockStream(pair.decompress);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(5).Buffer;

	function OffsetBuffer() {
	  this.offset = 0;
	  this.size = 0;
	  this.buffers = [];
	}
	module.exports = OffsetBuffer;

	OffsetBuffer.prototype.isEmpty = function isEmpty() {
	  return this.size === 0;
	};

	OffsetBuffer.prototype.clone = function clone(size) {
	  var r = new OffsetBuffer();
	  r.offset = this.offset;
	  r.size = size;
	  r.buffers = this.buffers.slice();
	  return r;
	};

	OffsetBuffer.prototype.toChunks = function toChunks() {
	  if (this.size === 0)
	    return [];

	  // We are going to slice it anyway
	  if (this.offset !== 0) {
	    this.buffers[0] = this.buffers[0].slice(this.offset);
	    this.offset = 0;
	  }

	  var chunks = [ ];
	  var off = 0;
	  for (var i = 0; off <= this.size && i < this.buffers.length; i++) {
	    var buf = this.buffers[i];
	    off += buf.length;

	    // Slice off last buffer
	    if (off > this.size) {
	      buf = buf.slice(0, buf.length - (off - this.size));
	      this.buffers[i] = buf;
	    }

	    chunks.push(buf);
	  }

	  // If some buffers were skipped - trim length
	  if (i < this.buffers.length)
	    this.buffers.length = i;

	  return chunks;
	};

	OffsetBuffer.prototype.toString = function toString(enc) {
	  return this.toChunks().map(function(c) {
	    return c.toString(enc);
	  }).join('');
	};

	OffsetBuffer.prototype.use = function use(buf, off, n) {
	  this.buffers = [ buf ];
	  this.offset = off;
	  this.size = n;
	};

	OffsetBuffer.prototype.push = function push(data) {
	  // Ignore empty writes
	  if (data.length === 0)
	    return;

	  this.size += data.length;
	  this.buffers.push(data);
	};

	OffsetBuffer.prototype.has = function has(n) {
	  return this.size >= n;
	};

	OffsetBuffer.prototype.skip = function skip(n) {
	  if (this.size === 0)
	    return;

	  this.size -= n;

	  // Fast case, skip bytes in a first buffer
	  if (this.offset + n < this.buffers[0].length) {
	    this.offset += n;
	    return;
	  }

	  var left = n - (this.buffers[0].length - this.offset);
	  this.offset = 0;

	  for (var shift = 1; left > 0 && shift < this.buffers.length; shift++) {
	    var buf = this.buffers[shift];
	    if (buf.length > left) {
	      this.offset = left;
	      break;
	    }
	    left -= buf.length;
	  }
	  this.buffers = this.buffers.slice(shift);
	};

	OffsetBuffer.prototype.copy = function copy(target, targetOff, off, n) {
	  if (this.size === 0)
	    return;
	  if (off !== 0)
	    throw new Error('Unsupported offset in .copy()');

	  var toff = targetOff;
	  var first = this.buffers[0];
	  var toCopy = Math.min(n, first.length - this.offset);
	  first.copy(target, toff, this.offset, this.offset + toCopy);

	  toff += toCopy;
	  var left = n - toCopy;
	  for (var i = 1; left > 0 && i < this.buffers.length; i++) {
	    var buf = this.buffers[i];
	    var toCopy = Math.min(left, buf.length);

	    buf.copy(target, toff, 0, toCopy);

	    toff += toCopy;
	    left -= toCopy;
	  }
	};

	OffsetBuffer.prototype.take = function take(n) {
	  if (n === 0)
	    return new Buffer(0);

	  this.size -= n;

	  // Fast cases
	  var first = this.buffers[0].length - this.offset;
	  if (first === n) {
	    var r = this.buffers.shift();
	    if (this.offset !== 0) {
	      r = r.slice(this.offset);
	      this.offset = 0;
	    }
	    return r;
	  } else if (first > n) {
	    var r = this.buffers[0].slice(this.offset, this.offset + n);
	    this.offset += n;
	    return r;
	  }

	  // Allocate and fill buffer
	  var out = new Buffer(n);
	  var toOff = 0;
	  var startOff = this.offset;
	  for (var i = 0; toOff !== n && i < this.buffers.length; i++) {
	    var buf = this.buffers[i];
	    var toCopy = Math.min(buf.length - startOff, n - toOff);

	    buf.copy(out, toOff, startOff, startOff + toCopy);
	    if (startOff + toCopy < buf.length) {
	      this.offset = startOff + toCopy;
	      break;
	    } else {
	      toOff += toCopy;
	      startOff = 0;
	    }
	  }

	  this.buffers = this.buffers.slice(i);
	  if (this.buffers.length === 0)
	    this.offset = 0;

	  return out;
	};

	OffsetBuffer.prototype.peekUInt8 = function peekUInt8() {
	  return this.buffers[0][this.offset];
	};

	OffsetBuffer.prototype.readUInt8 = function readUInt8() {
	  this.size -= 1;
	  var first = this.buffers[0];
	  var r = first[this.offset];
	  if (++this.offset === first.length) {
	    this.offset = 0;
	    this.buffers.shift();
	  }

	  return r;
	};

	OffsetBuffer.prototype.readUInt16LE = function readUInt16LE() {
	  var first = this.buffers[0];
	  this.size -= 2;

	  var r;
	  var shift;

	  // Fast case - first buffer has all bytes
	  if (first.length - this.offset >= 2) {
	    r = first.readUInt16LE(this.offset, true);
	    shift = 0;
	    this.offset += 2;

	  // One byte here - one byte there
	  } else {
	    r = first[this.offset] | (this.buffers[1][0] << 8);
	    shift = 1;
	    this.offset = 1;
	  }

	  if (this.offset === this.buffers[shift].length) {
	    this.offset = 0;
	    shift++;
	  }
	  if (shift !== 0)
	    this.buffers = this.buffers.slice(shift);

	  return r;
	};

	OffsetBuffer.prototype.readUInt24LE = function readUInt24LE() {
	  var first = this.buffers[0];

	  var r;
	  var shift;
	  var firstHas = first.length - this.offset;

	  // Fast case - first buffer has all bytes
	  if (firstHas >= 3) {
	    r = first.readUInt16LE(this.offset, true) | (first[this.offset + 2] << 16);
	    shift = 0;
	    this.offset += 3;

	  // First buffer has 2 of 3 bytes
	  } else if (firstHas >= 2) {
	    r = first.readUInt16LE(this.offset, true) | (this.buffers[1][0] << 16);
	    shift = 1;
	    this.offset = 1;

	  // Slow case: First buffer has 1 of 3 bytes
	  } else {
	    r = first[this.offset];
	    this.offset = 0;
	    this.buffers.shift();
	    this.size -= 1;

	    r |= this.readUInt16LE() << 8;
	    return r;
	  }

	  this.size -= 3;
	  if (this.offset === this.buffers[shift].length) {
	    this.offset = 0;
	    shift++;
	  }
	  if (shift !== 0)
	    this.buffers = this.buffers.slice(shift);

	  return r;
	};

	OffsetBuffer.prototype.readUInt32LE = function readUInt32LE() {
	  var first = this.buffers[0];

	  var r;
	  var shift;
	  var firstHas = first.length - this.offset;

	  // Fast case - first buffer has all bytes
	  if (firstHas >= 4) {
	    r = first.readUInt32LE(this.offset, true);
	    shift = 0;
	    this.offset += 4;

	  // First buffer has 3 of 4 bytes
	  } else if (firstHas >= 3) {
	    r = (first.readUInt16LE(this.offset, true) |
	         (first[this.offset + 2] << 16)) +
	        (this.buffers[1][0] * 0x1000000);
	    shift = 1;
	    this.offset = 1;

	  // Slow case: First buffer has 2 of 4 bytes
	  } else if (firstHas >= 2) {
	    r = first.readUInt16LE(this.offset, true);
	    this.offset = 0;
	    this.buffers.shift();
	    this.size -= 2;

	    r += this.readUInt16LE() * 0x10000;
	    return r;

	  // Slow case: First buffer has 1 of 4 bytes
	  } else {
	    r = first[this.offset];
	    this.offset = 0;
	    this.buffers.shift();
	    this.size -= 1;

	    r += this.readUInt24LE() * 0x100;
	    return r;
	  }

	  this.size -= 4;
	  if (this.offset === this.buffers[shift].length) {
	    this.offset = 0;
	    shift++;
	  }
	  if (shift !== 0)
	    this.buffers = this.buffers.slice(shift);

	  return r;
	};

	OffsetBuffer.prototype.readUInt16BE = function readUInt16BE() {
	  var r = this.readUInt16LE();

	  return ((r & 0xff) << 8) | (r >> 8);
	};

	OffsetBuffer.prototype.readUInt24BE = function readUInt24BE() {
	  var r = this.readUInt24LE();

	  return ((r & 0xff) << 16) | (((r >> 8) & 0xff) << 8) | (r >> 16);
	};

	OffsetBuffer.prototype.readUInt32BE = function readUInt32BE() {
	  var r = this.readUInt32LE();

	  return (((r & 0xff) << 24) |
	          (((r >>> 8) & 0xff) << 16) |
	          (((r >>> 16) & 0xff) << 8) |
	          (r >>> 24)) >>> 0;
	};

	// Signed number APIs

	function signedInt8(num) {
	  if (num >= 0x80)
	    return -(0xff ^ num) - 1;
	  else
	    return num;
	}

	OffsetBuffer.prototype.peekInt8 = function peekInt8() {
	  return signedInt8(this.peekUInt8());
	};

	OffsetBuffer.prototype.readInt8 = function readInt8() {
	  return signedInt8(this.readUInt8());
	};

	function signedInt16(num) {
	  if (num >= 0x8000)
	    return -(0xffff ^ num) - 1;
	  else
	    return num;
	}

	OffsetBuffer.prototype.readInt16BE = function readInt16BE() {
	  return signedInt16(this.readUInt16BE());
	};

	OffsetBuffer.prototype.readInt16LE = function readInt16LE() {
	  return signedInt16(this.readUInt16LE());
	};

	function signedInt24(num) {
	  if (num >= 0x800000)
	    return -(0xffffff ^ num) - 1;
	  else
	    return num;
	}

	OffsetBuffer.prototype.readInt24BE = function readInt24BE() {
	  return signedInt24(this.readUInt24BE());
	};

	OffsetBuffer.prototype.readInt24LE = function readInt24LE() {
	  return signedInt24(this.readUInt24LE());
	};

	function signedInt32(num) {
	  if (num >= 0x80000000)
	    return -(0xffffffff ^ num) - 1;
	  else
	    return num;
	}

	OffsetBuffer.prototype.readInt32BE = function readInt32BE() {
	  return signedInt32(this.readUInt32BE());
	};

	OffsetBuffer.prototype.readInt32LE = function readInt32LE() {
	  return signedInt32(this.readUInt32LE());
	};


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var util = __webpack_require__(10);

	var transport = __webpack_require__(147);
	var base = __webpack_require__(149);
	var Scheduler = base.Scheduler;

	function Framer(options) {
	  Scheduler.call(this);

	  this.version = null;
	  this.compress = null;
	  this.window = options.window;
	  this.timeout = options.timeout;

	  // Wait for `enablePush`
	  this.pushEnabled = null;
	}
	util.inherits(Framer, Scheduler);
	module.exports = Framer;

	Framer.prototype.setVersion = function setVersion(version) {
	  this.version = version;
	  this.emit('version');
	};

	Framer.prototype.setCompression = function setCompresion(pair) {
	  this.compress = new transport.utils.LockStream(pair.compress);
	};

	Framer.prototype.enablePush = function enablePush(enable) {
	  this.pushEnabled = enable;
	  this.emit('_pushEnabled');
	};

	Framer.prototype._checkPush = function _checkPush(callback) {
	  if (this.pushEnabled === null) {
	    this.once('_pushEnabled', function() {
	      this._checkPush(callback);
	    });
	    return;
	  }

	  var self = this;
	  var err = null;
	  if (!this.pushEnabled)
	    err = new Error('PUSH_PROMISE disabled by other side');
	  process.nextTick(function() {
	    return callback(err);
	  });
	};

	Framer.prototype._resetTimeout = function _resetTimeout() {
	  if (this.timeout)
	    this.timeout.reset();
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.name = 'spdy';

	exports.dictionary = __webpack_require__(173);
	exports.constants = __webpack_require__(174);
	exports.parser = __webpack_require__(175);
	exports.framer = __webpack_require__(176);
	exports.compressionPool = __webpack_require__(179);


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Buffer = __webpack_require__(5).Buffer;

	var dictionary = {};
	module.exports = dictionary;

	dictionary[2] = new Buffer([
	  'optionsgetheadpostputdeletetraceacceptaccept-charsetaccept-encodingaccept-',
	  'languageauthorizationexpectfromhostif-modified-sinceif-matchif-none-matchi',
	  'f-rangeif-unmodifiedsincemax-forwardsproxy-authorizationrangerefererteuser',
	  '-agent10010120020120220320420520630030130230330430530630740040140240340440',
	  '5406407408409410411412413414415416417500501502503504505accept-rangesageeta',
	  'glocationproxy-authenticatepublicretry-afterservervarywarningwww-authentic',
	  'ateallowcontent-basecontent-encodingcache-controlconnectiondatetrailertran',
	  'sfer-encodingupgradeviawarningcontent-languagecontent-lengthcontent-locati',
	  'oncontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookieMo',
	  'ndayTuesdayWednesdayThursdayFridaySaturdaySundayJanFebMarAprMayJunJulAugSe',
	  'pOctNovDecchunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplic',
	  'ation/xhtmltext/plainpublicmax-agecharset=iso-8859-1utf-8gzipdeflateHTTP/1',
	  '.1statusversionurl\x00'
	].join(''));

	dictionary[3] = new Buffer([
	  0x00, 0x00, 0x00, 0x07, 0x6f, 0x70, 0x74, 0x69,  // ....opti
	  0x6f, 0x6e, 0x73, 0x00, 0x00, 0x00, 0x04, 0x68,  // ons....h
	  0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x04, 0x70,  // ead....p
	  0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x03, 0x70,  // ost....p
	  0x75, 0x74, 0x00, 0x00, 0x00, 0x06, 0x64, 0x65,  // ut....de
	  0x6c, 0x65, 0x74, 0x65, 0x00, 0x00, 0x00, 0x05,  // lete....
	  0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00,  // trace...
	  0x06, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x00,  // .accept.
	  0x00, 0x00, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x70,  // ...accep
	  0x74, 0x2d, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,  // t-charse
	  0x74, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63,  // t....acc
	  0x65, 0x70, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f,  // ept-enco
	  0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x0f,  // ding....
	  0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x6c,  // accept-l
	  0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x00,  // anguage.
	  0x00, 0x00, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x70,  // ...accep
	  0x74, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73,  // t-ranges
	  0x00, 0x00, 0x00, 0x03, 0x61, 0x67, 0x65, 0x00,  // ....age.
	  0x00, 0x00, 0x05, 0x61, 0x6c, 0x6c, 0x6f, 0x77,  // ...allow
	  0x00, 0x00, 0x00, 0x0d, 0x61, 0x75, 0x74, 0x68,  // ....auth
	  0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,  // orizatio
	  0x6e, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x61, 0x63,  // n....cac
	  0x68, 0x65, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72,  // he-contr
	  0x6f, 0x6c, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x6f,  // ol....co
	  0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,  // nnection
	  0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74,  // ....cont
	  0x65, 0x6e, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65,  // ent-base
	  0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74,  // ....cont
	  0x65, 0x6e, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f,  // ent-enco
	  0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10,  // ding....
	  0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d,  // content-
	  0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,  // language
	  0x00, 0x00, 0x00, 0x0e, 0x63, 0x6f, 0x6e, 0x74,  // ....cont
	  0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67,  // ent-leng
	  0x74, 0x68, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f,  // th....co
	  0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x6f,  // ntent-lo
	  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,  // cation..
	  0x00, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,  // ..conten
	  0x74, 0x2d, 0x6d, 0x64, 0x35, 0x00, 0x00, 0x00,  // t-md5...
	  0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,  // .content
	  0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00,  // -range..
	  0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,  // ..conten
	  0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00,  // t-type..
	  0x00, 0x04, 0x64, 0x61, 0x74, 0x65, 0x00, 0x00,  // ..date..
	  0x00, 0x04, 0x65, 0x74, 0x61, 0x67, 0x00, 0x00,  // ..etag..
	  0x00, 0x06, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,  // ..expect
	  0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x70, 0x69,  // ....expi
	  0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x04, 0x66,  // res....f
	  0x72, 0x6f, 0x6d, 0x00, 0x00, 0x00, 0x04, 0x68,  // rom....h
	  0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x08, 0x69,  // ost....i
	  0x66, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00,  // f-match.
	  0x00, 0x00, 0x11, 0x69, 0x66, 0x2d, 0x6d, 0x6f,  // ...if-mo
	  0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73,  // dified-s
	  0x69, 0x6e, 0x63, 0x65, 0x00, 0x00, 0x00, 0x0d,  // ince....
	  0x69, 0x66, 0x2d, 0x6e, 0x6f, 0x6e, 0x65, 0x2d,  // if-none-
	  0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00,  // match...
	  0x08, 0x69, 0x66, 0x2d, 0x72, 0x61, 0x6e, 0x67,  // .if-rang
	  0x65, 0x00, 0x00, 0x00, 0x13, 0x69, 0x66, 0x2d,  // e....if-
	  0x75, 0x6e, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69,  // unmodifi
	  0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65,  // ed-since
	  0x00, 0x00, 0x00, 0x0d, 0x6c, 0x61, 0x73, 0x74,  // ....last
	  0x2d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65,  // -modifie
	  0x64, 0x00, 0x00, 0x00, 0x08, 0x6c, 0x6f, 0x63,  // d....loc
	  0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00,  // ation...
	  0x0c, 0x6d, 0x61, 0x78, 0x2d, 0x66, 0x6f, 0x72,  // .max-for
	  0x77, 0x61, 0x72, 0x64, 0x73, 0x00, 0x00, 0x00,  // wards...
	  0x06, 0x70, 0x72, 0x61, 0x67, 0x6d, 0x61, 0x00,  // .pragma.
	  0x00, 0x00, 0x12, 0x70, 0x72, 0x6f, 0x78, 0x79,  // ...proxy
	  0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,  // -authent
	  0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00,  // icate...
	  0x13, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61,  // .proxy-a
	  0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61,  // uthoriza
	  0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x05,  // tion....
	  0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00,  // range...
	  0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72,  // .referer
	  0x00, 0x00, 0x00, 0x0b, 0x72, 0x65, 0x74, 0x72,  // ....retr
	  0x79, 0x2d, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00,  // y-after.
	  0x00, 0x00, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65,  // ...serve
	  0x72, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x00,  // r....te.
	  0x00, 0x00, 0x07, 0x74, 0x72, 0x61, 0x69, 0x6c,  // ...trail
	  0x65, 0x72, 0x00, 0x00, 0x00, 0x11, 0x74, 0x72,  // er....tr
	  0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2d, 0x65,  // ansfer-e
	  0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00,  // ncoding.
	  0x00, 0x00, 0x07, 0x75, 0x70, 0x67, 0x72, 0x61,  // ...upgra
	  0x64, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x75, 0x73,  // de....us
	  0x65, 0x72, 0x2d, 0x61, 0x67, 0x65, 0x6e, 0x74,  // er-agent
	  0x00, 0x00, 0x00, 0x04, 0x76, 0x61, 0x72, 0x79,  // ....vary
	  0x00, 0x00, 0x00, 0x03, 0x76, 0x69, 0x61, 0x00,  // ....via.
	  0x00, 0x00, 0x07, 0x77, 0x61, 0x72, 0x6e, 0x69,  // ...warni
	  0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, 0x77, 0x77,  // ng....ww
	  0x77, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e,  // w-authen
	  0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00,  // ticate..
	  0x00, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,  // ..method
	  0x00, 0x00, 0x00, 0x03, 0x67, 0x65, 0x74, 0x00,  // ....get.
	  0x00, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,  // ...statu
	  0x73, 0x00, 0x00, 0x00, 0x06, 0x32, 0x30, 0x30,  // s....200
	  0x20, 0x4f, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x76,  // .OK....v
	  0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00,  // ersion..
	  0x00, 0x08, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31,  // ..HTTP.1
	  0x2e, 0x31, 0x00, 0x00, 0x00, 0x03, 0x75, 0x72,  // .1....ur
	  0x6c, 0x00, 0x00, 0x00, 0x06, 0x70, 0x75, 0x62,  // l....pub
	  0x6c, 0x69, 0x63, 0x00, 0x00, 0x00, 0x0a, 0x73,  // lic....s
	  0x65, 0x74, 0x2d, 0x63, 0x6f, 0x6f, 0x6b, 0x69,  // et-cooki
	  0x65, 0x00, 0x00, 0x00, 0x0a, 0x6b, 0x65, 0x65,  // e....kee
	  0x70, 0x2d, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x00,  // p-alive.
	  0x00, 0x00, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69,  // ...origi
	  0x6e, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x32,  // n1001012
	  0x30, 0x31, 0x32, 0x30, 0x32, 0x32, 0x30, 0x35,  // 01202205
	  0x32, 0x30, 0x36, 0x33, 0x30, 0x30, 0x33, 0x30,  // 20630030
	  0x32, 0x33, 0x30, 0x33, 0x33, 0x30, 0x34, 0x33,  // 23033043
	  0x30, 0x35, 0x33, 0x30, 0x36, 0x33, 0x30, 0x37,  // 05306307
	  0x34, 0x30, 0x32, 0x34, 0x30, 0x35, 0x34, 0x30,  // 40240540
	  0x36, 0x34, 0x30, 0x37, 0x34, 0x30, 0x38, 0x34,  // 64074084
	  0x30, 0x39, 0x34, 0x31, 0x30, 0x34, 0x31, 0x31,  // 09410411
	  0x34, 0x31, 0x32, 0x34, 0x31, 0x33, 0x34, 0x31,  // 41241341
	  0x34, 0x34, 0x31, 0x35, 0x34, 0x31, 0x36, 0x34,  // 44154164
	  0x31, 0x37, 0x35, 0x30, 0x32, 0x35, 0x30, 0x34,  // 17502504
	  0x35, 0x30, 0x35, 0x32, 0x30, 0x33, 0x20, 0x4e,  // 505203.N
	  0x6f, 0x6e, 0x2d, 0x41, 0x75, 0x74, 0x68, 0x6f,  // on-Autho
	  0x72, 0x69, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65,  // ritative
	  0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61,  // .Informa
	  0x74, 0x69, 0x6f, 0x6e, 0x32, 0x30, 0x34, 0x20,  // tion204.
	  0x4e, 0x6f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65,  // No.Conte
	  0x6e, 0x74, 0x33, 0x30, 0x31, 0x20, 0x4d, 0x6f,  // nt301.Mo
	  0x76, 0x65, 0x64, 0x20, 0x50, 0x65, 0x72, 0x6d,  // ved.Perm
	  0x61, 0x6e, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x34,  // anently4
	  0x30, 0x30, 0x20, 0x42, 0x61, 0x64, 0x20, 0x52,  // 00.Bad.R
	  0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x34, 0x30,  // equest40
	  0x31, 0x20, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68,  // 1.Unauth
	  0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x34, 0x30,  // orized40
	  0x33, 0x20, 0x46, 0x6f, 0x72, 0x62, 0x69, 0x64,  // 3.Forbid
	  0x64, 0x65, 0x6e, 0x34, 0x30, 0x34, 0x20, 0x4e,  // den404.N
	  0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64,  // ot.Found
	  0x35, 0x30, 0x30, 0x20, 0x49, 0x6e, 0x74, 0x65,  // 500.Inte
	  0x72, 0x6e, 0x61, 0x6c, 0x20, 0x53, 0x65, 0x72,  // rnal.Ser
	  0x76, 0x65, 0x72, 0x20, 0x45, 0x72, 0x72, 0x6f,  // ver.Erro
	  0x72, 0x35, 0x30, 0x31, 0x20, 0x4e, 0x6f, 0x74,  // r501.Not
	  0x20, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65,  // .Impleme
	  0x6e, 0x74, 0x65, 0x64, 0x35, 0x30, 0x33, 0x20,  // nted503.
	  0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,  // Service.
	  0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61,  // Unavaila
	  0x62, 0x6c, 0x65, 0x4a, 0x61, 0x6e, 0x20, 0x46,  // bleJan.F
	  0x65, 0x62, 0x20, 0x4d, 0x61, 0x72, 0x20, 0x41,  // eb.Mar.A
	  0x70, 0x72, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x4a,  // pr.May.J
	  0x75, 0x6e, 0x20, 0x4a, 0x75, 0x6c, 0x20, 0x41,  // un.Jul.A
	  0x75, 0x67, 0x20, 0x53, 0x65, 0x70, 0x74, 0x20,  // ug.Sept.
	  0x4f, 0x63, 0x74, 0x20, 0x4e, 0x6f, 0x76, 0x20,  // Oct.Nov.
	  0x44, 0x65, 0x63, 0x20, 0x30, 0x30, 0x3a, 0x30,  // Dec.00.0
	  0x30, 0x3a, 0x30, 0x30, 0x20, 0x4d, 0x6f, 0x6e,  // 0.00.Mon
	  0x2c, 0x20, 0x54, 0x75, 0x65, 0x2c, 0x20, 0x57,  // ..Tue..W
	  0x65, 0x64, 0x2c, 0x20, 0x54, 0x68, 0x75, 0x2c,  // ed..Thu.
	  0x20, 0x46, 0x72, 0x69, 0x2c, 0x20, 0x53, 0x61,  // .Fri..Sa
	  0x74, 0x2c, 0x20, 0x53, 0x75, 0x6e, 0x2c, 0x20,  // t..Sun..
	  0x47, 0x4d, 0x54, 0x63, 0x68, 0x75, 0x6e, 0x6b,  // GMTchunk
	  0x65, 0x64, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f,  // ed.text.
	  0x68, 0x74, 0x6d, 0x6c, 0x2c, 0x69, 0x6d, 0x61,  // html.ima
	  0x67, 0x65, 0x2f, 0x70, 0x6e, 0x67, 0x2c, 0x69,  // ge.png.i
	  0x6d, 0x61, 0x67, 0x65, 0x2f, 0x6a, 0x70, 0x67,  // mage.jpg
	  0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x67,  // .image.g
	  0x69, 0x66, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,  // if.appli
	  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78,  // cation.x
	  0x6d, 0x6c, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,  // ml.appli
	  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78,  // cation.x
	  0x68, 0x74, 0x6d, 0x6c, 0x2b, 0x78, 0x6d, 0x6c,  // html.xml
	  0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x70, 0x6c,  // .text.pl
	  0x61, 0x69, 0x6e, 0x2c, 0x74, 0x65, 0x78, 0x74,  // ain.text
	  0x2f, 0x6a, 0x61, 0x76, 0x61, 0x73, 0x63, 0x72,  // .javascr
	  0x69, 0x70, 0x74, 0x2c, 0x70, 0x75, 0x62, 0x6c,  // ipt.publ
	  0x69, 0x63, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74,  // icprivat
	  0x65, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67, 0x65,  // emax-age
	  0x3d, 0x67, 0x7a, 0x69, 0x70, 0x2c, 0x64, 0x65,  // .gzip.de
	  0x66, 0x6c, 0x61, 0x74, 0x65, 0x2c, 0x73, 0x64,  // flate.sd
	  0x63, 0x68, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,  // chcharse
	  0x74, 0x3d, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x63,  // t.utf-8c
	  0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x69,  // harset.i
	  0x73, 0x6f, 0x2d, 0x38, 0x38, 0x35, 0x39, 0x2d,  // so-8859-
	  0x31, 0x2c, 0x75, 0x74, 0x66, 0x2d, 0x2c, 0x2a,  // 1.utf-..
	  0x2c, 0x65, 0x6e, 0x71, 0x3d, 0x30, 0x2e         // .enq.0.
	]);

	dictionary[3.1] = dictionary[3];


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var transport = __webpack_require__(147);
	var base = transport.protocol.base;

	exports.FRAME_HEADER_SIZE = 8;

	exports.PING_OPAQUE_SIZE = 4;

	exports.MAX_CONCURRENT_STREAMS = Infinity;
	exports.DEFAULT_MAX_HEADER_LIST_SIZE = Infinity;

	exports.DEFAULT_WEIGHT = 16;

	exports.frameType = {
	  SYN_STREAM: 1,
	  SYN_REPLY: 2,
	  RST_STREAM: 3,
	  SETTINGS: 4,
	  PING: 6,
	  GOAWAY: 7,
	  HEADERS: 8,
	  WINDOW_UPDATE: 9,

	  // Custom
	  X_FORWARDED_FOR: 0xf000
	};

	exports.flags = {
	  FLAG_FIN: 0x01,
	  FLAG_COMPRESSED: 0x02,
	  FLAG_UNIDIRECTIONAL: 0x02
	};

	exports.error = {
	  PROTOCOL_ERROR: 1,
	  INVALID_STREAM: 2,
	  REFUSED_STREAM: 3,
	  UNSUPPORTED_VERSION: 4,
	  CANCEL: 5,
	  INTERNAL_ERROR: 6,
	  FLOW_CONTROL_ERROR: 7,
	  STREAM_IN_USE: 8,
	  // STREAM_ALREADY_CLOSED: 9
	  STREAM_CLOSED: 9,
	  INVALID_CREDENTIALS: 10,
	  FRAME_TOO_LARGE: 11
	};
	exports.errorByCode = base.utils.reverse(exports.error);

	exports.settings = {
	  FLAG_SETTINGS_PERSIST_VALUE: 1,
	  FLAG_SETTINGS_PERSISTED: 2,

	  SETTINGS_UPLOAD_BANDWIDTH: 1,
	  SETTINGS_DOWNLOAD_BANDWIDTH: 2,
	  SETTINGS_ROUND_TRIP_TIME: 3,
	  SETTINGS_MAX_CONCURRENT_STREAMS: 4,
	  SETTINGS_CURRENT_CWND: 5,
	  SETTINGS_DOWNLOAD_RETRANS_RATE: 6,
	  SETTINGS_INITIAL_WINDOW_SIZE: 7,
	  SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE: 8
	};

	exports.settingsIndex = [
	  null,

	  'upload_bandwidth',
	  'download_bandwidth',
	  'round_trip_time',
	  'max_concurrent_streams',
	  'current_cwnd',
	  'download_retrans_rate',
	  'initial_window_size',
	  'client_certificate_vector_size'
	];

	exports.DEFAULT_WINDOW = 64 * 1024;
	exports.MAX_INITIAL_WINDOW_SIZE = 2147483647;

	exports.goaway = {
	  OK: 0,
	  PROTOCOL_ERROR: 1,
	  INTERNAL_ERROR: 2
	};
	exports.goawayByCode = base.utils.reverse(exports.goaway);

	exports.statusReason = {
	  100 : 'Continue',
	  101 : 'Switching Protocols',
	  102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
	  200 : 'OK',
	  201 : 'Created',
	  202 : 'Accepted',
	  203 : 'Non-Authoritative Information',
	  204 : 'No Content',
	  205 : 'Reset Content',
	  206 : 'Partial Content',
	  207 : 'Multi-Status',               // RFC 4918
	  300 : 'Multiple Choices',
	  301 : 'Moved Permanently',
	  302 : 'Moved Temporarily',
	  303 : 'See Other',
	  304 : 'Not Modified',
	  305 : 'Use Proxy',
	  307 : 'Temporary Redirect',
	  308 : 'Permanent Redirect',         // RFC 7238
	  400 : 'Bad Request',
	  401 : 'Unauthorized',
	  402 : 'Payment Required',
	  403 : 'Forbidden',
	  404 : 'Not Found',
	  405 : 'Method Not Allowed',
	  406 : 'Not Acceptable',
	  407 : 'Proxy Authentication Required',
	  408 : 'Request Time-out',
	  409 : 'Conflict',
	  410 : 'Gone',
	  411 : 'Length Required',
	  412 : 'Precondition Failed',
	  413 : 'Request Entity Too Large',
	  414 : 'Request-URI Too Large',
	  415 : 'Unsupported Media Type',
	  416 : 'Requested Range Not Satisfiable',
	  417 : 'Expectation Failed',
	  418 : 'I\'m a teapot',              // RFC 2324
	  422 : 'Unprocessable Entity',       // RFC 4918
	  423 : 'Locked',                     // RFC 4918
	  424 : 'Failed Dependency',          // RFC 4918
	  425 : 'Unordered Collection',       // RFC 4918
	  426 : 'Upgrade Required',           // RFC 2817
	  428 : 'Precondition Required',      // RFC 6585
	  429 : 'Too Many Requests',          // RFC 6585
	  431 : 'Request Header Fields Too Large',// RFC 6585
	  500 : 'Internal Server Error',
	  501 : 'Not Implemented',
	  502 : 'Bad Gateway',
	  503 : 'Service Unavailable',
	  504 : 'Gateway Time-out',
	  505 : 'HTTP Version Not Supported',
	  506 : 'Variant Also Negotiates',    // RFC 2295
	  507 : 'Insufficient Storage',       // RFC 4918
	  509 : 'Bandwidth Limit Exceeded',
	  510 : 'Not Extended',               // RFC 2774
	  511 : 'Network Authentication Required' // RFC 6585
	};


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parser = exports;

	var transport = __webpack_require__(147);
	var base = transport.protocol.base;
	var utils = base.utils;
	var constants = __webpack_require__(174);

	var assert = __webpack_require__(9);
	var util = __webpack_require__(10);
	var OffsetBuffer = __webpack_require__(170);

	function Parser(options) {
	  base.Parser.call(this, options);

	  this.isServer = options.isServer;
	  this.waiting = constants.FRAME_HEADER_SIZE;
	  this.state = 'frame-head';
	  this.pendingHeader = null;
	}
	util.inherits(Parser, base.Parser);

	parser.create = function create(options) {
	  return new Parser(options);
	};

	Parser.prototype.setMaxFrameSize = function setMaxFrameSize(size) {
	  // http2-only
	};

	Parser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize(size) {
	  // http2-only
	};

	// Only for testing
	Parser.prototype.skipPreface = function skipPreface() {
	};

	Parser.prototype.execute = function execute(buffer, callback) {
	  if (this.state === 'frame-head')
	    return this.onFrameHead(buffer, callback);

	  assert(this.state === 'frame-body' && this.pendingHeader !== null);

	  var self = this;
	  var header = this.pendingHeader;
	  this.pendingHeader = null;

	  this.onFrameBody(header, buffer, function(err, frame) {
	    if (err)
	      return callback(err);

	    self.state = 'frame-head';
	    self.waiting = constants.FRAME_HEADER_SIZE;
	    self.partial = false;
	    callback(null, frame);
	  });
	};

	Parser.prototype.executePartial = function executePartial(buffer, callback) {
	  var header = this.pendingHeader;

	  if (this.window)
	    this.window.recv.update(-buffer.size);

	  // DATA frame
	  callback(null, {
	    type: 'DATA',
	    id: header.id,

	    // Partial DATA can't be FIN
	    fin: false,
	    data: buffer.take(buffer.size)
	  });
	};

	Parser.prototype.onFrameHead = function onFrameHead(buffer, callback) {
	  var header = {
	    control: (buffer.peekUInt8() & 0x80) === 0x80 ? true : false,
	    version: null,
	    type: null,
	    id: null,
	    flags: null,
	    length: null
	  };

	  if (header.control) {
	    header.version = buffer.readUInt16BE() & 0x7fff;
	    header.type = buffer.readUInt16BE();
	  } else {
	    header.id = buffer.readUInt32BE(0) & 0x7fffffff;
	  }
	  header.flags = buffer.readUInt8();
	  header.length = buffer.readUInt24BE();

	  if (this.version === null && header.control) {
	    // TODO(indutny): do ProtocolError here and in the rest of errors
	    if (header.version !== 2 && header.version !== 3)
	      return callback(new Error('Unsupported SPDY version: ' + header.version));
	    this.setVersion(header.version);
	  }

	  this.state = 'frame-body';
	  this.waiting = header.length;
	  this.pendingHeader = header;
	  this.partial = !header.control;

	  callback(null, null);
	};

	Parser.prototype.onFrameBody = function onFrameBody(header, buffer, callback) {
	  // Data frame
	  if (!header.control) {
	    // Count received bytes
	    if (this.window)
	      this.window.recv.update(-buffer.size);

	    // No support for compressed DATA
	    if ((header.flags & constants.flags.FLAG_COMPRESSED) !== 0)
	      return callback(new Error('DATA compression not supported'));

	    if (header.id === 0) {
	      return callback(this.error(constants.error.PROTOCOL_ERROR,
	                                 'Invalid stream id for DATA'));
	    }

	    return callback(null, {
	      type: 'DATA',
	      id: header.id,
	      fin: (header.flags & constants.flags.FLAG_FIN) !== 0,
	      data: buffer.take(buffer.size)
	    });
	  }

	  // SYN_STREAM or SYN_REPLY
	  if (header.type === 0x01 || header.type === 0x02)
	    this.onSynHeadFrame(header.type, header.flags, buffer, callback);
	  // RST_STREAM
	  else if (header.type === 0x03)
	    this.onRSTFrame(buffer, callback);
	  // SETTINGS
	  else if (header.type === 0x04)
	    this.onSettingsFrame(buffer, callback);
	  else if (header.type === 0x05)
	    callback(null, { type: 'NOOP' });
	  // PING
	  else if (header.type === 0x06)
	    this.onPingFrame(buffer, callback);
	  // GOAWAY
	  else if (header.type === 0x07)
	    this.onGoawayFrame(buffer, callback);
	  // HEADERS
	  else if (header.type === 0x08)
	    this.onHeaderFrames(buffer, callback);
	  // WINDOW_UPDATE
	  else if (header.type === 0x09)
	    this.onWindowUpdateFrame(buffer, callback);
	  // X-FORWARDED
	  else if (header.type === 0xf000)
	    this.onXForwardedFrame(buffer, callback);
	  else
	    callback(null, { type: 'unknown: ' + header.type });
	};

	Parser.prototype._filterHeader = function _filterHeader(headers, name) {
	  var res = {};
	  var keys = Object.keys(headers);

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (key !== name)
	      res[key] = headers[key];
	  }

	  return res;
	};

	Parser.prototype.onSynHeadFrame = function onSynHeadFrame(type,
	                                                          flags,
	                                                          body,
	                                                          callback) {
	  var self = this;
	  var stream = type === 0x01;
	  var offset = stream ? 10 : this.version === 2 ? 6 : 4;

	  if (!body.has(offset))
	    return callback(new Error('SynHead OOB'));

	  var head = body.clone(offset);
	  body.skip(offset);
	  this.parseKVs(body, function(err, headers) {
	    if (err)
	      return callback(err);

	    if (stream &&
	        (!headers[':method'] || !headers[':path'])) {
	      return callback(new Error('Missing `:method` and/or `:path` header'));
	    }

	    var id = head.readUInt32BE() & 0x7fffffff;

	    if (id === 0) {
	      return callback(self.error(constants.error.PROTOCOL_ERROR,
	                                 'Invalid stream id for HEADERS'));
	    }

	    var associated = stream ? head.readUInt32BE() & 0x7fffffff : 0;
	    var priority = stream ? head.readUInt8() >> 5 :
	                            utils.weightToPriority(constants.DEFAULT_WEIGHT);
	    var fin = (flags & constants.flags.FLAG_FIN) !== 0;
	    var unidir = (flags & constants.flags.FLAG_UNIDIRECTIONAL) !== 0;
	    var path = headers[':path'];

	    var isPush = stream && associated !== 0;

	    var weight = utils.priorityToWeight(priority);
	    var priorityInfo = {
	      weight: weight,
	      exclusive: false,
	      parent: 0
	    };

	    if (!isPush) {
	      callback(null, {
	        type: 'HEADERS',
	        id: id,
	        priority: priorityInfo,
	        fin: fin,
	        writable: !unidir,
	        headers: headers,
	        path: path
	      });
	      return;
	    }

	    if (stream && !headers[':status'])
	      return callback(new Error('Missing `:status` header'));

	    var filteredHeaders = self._filterHeader(headers, ':status');

	    callback(null, [ {
	      type: 'PUSH_PROMISE',
	      id: associated,
	      fin: false,
	      promisedId: id,
	      headers: filteredHeaders,
	      path: path
	    }, {
	      type: 'HEADERS',
	      id: id,
	      fin: fin,
	      priority: priorityInfo,
	      writable: true,
	      path: undefined,
	      headers: {
	        ':status': headers[':status']
	      }
	    }]);
	  });
	};

	Parser.prototype.onHeaderFrames = function onHeaderFrames(body, callback) {
	  var offset = this.version === 2 ? 6 : 4;
	  if (!body.has(offset))
	    return callback(new Error('HEADERS OOB'));

	  var streamId = body.readUInt32BE() & 0x7fffffff;
	  if (this.version === 2)
	    body.skip(2);

	  this.parseKVs(body, function(err, headers) {
	    if (err)
	      return callback(err);

	    callback(null, {
	      type: 'HEADERS',
	      priority: {
	        parent: 0,
	        exclusive: false,
	        weight: constants.DEFAULT_WEIGHT
	      },
	      id: streamId,
	      fin: false,
	      writable: true,
	      path: undefined,
	      headers: headers
	    });
	  });
	};

	Parser.prototype.parseKVs = function parseKVs(buffer, callback) {
	  var self = this;

	  this.decompress.write(buffer.toChunks(), function(err, chunks) {
	    if (err)
	      return callback(err);

	    var buffer = new OffsetBuffer();
	    for (var i = 0; i < chunks.length; i++)
	      buffer.push(chunks[i]);

	    var size = self.version === 2 ? 2 : 4;
	    if (!buffer.has(size))
	      return callback(new Error('KV OOB'));

	    var count = self.version === 2 ? buffer.readUInt16BE() :
	                                     buffer.readUInt32BE();
	    var headers = {};

	    function readString() {
	      if (!buffer.has(size))
	        return null;
	      var len = self.version === 2 ? buffer.readUInt16BE() :
	                                     buffer.readUInt32BE();

	      if (!buffer.has(len))
	        return null;

	      var value = buffer.take(len);
	      return value.toString();
	    }

	    while (count > 0) {
	      var key = readString();
	      var value = readString();

	      if (key === null || value === null)
	        return callback(new Error('Headers OOB'));

	      if (self.version < 3) {
	        var isInternal = /^(method|version|url|host|scheme|status)$/.test(key);
	        if (key === 'url')
	          key = 'path';
	        if (isInternal)
	          key = ':' + key;
	      }

	      // Compatibility with HTTP2
	      if (key === ':status')
	        value = value.split(/ /g, 2)[0];

	      count--;
	      if (key === ':host')
	        key = ':authority';

	      // Skip version, not present in HTTP2
	      if (key === ':version')
	        continue;

	      value = value.split(/\0/g);
	      for (var i = 0; i < value.length; i++)
	        utils.addHeaderLine(key, value[i], headers);
	    }

	    callback(null, headers);
	  });
	};

	Parser.prototype.onRSTFrame = function onRSTFrame(body, callback) {
	  if (!body.has(8))
	    return callback(new Error('RST OOB'));

	  var frame = {
	    type: 'RST',
	    id: body.readUInt32BE() & 0x7fffffff,
	    code: constants.errorByCode[body.readUInt32BE()],
	  };

	  if (frame.id === 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for RST'));
	  }

	  if (body.size !== 0)
	    frame.extra = body.take(body.size);
	  callback(null, frame);
	};

	Parser.prototype.onSettingsFrame = function onSettingsFrame(body, callback) {
	  if (!body.has(4))
	    return callback(new Error('SETTINGS OOB'));

	  var settings = {},
	      number = body.readUInt32BE(),
	      idMap = {
	        1: 'upload_bandwidth',
	        2: 'download_bandwidth',
	        3: 'round_trip_time',
	        4: 'max_concurrent_streams',
	        5: 'current_cwnd',
	        6: 'download_retrans_rate',
	        7: 'initial_window_size',
	        8: 'client_certificate_vector_size'
	      };

	  if (!body.has(number * 8))
	    return callback(new Error('SETTINGS OOB#2'));

	  for (var i = 0; i < number; i++) {
	    var id = this.version === 2 ? body.readUInt32LE() :
	                                   body.readUInt32BE();
	    var flags = (id >> 24) & 0xff;
	    id = id & 0xffffff;

	    // Skip persisted settings
	    if (flags & 0x2)
	      continue;

	    var name = idMap[id];

	    settings[name] = body.readUInt32BE();
	  }

	  callback(null, {
	    type: 'SETTINGS',
	    settings: settings
	  });
	};

	Parser.prototype.onPingFrame = function onPingFrame(body, callback) {
	  if (!body.has(4))
	    return callback(new Error('PING OOB'));

	  var isServer = this.isServer;
	  var opaque = body.clone(body.size).take(body.size);
	  var id = body.readUInt32BE();
	  var ack = isServer ? (id % 2 === 0) : (id % 2 === 1);

	  callback(null, { type: 'PING', opaque: opaque, ack: ack });
	};

	Parser.prototype.onGoawayFrame = function onGoawayFrame(body, callback) {
	  if (!body.has(8))
	    return callback(new Error('GOAWAY OOB'));

	  callback(null, {
	    type: 'GOAWAY',
	    lastId: body.readUInt32BE() & 0x7fffffff,
	    code: constants.goawayByCode[body.readUInt32BE()]
	  });
	};

	Parser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame(body,
	                                                                    callback) {
	  if (!body.has(8))
	    return callback(new Error('WINDOW_UPDATE OOB'));

	  callback(null, {
	    type: 'WINDOW_UPDATE',
	    id: body.readUInt32BE() & 0x7fffffff,
	    delta: body.readInt32BE()
	  });
	};

	Parser.prototype.onXForwardedFrame = function onXForwardedFrame(body,
	                                                                callback) {
	  if (!body.has(4))
	    return callback(new Error('X_FORWARDED OOB'));

	  var len = body.readUInt32BE();
	  if (!body.has(len))
	    return callback(new Error('X_FORWARDED host length OOB'));

	  callback(null, {
	    type: 'X_FORWARDED_FOR',
	    host: body.take(len).toString()
	  });
	};


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var transport = __webpack_require__(147);
	var constants = __webpack_require__(172).constants;
	var base = transport.protocol.base;
	var utils = base.utils;

	var assert = __webpack_require__(9);
	var util = __webpack_require__(10);
	var Buffer = __webpack_require__(5).Buffer;
	var WriteBuffer = __webpack_require__(177);

	var debug = __webpack_require__(153)('spdy:framer');

	function Framer(options) {
	  base.Framer.call(this, options);
	}
	util.inherits(Framer, base.Framer);
	module.exports = Framer;

	Framer.create = function create(options) {
	  return new Framer(options);
	};

	Framer.prototype.setMaxFrameSize = function setMaxFrameSize(size) {
	  // http2-only
	};

	Framer.prototype.headersToDict = function headersToDict(headers,
	                                                        preprocess,
	                                                        callback) {
	  function stringify(value) {
	    if (value !== undefined) {
	      if (Array.isArray(value)) {
	        return value.join('\x00');
	      } else if (typeof value === 'string') {
	        return value;
	      } else {
	        return value.toString();
	      }
	    } else {
	      return '';
	    }
	  }

	  // Lower case of all headers keys
	  var loweredHeaders = {};
	  Object.keys(headers || {}).map(function(key) {
	    loweredHeaders[key.toLowerCase()] = headers[key];
	  });

	  // Allow outer code to add custom headers or remove something
	  if (preprocess)
	    preprocess(loweredHeaders);

	  // Transform object into kv pairs
	  var size = this.version === 2 ? 2 : 4;
	  var len = size;
	  var pairs = Object.keys(loweredHeaders).filter(function(key) {
	    var lkey = key.toLowerCase();

	    // Will be in `:host`
	    if (lkey === 'host' && this.version >= 3)
	      return false;

	    return lkey !== 'connection' && lkey !== 'keep-alive' &&
	           lkey !== 'proxy-connection' && lkey !== 'transfer-encoding';
	  }, this).map(function(key) {
	    var klen = Buffer.byteLength(key),
	        value = stringify(loweredHeaders[key]),
	        vlen = Buffer.byteLength(value);

	    len += size * 2 + klen + vlen;
	    return [klen, key, vlen, value];
	  });

	  var block = new WriteBuffer();
	  block.reserve(len);

	  if (this.version === 2)
	    block.writeUInt16BE(pairs.length);
	  else
	    block.writeUInt32BE(pairs.length);

	  pairs.forEach(function(pair) {
	    // Write key length
	    if (this.version === 2)
	      block.writeUInt16BE(pair[0]);
	    else
	      block.writeUInt32BE(pair[0]);

	    // Write key
	    block.write(pair[1]);

	    // Write value length
	    if (this.version === 2)
	      block.writeUInt16BE(pair[2]);
	    else
	      block.writeUInt32BE(pair[2]);
	    // Write value
	    block.write(pair[3]);
	  }, this);

	  assert(this.compress !== null, 'Framer version not initialized');
	  this.compress.write(block.render(), callback);
	};

	Framer.prototype._frame = function _frame(frame, body, callback) {
	  if (!this.version) {
	    this.on('version', function() {
	      this._frame(frame, body, callback);
	    });
	    return;
	  }

	  debug('id=%d type=%s', frame.id, frame.type);

	  var buffer = new WriteBuffer();

	  buffer.writeUInt16BE(0x8000 | this.version);
	  buffer.writeUInt16BE(constants.frameType[frame.type]);
	  buffer.writeUInt8(frame.flags);
	  var len = buffer.skip(3);

	  var self = this;
	  body(buffer);

	  var frameSize = buffer.size - constants.FRAME_HEADER_SIZE;
	  len.writeUInt24BE(frameSize);

	  var chunks = buffer.render();
	  var toWrite = {
	    stream: frame.id,
	    priority: false,
	    chunks: chunks,
	    callback: callback
	  };

	  this._resetTimeout();
	  this.schedule(toWrite);

	  return chunks;
	};

	Framer.prototype._synFrame = function _synFrame(frame, callback) {
	  var self = this;

	  if (!frame.path)
	    throw new Error('`path` is required frame argument');

	  function preprocess(headers) {
	    var method = frame.method || base.constants.DEFAULT_METHOD;
	    var version = frame.version || 'HTTP/1.1';
	    var scheme = frame.scheme || 'https';
	    var host = frame.host ||
	               frame.headers && frame.headers.host ||
	               base.constants.DEFAULT_HOST;

	    if (self.version === 2) {
	      headers.method = method;
	      headers.version = version;
	      headers.url = frame.path;
	      headers.scheme = scheme;
	      headers.host = host;
	      if (frame.status)
	        headers.status = frame.status;
	    } else {
	      headers[':method'] = method;
	      headers[':version'] = version;
	      headers[':path'] = frame.path;
	      headers[':scheme'] = scheme;
	      headers[':host'] = host;
	      if (frame.status)
	        headers[':status'] = frame.status;
	    }
	  }

	  this.headersToDict(frame.headers, preprocess, function(err, chunks) {
	    if (err) {
	      if (callback)
	        return callback(err);
	      else
	        return self.emit('error', err);
	    }

	    self._frame({
	      type: 'SYN_STREAM',
	      id: frame.id,
	      flags: frame.fin ? constants.flags.FLAG_FIN : 0
	    }, function(buf) {
	      buf.reserve(10);

	      buf.writeUInt32BE(frame.id & 0x7fffffff);
	      buf.writeUInt32BE(frame.associated & 0x7fffffff);

	      var weight = frame.priority && frame.priority.weight ||
	                   constants.DEFAULT_WEIGHT;

	      // We only have 3 bits for priority in SPDY, try to fit it into this
	      var priority = utils.weightToPriority(weight);
	      buf.writeUInt8(priority << 5);

	      // CREDENTIALS slot
	      buf.writeUInt8(0);

	      for (var i = 0; i < chunks.length; i++)
	        buf.copyFrom(chunks[i]);
	    }, callback);
	  });
	};

	Framer.prototype.requestFrame = function requestFrame(frame, callback) {
	  this._synFrame({
	    id: frame.id,
	    fin: frame.fin,
	    associated: 0,
	    method: frame.method,
	    version: frame.version,
	    scheme: frame.scheme,
	    host: frame.host,
	    path: frame.path,
	    priority: frame.priority,
	    headers: frame.headers
	  }, callback);
	};

	Framer.prototype.responseFrame = function responseFrame(frame, callback) {
	  var self = this;

	  var reason = frame.reason;
	  if (!reason)
	    reason = constants.statusReason[frame.status];

	  function preprocess(headers) {
	    if (self.version === 2) {
	      headers.status = frame.status + ' ' + reason;
	      headers.version = 'HTTP/1.1';
	    } else {
	      headers[':status'] = frame.status + ' ' + reason;
	      headers[':version'] = 'HTTP/1.1';
	    }
	  }

	  this.headersToDict(frame.headers, preprocess, function(err, chunks) {
	    if (err) {
	      if (callback)
	        return callback(err);
	      else
	        return self.emit('error', err);
	    }

	    self._frame({
	      type: 'SYN_REPLY',
	      id: frame.id,
	      flags: 0
	    }, function(buf) {
	      buf.reserve(self.version === 2 ? 6 : 4);

	      buf.writeUInt32BE(frame.id & 0x7fffffff);

	      // Unused data
	      if (self.version === 2)
	        buf.writeUInt16BE(0);

	      for (var i = 0; i < chunks.length; i++)
	        buf.copyFrom(chunks[i]);
	    }, callback);
	  });
	};


	Framer.prototype.pushFrame = function pushFrame(frame, callback) {
	  var self = this;

	  this._checkPush(function(err) {
	    if (err)
	      return callback(err);

	    self._synFrame({
	      id: frame.promisedId,
	      associated: frame.id,
	      method: frame.method,
	      status: frame.status || 200,
	      version: frame.version,
	      scheme: frame.scheme,
	      host: frame.host,
	      path: frame.path,
	      priority: frame.priority,

	      // Merge everything together, there is no difference in SPDY protocol
	      headers: util._extend(util._extend({}, frame.headers), frame.response)
	    }, callback);
	  });
	};

	Framer.prototype.headersFrame = function headersFrame(frame, callback) {
	  var self = this;

	  this.headersToDict(frame.headers, null, function(err, chunks) {
	    if (err) {
	      if (callback)
	        return callback(err);
	      else
	        return self.emit('error', err);
	    }

	    self._frame({
	      type: 'HEADERS',
	      id: frame.id,
	      priority: false,
	      flags: 0
	    }, function(buf) {
	      buf.reserve(4 + (self.version === 2 ? 2 : 0));
	      buf.writeUInt32BE(frame.id & 0x7fffffff);

	      // Unused data
	      if (self.version === 2)
	        buf.writeUInt16BE(0);

	      for (var i = 0; i < chunks.length; i++)
	        buf.copyFrom(chunks[i]);
	    }, callback);
	  });
	};

	Framer.prototype.dataFrame = function dataFrame(frame, callback) {
	  if (!this.version) {
	    return this.on('version', function() {
	      this.dataFrame(frame, callback);
	    });
	  }

	  debug('id=%d type=DATA', frame.id);

	  var buffer = new WriteBuffer();
	  buffer.reserve(8 + frame.data.length);

	  buffer.writeUInt32BE(frame.id & 0x7fffffff);
	  buffer.writeUInt8(frame.fin ? 0x01 : 0x0);
	  buffer.writeUInt24BE(frame.data.length);
	  buffer.copyFrom(frame.data);

	  var chunks = buffer.render();
	  var toWrite = {
	    stream: frame.id,
	    priority: frame.priority,
	    chunks: chunks,
	    callback: callback
	  };

	  var self = this;
	  this._resetTimeout();

	  var bypass = this.version < 3.1;
	  this.window.send.update(-frame.data.length, bypass ? undefined : function() {
	    self._resetTimeout();
	    self.schedule(toWrite);
	  });

	  if (bypass) {
	    this._resetTimeout();
	    this.schedule(toWrite);
	  }
	};

	Framer.prototype.pingFrame = function pingFrame(frame, callback) {
	  this._frame({
	    type: 'PING',
	    id: 0,
	    flags: 0
	  }, function(buf, callback) {
	    buf.reserve(4);

	    var opaque = frame.opaque;
	    buf.writeUInt32BE(opaque.readUInt32BE(opaque.length - 4, true));
	  }, callback);
	};

	Framer.prototype.rstFrame = function rstFrame(frame, callback) {
	  var self = this;

	  this._frame({
	    type: 'RST_STREAM',
	    id: frame.id,
	    flags: 0
	  }, function(buf) {
	    buf.reserve(8);

	    // Stream ID
	    buf.writeUInt32BE(frame.id & 0x7fffffff);
	    // Status Code
	    buf.writeUInt32BE(constants.error[frame.code]);

	    // Extra debugging information
	    if (frame.extra)
	      buf.write(frame.extra);
	  }, callback);
	};

	Framer.prototype.prefaceFrame = function prefaceFrame() {
	};

	Framer.prototype.settingsFrame = function settingsFrame(options, callback) {
	  var self = this;

	  var key = this.version + '/' + JSON.stringify(options);

	  var settings = Framer.settingsCache[key];
	  if (settings) {
	    debug('cached settings');
	    this._resetTimeout();
	    this.schedule({
	      stream: 0,
	      priority: false,
	      chunks: settings,
	      callback: callback
	    });
	    return;
	  }

	  var params = [];
	  for (var i = 0; i < constants.settingsIndex.length; i++) {
	    var name = constants.settingsIndex[i];
	    if (!name)
	      continue;

	    // value: Infinity
	    if (!isFinite(options[name]))
	      continue;

	    if (options[name] !== undefined)
	      params.push({ key: i, value: options[name] });
	  }

	  var frame = this._frame({
	    type: 'SETTINGS',
	    id: 0,
	    flags: 0
	  }, function(buf) {
	    buf.reserve(4 + 8 * params.length);

	    // Count of entries
	    buf.writeUInt32BE(params.length);

	    params.forEach(function(param) {
	      var flag = constants.settings.FLAG_SETTINGS_PERSIST_VALUE << 24;

	      if (self.version === 2)
	        buf.writeUInt32LE(flag | param.key);
	      else
	        buf.writeUInt32BE(flag | param.key);
	      buf.writeUInt32BE(param.value & 0x7fffffff);
	    });
	  }, callback);

	  Framer.settingsCache[key] = frame;
	};
	Framer.settingsCache = {};

	Framer.prototype.ackSettingsFrame = function ackSettingsFrame(callback) {
	  if (callback)
	    process.nextTick(callback);
	};

	Framer.prototype.windowUpdateFrame = function windowUpdateFrame(frame,
	                                                                callback) {
	  this._frame({
	    type: 'WINDOW_UPDATE',
	    id: frame.id,
	    flags: 0
	  }, function(buf) {
	    buf.reserve(8);

	    // ID
	    buf.writeUInt32BE(frame.id & 0x7fffffff);

	    // Delta
	    buf.writeInt32BE(frame.delta);
	  }, callback);
	};

	Framer.prototype.goawayFrame = function goawayFrame(frame, callback) {
	  this._frame({
	    type: 'GOAWAY',
	    id: 0,
	    flags: 0
	  }, function(buf) {
	    buf.reserve(8);

	    // Last-good-stream-ID
	    buf.writeUInt32BE(frame.lastId & 0x7fffffff);
	    // Status
	    buf.writeUInt32BE(constants.goaway[frame.code]);
	  }, callback);
	};

	Framer.prototype.priorityFrame = function priorityFrame(frame, callback) {
	  // No such thing in SPDY
	  if (callback)
	    process.nextTick(callback);
	};

	Framer.prototype.xForwardedFor = function xForwardedFor(frame, callback) {
	  this._frame({
	    type: 'X_FORWARDED_FOR',
	    id: 0,
	    flags: 0
	  }, function(buf) {
	    buf.writeUInt32BE(Buffer.byteLength(frame.host));
	    buf.write(frame.host);
	  }, callback);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(178);
	var Buffer = __webpack_require__(5).Buffer;

	function WBuf() {
	  this.buffers = [];
	  this.toReserve = 0;
	  this.size = 0;
	  this.maxSize = 0;
	  this.avail = 0;

	  this.last = null;
	  this.offset = 0;

	  // Used in slicing
	  this.sliceQueue = null;

	  this.forceReserve = false;

	  // Mostly a constant
	  this.reserveRate = 64;
	}
	module.exports = WBuf;

	WBuf.prototype.reserve = function reserve(n) {
	  this.toReserve += n;

	  // Force reservation of extra bytes
	  if (this.forceReserve)
	    this.toReserve = Math.max(this.toReserve, this.reserveRate);
	};

	WBuf.prototype._ensure = function _ensure(n) {
	  if (this.avail >= n)
	    return;

	  if (this.toReserve === 0)
	    this.toReserve = this.reserveRate;

	  this.toReserve = Math.max(n - this.avail, this.toReserve);

	  if (this.avail === 0)
	    this._next();
	};

	WBuf.prototype._next = function _next() {
	  var buf;
	  if (this.sliceQueue === null) {
	    // Most common case
	    buf = new Buffer(this.toReserve);
	  } else {
	    // Only for `.slice()` results
	    buf = this.sliceQueue.shift();
	    if (this.sliceQueue.length === 0)
	      this.sliceQueue = null;
	  }

	  this.toReserve = 0;

	  this.buffers.push(buf);
	  this.avail = buf.length;
	  this.offset = 0;
	  this.last = buf;
	};

	WBuf.prototype._rangeCheck = function _rangeCheck() {
	  if (this.maxSize !== 0 && this.size > this.maxSize)
	    throw new RangeError('WBuf overflow');
	};

	WBuf.prototype._move = function _move(n) {
	  this.size += n;
	  if (this.avail === 0)
	    this.last = null;

	  this._rangeCheck();
	};

	WBuf.prototype.slice = function slice(start, end) {
	  assert(0 <= start && start <= this.size);
	  assert(0 <= end && end <= this.size);

	  if (this.last === null)
	    this._next();

	  var res = new WBuf();

	  // Only last chunk is requested
	  if (start >= this.size - this.offset) {
	    res.buffers.push(this.last);
	    res.last = this.last;
	    res.offset = start - this.size + this.offset;
	    res.maxSize = end - start;
	    res.avail = res.maxSize;

	    return res;
	  }

	  var startIndex = -1;
	  var startOffset = 0;
	  var endIndex = -1;

	  // Find buffer indices
	  var offset = 0;
	  for (var i = 0; i < this.buffers.length; i++) {
	    var buf = this.buffers[i];
	    var next = offset + buf.length;

	    // Found the start
	    if (start >= offset && start <= next) {
	      startIndex = i;
	      startOffset = start - offset;
	      if (endIndex !== -1)
	        break;
	    }
	    if (end >= offset && end <= next) {
	      endIndex = i;
	      if (startIndex !== -1)
	        break;
	    }

	    offset = next;
	  }

	  res.last = this.buffers[startIndex];
	  res.offset = startOffset;
	  res.maxSize = end - start;

	  // Multi-buffer slice
	  if (startIndex < endIndex) {
	    res.sliceQueue = this.buffers.slice(startIndex + 1, endIndex + 1);

	    res.last = res.last.slice(res.offset);
	    res.offset = 0;
	  }

	  res.avail = res.last.length - res.offset;
	  res.buffers.push(res.last);

	  return res;
	};

	WBuf.prototype.skip = function skip(n) {
	  if (n === 0)
	    return this.slice(this.size, this.size);

	  this._ensure(n);

	  var left = n;
	  while (left > 0) {
	    var toSkip = Math.min(left, this.avail);
	    left -= toSkip;
	    this.size += toSkip;
	    if (toSkip === this.avail) {
	      if (left !== 0) {
	        this._next();
	      } else {
	        this.avail -= toSkip;
	        this.offset += toSkip;
	      }
	    } else {
	      this.offset += toSkip;
	      this.avail -= toSkip;
	    }
	  }

	  this._rangeCheck();

	  return this.slice(this.size - n, this.size);
	};

	WBuf.prototype.write = function write(str) {
	  var len = 0;
	  for (var i = 0; i < str.length; i++) {
	    var c = str.charCodeAt(i);
	    if (c > 255)
	      len += 2;
	    else
	      len += 1;
	  }
	  this.reserve(len);
	  for (var i = 0; i < str.length; i++) {
	    var c = str.charCodeAt(i);
	    var hi = c >>> 8;
	    var lo = c & 0xff;

	    if (hi)
	      this.writeUInt8(hi);
	    this.writeUInt8(lo);
	  }
	};

	WBuf.prototype.copyFrom = function copyFrom(buf, start, end) {
	  var off = start === undefined ? 0 : start;
	  var len = end === undefined ? buf.length : end;
	  if (off === len)
	    return;

	  this._ensure(len - off);
	  while (off < len) {
	    var toCopy = Math.min(len - off, this.avail);
	    buf.copy(this.last, this.offset, off, off + toCopy);
	    off += toCopy;
	    this.size += toCopy;
	    if (toCopy === this.avail) {
	      if (off !== len) {
	        this._next();
	      } else {
	        this.avail = 0;
	        this.offset += toCopy;
	      }
	    } else {
	      this.offset += toCopy;
	      this.avail -= toCopy;
	    }
	  }

	  this._rangeCheck();
	};

	WBuf.prototype.writeUInt8 = function writeUInt8(v) {
	  this._ensure(1);

	  this.last[this.offset++] = v;
	  this.avail--;
	  this._move(1);
	};

	WBuf.prototype.writeUInt16BE = function writeUInt16BE(v) {
	  this._ensure(2);

	  // Fast case - everything fits into the last buffer
	  if (this.avail >= 2) {
	    this.last.writeUInt16BE(v, this.offset, true);
	    this.offset += 2;
	    this.avail -= 2;

	  // One byte here, one byte there
	  } else {
	    this.last[this.offset] = (v >>> 8);
	    this._next();
	    this.last[this.offset++] = v & 0xff;
	    this.avail--;
	  }

	  this._move(2);
	};

	WBuf.prototype.writeUInt24BE = function writeUInt24BE(v) {
	  this._ensure(3);

	  // Fast case - everything fits into the last buffer
	  if (this.avail >= 3) {
	    this.last.writeUInt16BE(v >>> 8, this.offset, true);
	    this.last[this.offset + 2] = v & 0xff;
	    this.offset += 3;
	    this.avail -= 3;
	    this._move(3);

	  // Two bytes here
	  } else if (this.avail >= 2) {
	    this.last.writeUInt16BE(v >>> 8, this.offset, true);
	    this._next();
	    this.last[this.offset++] = v & 0xff;
	    this.avail--;
	    this._move(3);

	  // Just one byte here
	  } else {
	    this.last[this.offset] = v >>> 16;
	    this._move(1);
	    this._next();
	    this.writeUInt16BE(v & 0xffff);
	  }
	};

	WBuf.prototype.writeUInt32BE = function writeUInt32BE(v) {
	  this._ensure(4);

	  // Fast case - everything fits into the last buffer
	  if (this.avail >= 4) {
	    this.last.writeUInt32BE(v, this.offset, true);
	    this.offset += 4;
	    this.avail -= 4;
	    this._move(4);

	  // Three bytes here
	  } else if (this.avail >= 3) {
	    this.writeUInt24BE(v >>> 8);
	    this._next();
	    this.last[this.offset++] = v & 0xff;
	    this.avail--;
	    this._move(1);

	  // Slow case, who cares
	  } else {
	    this.writeUInt16BE(v >>> 16);
	    this.writeUInt16BE(v & 0xffff);
	  }
	};

	WBuf.prototype.writeUInt16LE = function writeUInt16LE(num) {
	  var r = ((num & 0xff) << 8) | (num >>> 8);
	  this.writeUInt16BE(r);
	};

	WBuf.prototype.writeUInt24LE = function writeUInt24LE(num) {
	  var r = ((num & 0xff) << 16) | (((num >>> 8) & 0xff) << 8) | (num >>> 16);
	  this.writeUInt24BE(r);
	};

	WBuf.prototype.writeUInt32LE = function writeUInt32LE(num) {
	  var r = ((num & 0xff) << 24) |
	          (((num >>> 8) & 0xff) << 16) |
	          (((num >>> 16) & 0xff) << 8) |
	          (num >>> 24);
	  this.writeUInt32BE(r);
	};

	WBuf.prototype.render = function render() {
	  var left = this.size;
	  var out = [];

	  for (var i = 0; i < this.buffers.length && left >= 0; i++) {
	    var buf = this.buffers[i];
	    left -= buf.length;
	    if (left >= 0) {
	      out.push(buf);
	    } else {
	      out.push(buf.slice(0, buf.length + left));
	    }
	  }

	  return out;
	};

	// Signed APIs
	WBuf.prototype.writeInt8 = function writeInt8(num) {
	  if (num < 0)
	    return this.writeUInt8(0x100 + num);
	  else
	    return this.writeUInt8(num);
	};

	function toUnsigned16(num) {
	  if (num < 0)
	    return 0x10000 + num;
	  else
	    return num;
	}

	WBuf.prototype.writeInt16LE = function writeInt16LE(num) {
	  this.writeUInt16LE(toUnsigned16(num));
	};

	WBuf.prototype.writeInt16BE = function writeInt16BE(num) {
	  this.writeUInt16BE(toUnsigned16(num));
	};

	function toUnsigned24(num) {
	  if (num < 0)
	    return 0x1000000 + num;
	  else
	    return num;
	}

	WBuf.prototype.writeInt24LE = function writeInt24LE(num) {
	  this.writeUInt24LE(toUnsigned24(num));
	};

	WBuf.prototype.writeInt24BE = function writeInt24BE(num) {
	  this.writeUInt24BE(toUnsigned24(num));
	};

	function toUnsigned32(num) {
	  if (num < 0)
	    return (0xffffffff + num) + 1;
	  else
	    return num;
	}

	WBuf.prototype.writeInt32LE = function writeInt32LE(num) {
	  this.writeUInt32LE(toUnsigned32(num));
	};

	WBuf.prototype.writeInt32BE = function writeInt32BE(num) {
	  this.writeUInt32BE(toUnsigned32(num));
	};

	WBuf.prototype.writeComb = function writeComb(size, endian, value) {
	  if (size === 1)
	    return this.writeUInt8(value);

	  if (endian === 'le') {
	    if (size === 2)
	      this.writeUInt16LE(value);
	    else if (size === 3)
	      this.writeUInt24LE(value);
	    else if (size === 4)
	      this.writeUInt32LE(value);
	  } else {
	    if (size === 2)
	      this.writeUInt16BE(value);
	    else if (size === 3)
	      this.writeUInt24BE(value);
	    else if (size === 4)
	      this.writeUInt32BE(value);
	  }
	};


/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = assert;

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	assert.equal = function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	};


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var zlibpool = exports;
	var zlib = __webpack_require__(116);

	var transport = __webpack_require__(147);

	// TODO(indutny): think about it, why has it always been Z_SYNC_FLUSH here.
	// It should be possible to manually flush stuff after the write instead
	function createDeflate(version, compression) {
	  var deflate = zlib.createDeflate({
	    dictionary: transport.protocol.spdy.dictionary[version],
	    flush: zlib.Z_SYNC_FLUSH,
	    windowBits: 11,
	    level: compression ? zlib.Z_DEFAULT_COMPRESSION : zlib.Z_NO_COMPRESSION
	  });

	  // For node.js v0.8
	  deflate._flush = zlib.Z_SYNC_FLUSH;

	  return deflate;
	}

	function createInflate(version) {
	  var inflate = zlib.createInflate({
	    dictionary: transport.protocol.spdy.dictionary[version],
	    flush: zlib.Z_SYNC_FLUSH,
	    windowBits: 0
	  });

	  // For node.js v0.8
	  inflate._flush = zlib.Z_SYNC_FLUSH;

	  return inflate;
	}

	function Pool(compression) {
	  this.compression = compression;
	  this.pool = {
	    2: [],
	    3: [],
	    3.1: []
	  };
	}

	zlibpool.create = function create(compression) {
	  return new Pool(compression);
	};

	Pool.prototype.get = function get(version) {
	  if (this.pool[version].length > 0) {
	    return this.pool[version].pop();
	  } else {
	    var id = version;

	    return {
	      version: version,
	      compress: createDeflate(id, this.compression),
	      decompress: createInflate(id)
	    };
	  }
	};

	Pool.prototype.put = function put(pair) {
	  this.pool[pair.version].push(pair);
	};


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.name = 'h2';

	exports.constants = __webpack_require__(181);
	exports.parser = __webpack_require__(182);
	exports.framer = __webpack_require__(183);
	exports.compressionPool = __webpack_require__(184);


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var transport = __webpack_require__(147);
	var base = transport.protocol.base;

	var util = __webpack_require__(10);
	var Buffer = __webpack_require__(5).Buffer;

	exports.PREFACE_SIZE = 24;
	exports.PREFACE = 'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n';
	exports.PREFACE_BUFFER = new Buffer(exports.PREFACE);

	exports.PING_OPAQUE_SIZE = 8;

	exports.FRAME_HEADER_SIZE = 9;
	exports.INITIAL_MAX_FRAME_SIZE = 16384;
	exports.ABSOLUTE_MAX_FRAME_SIZE = 16777215;
	exports.HEADER_TABLE_SIZE = 4096;
	exports.DEFAULT_MAX_HEADER_LIST_SIZE = 80 * 1024;  // as in http_parser
	exports.MAX_INITIAL_WINDOW_SIZE = 2147483647;

	exports.DEFAULT_WEIGHT = 16;

	exports.MAX_CONCURRENT_STREAMS = Infinity;

	exports.frameType = {
	  DATA: 0,
	  HEADERS: 1,
	  PRIORITY: 2,
	  RST_STREAM: 3,
	  SETTINGS: 4,
	  PUSH_PROMISE: 5,
	  PING: 6,
	  GOAWAY: 7,
	  WINDOW_UPDATE: 8,
	  CONTINUATION: 9,

	  // Custom
	  X_FORWARDED_FOR: 0xde
	};

	exports.flags = {
	  ACK: 0x01,  // SETTINGS-only
	  END_STREAM: 0x01,
	  END_HEADERS: 0x04,
	  PADDED: 0x08,
	  PRIORITY: 0x20
	};

	exports.settings = {
	  SETTINGS_HEADER_TABLE_SIZE: 0x01,
	  SETTINGS_ENABLE_PUSH: 0x02,
	  SETTINGS_MAX_CONCURRENT_STREAMS: 0x03,
	  SETTINGS_INITIAL_WINDOW_SIZE: 0x04,
	  SETTINGS_MAX_FRAME_SIZE: 0x05,
	  SETTINGS_MAX_HEADER_LIST_SIZE: 0x06
	};

	exports.settingsIndex = [
	  null,
	  'header_table_size',
	  'enable_push',
	  'max_concurrent_streams',
	  'initial_window_size',
	  'max_frame_size',
	  'max_header_list_size'
	];

	exports.error = {
	  OK: 0,
	  NO_ERROR: 0,

	  PROTOCOL_ERROR: 1,
	  INTERNAL_ERROR: 2,
	  FLOW_CONTROL_ERROR: 3,
	  SETTINGS_TIMEOUT: 4,

	  STREAM_CLOSED: 5,
	  INVALID_STREAM: 5,

	  FRAME_SIZE_ERROR: 6,
	  REFUSED_STREAM: 7,
	  CANCEL: 8,
	  COMPRESSION_ERROR: 9,
	  CONNECT_ERROR: 10,
	  ENHANCE_YOUR_CALM: 11,
	  INADEQUATE_SECURITY: 12,
	  HTTP_1_1_REQUIRED: 13
	};
	exports.errorByCode = base.utils.reverse(exports.error);

	exports.DEFAULT_WINDOW = 64 * 1024 - 1;

	exports.goaway = exports.error;
	exports.goawayByCode = util._extend({}, exports.errorByCode);
	exports.goawayByCode[0] = 'OK';


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parser = exports;

	var transport = __webpack_require__(147);
	var base = transport.protocol.base;
	var utils = base.utils;
	var constants = __webpack_require__(180).constants;

	var assert = __webpack_require__(9);
	var util = __webpack_require__(10);

	function Parser(options) {
	  base.Parser.call(this, options);

	  this.isServer = options.isServer;

	  this.waiting = constants.PREFACE_SIZE;
	  this.state = 'preface';
	  this.pendingHeader = null;

	  // Header Block queue
	  this._lastHeaderBlock = null;
	  this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE;
	  this.maxHeaderListSize = constants.DEFAULT_MAX_HEADER_LIST_SIZE;
	}
	util.inherits(Parser, base.Parser);

	parser.create = function create(options) {
	  return new Parser(options);
	};

	Parser.prototype.setMaxFrameSize = function setMaxFrameSize(size) {
	  this.maxFrameSize = size;
	};

	Parser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize(size) {
	  this.maxHeaderListSize = size;
	};

	// Only for testing
	Parser.prototype.skipPreface = function skipPreface() {
	  // Just some number bigger than 3.1, doesn't really matter for HTTP2
	  this.setVersion(4);

	  // Parse frame header!
	  this.state = 'frame-head';
	  this.waiting = constants.FRAME_HEADER_SIZE;
	};

	Parser.prototype.execute = function execute(buffer, callback) {
	  if (this.state === 'preface')
	    return this.onPreface(buffer, callback);

	  if (this.state === 'frame-head')
	    return this.onFrameHead(buffer, callback);

	  assert(this.state === 'frame-body' && this.pendingHeader !== null);

	  var self = this;
	  var header = this.pendingHeader;
	  this.pendingHeader = null;

	  this.onFrameBody(header, buffer, function(err, frame) {
	    if (err)
	      return callback(err);

	    self.state = 'frame-head';
	    self.partial = false;
	    self.waiting = constants.FRAME_HEADER_SIZE;
	    callback(null, frame);
	  });
	};

	Parser.prototype.executePartial = function executePartial(buffer, callback) {
	  var header = this.pendingHeader;

	  assert.equal(header.flags & constants.flags.PADDED, 0);

	  if (this.window)
	    this.window.recv.update(-buffer.size);

	  callback(null, {
	    type: 'DATA',
	    id: header.id,

	    // Partial DATA can't be FIN
	    fin: false,
	    data: buffer.take(buffer.size)
	  });
	};

	Parser.prototype.onPreface = function onPreface(buffer, callback) {
	  if (buffer.take(buffer.size).toString() !== constants.PREFACE) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid preface'));
	  }

	  this.skipPreface();
	  callback(null, null);
	};

	Parser.prototype.onFrameHead = function onFrameHead(buffer, callback) {
	  var header = {
	    length: buffer.readUInt24BE(),
	    control: true,
	    type: buffer.readUInt8(),
	    flags: buffer.readUInt8(),
	    id: buffer.readUInt32BE() & 0x7fffffff
	  };

	  if (header.length > this.maxFrameSize) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'Frame length OOB'));
	  }

	  header.control = header.type !== constants.frameType.DATA;

	  this.state = 'frame-body';
	  this.pendingHeader = header;
	  this.waiting = header.length;
	  this.partial = !header.control;

	  // TODO(indutny): eventually support partial padded DATA
	  if (this.partial)
	    this.partial = (header.flags & constants.flags.PADDED) === 0;

	  callback(null, null);
	};

	Parser.prototype.onFrameBody = function onFrameBody(header, buffer, callback) {
	  var frameType = constants.frameType;

	  if (header.type === frameType.DATA)
	    this.onDataFrame(header, buffer, callback);
	  else if (header.type === frameType.HEADERS)
	    this.onHeadersFrame(header, buffer, callback);
	  else if (header.type === frameType.CONTINUATION)
	    this.onContinuationFrame(header, buffer, callback);
	  else if (header.type === frameType.WINDOW_UPDATE)
	    this.onWindowUpdateFrame(header, buffer, callback);
	  else if (header.type === frameType.RST_STREAM)
	    this.onRSTFrame(header, buffer, callback);
	  else if (header.type === frameType.SETTINGS)
	    this.onSettingsFrame(header, buffer, callback);
	  else if (header.type === frameType.PUSH_PROMISE)
	    this.onPushPromiseFrame(header, buffer, callback);
	  else if (header.type === frameType.PING)
	    this.onPingFrame(header, buffer, callback);
	  else if (header.type === frameType.GOAWAY)
	    this.onGoawayFrame(header, buffer, callback);
	  else if (header.type === frameType.PRIORITY)
	    this.onPriorityFrame(header, buffer, callback);
	  else if (header.type === frameType.X_FORWARDED_FOR)
	    this.onXForwardedFrame(header, buffer, callback);
	  else
	    this.onUnknownFrame(header, buffer, callback);
	};

	Parser.prototype.onUnknownFrame = function onUnknownFrame(header, buffer, callback) {
	  if (this._lastHeaderBlock !== null) {
	    callback(this.error(constants.error.PROTOCOL_ERROR,
	                        'Received unknown frame in the middle of a header block'));
	    return;
	  }
	  callback(null, { type: 'unknown: ' + header.type });
	};

	Parser.prototype.unpadData = function unpadData(header, body, callback) {
	  var isPadded = (header.flags & constants.flags.PADDED) !== 0;

	  if (!isPadded)
	    return callback(null, body);

	  if (!body.has(1)) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'Not enough space for padding'));
	  }

	  var pad = body.readUInt8();
	  if (!body.has(pad)) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid padding size'));
	  }

	  var contents = body.clone(body.size - pad);
	  body.skip(body.size);
	  callback(null, contents);
	};

	Parser.prototype.onDataFrame = function onDataFrame(header, body, callback) {
	  var isEndStream = (header.flags & constants.flags.END_STREAM) !== 0;

	  if (header.id === 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Received DATA frame with stream=0'));
	  }

	  // Count received bytes
	  if (this.window)
	    this.window.recv.update(-body.size);

	  this.unpadData(header, body, function(err, data) {
	    if (err)
	      return callback(err);

	    callback(null, {
	      type: 'DATA',
	      id: header.id,
	      fin: isEndStream,
	      data: data.take(data.size)
	    });
	  });
	};

	Parser.prototype.initHeaderBlock = function initHeaderBlock(header,
	                                                            frame,
	                                                            block,
	                                                            callback) {

	  if (this._lastHeaderBlock) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Duplicate Stream ID'));
	  }

	  this._lastHeaderBlock = {
	    id: header.id,
	    frame: frame,
	    queue: [],
	    size: 0
	  };

	  this.queueHeaderBlock(header, block, callback);
	};

	Parser.prototype.queueHeaderBlock = function queueHeaderBlock(header,
	                                                              block,
	                                                              callback) {
	  var self = this;
	  var item = this._lastHeaderBlock;
	  if (!this._lastHeaderBlock || item.id !== header.id) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'No matching stream for continuation'));
	  }

	  var fin = (header.flags & constants.flags.END_HEADERS) !== 0;

	  var chunks = block.toChunks();
	  for (var i = 0; i < chunks.length; i++) {
	    var chunk = chunks[i];
	    item.queue.push(chunk);
	    item.size += chunk.length;
	  }

	  if (item.size >= self.maxHeaderListSize) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Compressed header list is too large'));
	  }

	  if (!fin)
	    return callback(null, null);
	  this._lastHeaderBlock = null;

	  this.decompress.write(item.queue, function(err, chunks) {
	    if (err) {
	      return callback(self.error(constants.error.COMPRESSION_ERROR,
	                                 err.message));
	    }

	    var headers = {};
	    var size = 0;
	    for (var i = 0; i < chunks.length; i++) {
	      var header = chunks[i];

	      size += header.name.length + header.value.length + 32;
	      if (size >= self.maxHeaderListSize) {
	        return callback(self.error(constants.error.PROTOCOL_ERROR,
	                                   'Header list is too large'));
	      }

	      if (/[A-Z]/.test(header.name)) {
	        return callback(self.error(constants.error.PROTOCOL_ERROR,
	                                   'Header name must be lowercase'));
	      }

	      utils.addHeaderLine(header.name, header.value, headers);
	    }

	    item.frame.headers = headers;
	    item.frame.path = headers[':path'];

	    callback(null, item.frame);
	  });
	};

	Parser.prototype.onHeadersFrame = function onHeadersFrame(header,
	                                                          body,
	                                                          callback) {
	  var self = this;

	  if (header.id === 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for HEADERS'));
	  }

	  this.unpadData(header, body, function(err, data) {
	    if (err)
	      return callback(err);

	    var isPriority = (header.flags & constants.flags.PRIORITY) !== 0;
	    if (!data.has(isPriority ? 5 : 0)) {
	      return callback(self.error(constants.error.FRAME_SIZE_ERROR,
	                                 'Not enough data for HEADERS'));
	    }

	    var exclusive = false;
	    var dependency = 0;
	    var weight = constants.DEFAULT_WEIGHT;
	    if (isPriority) {
	      dependency = data.readUInt32BE();
	      exclusive = (dependency & 0x80000000) !== 0;
	      dependency &= 0x7fffffff;

	      // Weight's range is [1, 256]
	      weight = data.readUInt8() + 1;
	    }

	    if (dependency === header.id) {
	      return callback(self.error(constants.error.PROTOCOL_ERROR,
	                                 'Stream can\'t dependend on itself'));
	    }

	    var streamInfo = {
	      type: 'HEADERS',
	      id: header.id,
	      priority: {
	        parent: dependency,
	        exclusive: exclusive,
	        weight: weight
	      },
	      fin: (header.flags & constants.flags.END_STREAM) !== 0,
	      writable: true,
	      headers: null,
	      path: null
	    };

	    self.initHeaderBlock(header, streamInfo, data, callback);
	  });
	};

	Parser.prototype.onContinuationFrame = function onContinuationFrame(header,
	                                                                    body,
	                                                                    callback) {
	  this.queueHeaderBlock(header, body, callback);
	};

	Parser.prototype.onRSTFrame = function onRSTFrame(header, body, callback) {
	  if (body.size !== 4) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'RST_STREAM length not 4'));
	  }

	  if (header.id === 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for RST_STREAM'));
	  }

	  callback(null, {
	    type: 'RST',
	    id: header.id,
	    code: constants.errorByCode[body.readUInt32BE()]
	  });
	};

	Parser.prototype._validateSettings = function _validateSettings(settings) {
	  if (settings['enable_push'] !== undefined &&
	      settings['enable_push'] !== 0 &&
	      settings['enable_push'] !== 1)
	    return this.error(constants.error.PROTOCOL_ERROR,
	                      'SETTINGS_ENABLE_PUSH must be 0 or 1');

	  if ( settings['initial_window_size'] !== undefined &&
	      (settings['initial_window_size'] > constants.MAX_INITIAL_WINDOW_SIZE ||
	       settings['initial_window_size'] < 0))
	    return this.error(constants.error.FLOW_CONTROL_ERROR,
	                      'SETTINGS_INITIAL_WINDOW_SIZE is OOB');

	  if ( settings['max_frame_size'] !== undefined &&
	      (settings['max_frame_size'] > constants.ABSOLUTE_MAX_FRAME_SIZE ||
	       settings['max_frame_size'] < constants.INITIAL_MAX_FRAME_SIZE))
	    return this.error(constants.error.PROTOCOL_ERROR,
	                      'SETTINGS_MAX_FRAME_SIZE is OOB');

	  return undefined;
	};

	Parser.prototype.onSettingsFrame = function onSettingsFrame(header,
	                                                            body,
	                                                            callback) {

	  if (header.id !== 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for SETTINGS'));
	  }

	  var isAck = (header.flags & constants.flags.ACK) !== 0;
	  if (isAck && body.size !== 0) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'SETTINGS with ACK and non-zero length'));
	  }

	  if (isAck)
	    return callback(null, { type: 'ACK_SETTINGS' });

	  if (body.size % 6 !== 0) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'SETTINGS length not multiple of 6'));
	  }

	  var settings = {};
	  while (!body.isEmpty()) {
	    var id = body.readUInt16BE();
	    var value = body.readUInt32BE();
	    var name = constants.settingsIndex[id];

	    if (name)
	      settings[name] = value;
	  }

	  var err = this._validateSettings(settings);
	  if (err !== undefined) {
	    return callback(err);
	  }

	  callback(null, {
	    type: 'SETTINGS',
	    settings: settings
	  });
	};

	Parser.prototype.onPushPromiseFrame = function onPushPromiseFrame(header,
	                                                                  body,
	                                                                  callback) {

	  if (header.id === 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for PUSH_PROMISE'));
	  }

	  var self = this;
	  this.unpadData(header, body, function(err, data) {
	    if (err)
	      return callback(err);

	    if (!data.has(4)) {
	      return callback(self.error(constants.error.FRAME_SIZE_ERROR,
	                                 'PUSH_PROMISE length less than 4'));
	    }

	    var streamInfo = {
	      type: 'PUSH_PROMISE',
	      id: header.id,
	      fin: false,
	      promisedId: data.readUInt32BE() & 0x7fffffff,
	      headers: null,
	      path: null
	    };

	    self.initHeaderBlock(header, streamInfo, data, callback);
	  });
	};

	Parser.prototype.onPingFrame = function onPingFrame(header, body, callback) {
	  if (body.size !== 8) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'PING length != 8'));
	  }

	  if (header.id !== 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for PING'));
	  }

	  var ack = (header.flags & constants.flags.ACK) !== 0;
	  callback(null, { type: 'PING', opaque: body.take(body.size), ack: ack });
	};

	Parser.prototype.onGoawayFrame = function onGoawayFrame(header,
	                                                        body,
	                                                        callback) {
	  if (!body.has(8)) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'GOAWAY length < 8'));
	  }

	  if (header.id !== 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for GOAWAY'));
	  }

	  var frame = {
	    type: 'GOAWAY',
	    lastId: body.readUInt32BE(),
	    code: constants.goawayByCode[body.readUInt32BE()]
	  };

	  if (body.size !== 0)
	    frame.debug = body.take(body.size);

	  callback(null, frame);
	};

	Parser.prototype.onPriorityFrame = function onPriorityFrame(header,
	                                                            body,
	                                                            callback) {
	  if (body.size !== 5) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'PRIORITY length != 5'));
	  }

	  if (header.id === 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Invalid stream id for PRIORITY'));
	  }

	  var dependency = body.readUInt32BE();

	  // Again the range is from 1 to 256
	  var weight = body.readUInt8() + 1;

	  if (dependency === header.id) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'Stream can\'t dependend on itself'));
	  }

	  callback(null, {
	    type: 'PRIORITY',
	    id: header.id,
	    priority: {
	      exclusive: (dependency & 0x80000000) !== 0,
	      parent: dependency & 0x7fffffff,
	      weight: weight
	    }
	  });
	};

	Parser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame(header,
	                                                                    body,
	                                                                    callback) {
	  if (body.size !== 4) {
	    return callback(this.error(constants.error.FRAME_SIZE_ERROR,
	                               'WINDOW_UPDATE length != 4'));
	  }

	  var delta = body.readInt32BE();
	  if (delta === 0) {
	    return callback(this.error(constants.error.PROTOCOL_ERROR,
	                               'WINDOW_UPDATE delta == 0'));
	  }

	  callback(null, {
	    type: 'WINDOW_UPDATE',
	    id: header.id,
	    delta: delta
	  });
	};

	Parser.prototype.onXForwardedFrame = function onXForwardedFrame(header,
	                                                                body,
	                                                                callback) {
	  callback(null, {
	    type: 'X_FORWARDED_FOR',
	    host: body.take(body.size).toString()
	  });
	};


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var transport = __webpack_require__(147);
	var base = transport.protocol.base;
	var constants = __webpack_require__(180).constants;

	var assert = __webpack_require__(9);
	var util = __webpack_require__(10);
	var WriteBuffer = __webpack_require__(177);
	var OffsetBuffer = __webpack_require__(170);
	var Buffer = __webpack_require__(5).Buffer;
	var debug = __webpack_require__(153)('spdy:framer');
	var debugExtra = __webpack_require__(153)('spdy:framer:extra');

	function Framer(options) {
	  base.Framer.call(this, options);

	  this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE;
	}
	util.inherits(Framer, base.Framer);
	module.exports = Framer;

	Framer.create = function create(options) {
	  return new Framer(options);
	};

	Framer.prototype.setMaxFrameSize = function setMaxFrameSize(size) {
	  this.maxFrameSize = size;
	};

	Framer.prototype._frame = function _frame(frame, body, callback) {
	  debug('id=%d type=%s', frame.id, frame.type);

	  var buffer = new WriteBuffer();

	  buffer.reserve(constants.FRAME_HEADER_SIZE);
	  var len = buffer.skip(3);
	  buffer.writeUInt8(constants.frameType[frame.type]);
	  buffer.writeUInt8(frame.flags);
	  buffer.writeUInt32BE(frame.id & 0x7fffffff);

	  body(buffer);

	  var frameSize = buffer.size - constants.FRAME_HEADER_SIZE;
	  len.writeUInt24BE(frameSize);

	  var chunks = buffer.render();
	  var toWrite = {
	    stream: frame.id,
	    priority: frame.priority === undefined ? false : frame.priority,
	    chunks: chunks,
	    callback: callback
	  };

	  if (this.window && frame.type === 'DATA') {
	    var self = this;
	    this._resetTimeout();
	    this.window.send.update(-frameSize, function() {
	      self._resetTimeout();
	      self.schedule(toWrite);
	    });
	  } else {
	    this._resetTimeout();
	    this.schedule(toWrite);
	  }

	  return chunks;
	};

	Framer.prototype._split = function _split(frame) {
	  var buf = new OffsetBuffer();
	  for (var i = 0; i < frame.chunks.length; i++)
	    buf.push(frame.chunks[i]);

	  var frames = [];
	  while (!buf.isEmpty()) {
	    // First frame may have reserved bytes in it
	    var size = this.maxFrameSize;
	    if (frames.length === 0)
	      size -= frame.reserve;
	    size = Math.min(size, buf.size);

	    var frameBuf = buf.clone(size);
	    buf.skip(size);

	    frames.push({
	      size: frameBuf.size,
	      chunks: frameBuf.toChunks()
	    });
	  }

	  return frames;
	};

	Framer.prototype._continuationFrame = function _continuationFrame(frame,
	                                                                  body,
	                                                                  callback) {
	  var frames = this._split(frame);

	  frames.forEach(function(subFrame, i) {
	    var isFirst = i === 0;
	    var isLast = i === frames.length - 1;

	    var flags = isLast ? constants.flags.END_HEADERS : 0;

	    // PRIORITY and friends
	    if (isFirst)
	      flags |= frame.flags;

	    this._frame({
	      id: frame.id,
	      priority: false,
	      type: isFirst ? frame.type : 'CONTINUATION',
	      flags: flags
	    }, function(buf) {
	      // Fill those reserved bytes
	      if (isFirst && body)
	        body(buf);

	      buf.reserve(subFrame.size);
	      for (var i = 0; i < subFrame.chunks.length; i++)
	        buf.copyFrom(subFrame.chunks[i]);
	    }, isLast ? callback : null);
	  }, this);

	  if (frames.length === 0) {
	    this._frame({
	      id: frame.id,
	      priority: false,
	      type: frame.type,
	      flags: frame.flags | constants.flags.END_HEADERS
	    }, function(buf) {
	      if (body)
	        body(buf);
	    }, callback);
	  }
	};

	Framer.prototype._compressHeaders = function _compressHeaders(headers,
	                                                              pairs,
	                                                              callback) {
	  Object.keys(headers || {}).forEach(function(name) {
	    var lowName = name.toLowerCase();

	    // Should be already in `:authority`
	    if (lowName === 'host')
	      return;
	    // Not allowed in HTTP2
	    if (lowName === 'connection')
	      return;

	    // Should be in `pairs`
	    if (/^:/.test(lowName))
	      return;

	    // Do not compress, or index Cookie field (for security reasons)
	    var neverIndex = lowName === 'cookie' || lowName === 'set-cookie';

	    var value = headers[name];
	    if (Array.isArray(value)) {
	      for (var i = 0; i < value.length; i++) {
	        pairs.push({
	          name: lowName,
	          value: value[i] + '',
	          neverIndex: neverIndex,
	          huffman: !neverIndex
	        });
	      }
	    } else {
	      pairs.push({
	        name: lowName,
	        value: value + '',
	        neverIndex: neverIndex,
	        huffman: !neverIndex
	      });
	    }
	  });

	  var self = this;
	  assert(this.compress !== null, 'Framer version not initialized');
	  debugExtra('compressing headers=%j', pairs);
	  this.compress.write([ pairs ], callback);
	};

	Framer.prototype._isDefaultPriority = function _isDefaultPriority(priority) {
	  if (!priority)
	    return true;

	  return !priority.parent &&
	         priority.weight === constants.DEFAULT &&
	         !priority.exclusive;
	};

	Framer.prototype._defaultHeaders = function _defaultHeaders(frame, pairs) {
	  if (!frame.path)
	    throw new Error('`path` is required frame argument');

	  pairs.push({
	    name: ':method',
	    value: frame.method || base.constants.DEFAULT_METHOD
	  });
	  pairs.push({ name: ':path', value: frame.path });
	  pairs.push({ name: ':scheme', value: frame.scheme || 'https' });
	  pairs.push({
	    name: ':authority',
	    value: frame.host ||
	           frame.headers && frame.headers.host ||
	           base.constants.DEFAULT_HOST
	  });
	};

	Framer.prototype._headersFrame = function _headersFrame(kind, frame, callback) {
	  var pairs = [];

	  if (kind === 'request') {
	    this._defaultHeaders(frame, pairs);
	  } else if (kind === 'response') {
	    pairs.push({ name: ':status', value: (frame.status || 200) + '' });
	  }

	  var self = this;
	  this._compressHeaders(frame.headers, pairs, function(err, chunks) {
	    if (err) {
	      if (callback)
	        return callback(err);
	      else
	        return self.emit('error', err);
	    }

	    var reserve = 0;

	    // If priority info is present, and the values are not default ones
	    // reserve space for the priority info and add PRIORITY flag
	    var priority = frame.priority;
	    if (!self._isDefaultPriority(priority))
	      reserve = 5;

	    var flags = reserve === 0 ? 0 : constants.flags.PRIORITY;

	    // Mostly for testing
	    if (frame.fin)
	      flags |= constants.flags.END_STREAM;

	    self._continuationFrame({
	      id: frame.id,
	      type: 'HEADERS',
	      flags: flags,
	      reserve: reserve,
	      chunks: chunks
	    }, function(buf) {
	      if (reserve === 0)
	        return;

	      buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) |
	                        priority.parent);
	      buf.writeUInt8((priority.weight | 0) - 1);
	    }, callback);
	  });
	};

	Framer.prototype.requestFrame = function requestFrame(frame, callback) {
	  return this._headersFrame('request', frame, callback);
	};

	Framer.prototype.responseFrame = function responseFrame(frame, callback) {
	  return this._headersFrame('response', frame, callback);
	};

	Framer.prototype.headersFrame = function headersFrame(frame, callback) {
	  return this._headersFrame('headers', frame, callback);
	};

	Framer.prototype.pushFrame = function pushFrame(frame, callback) {
	  var self = this;

	  function compress(headers, pairs, callback) {
	    self._compressHeaders(headers, pairs, function(err, chunks) {
	      if (err) {
	        if (callback)
	          return callback(err);
	        else
	          return self.emit('error', err);
	      }

	      callback(chunks);
	    });
	  }

	  function sendPromise(chunks) {
	    self._continuationFrame({
	      id: frame.id,
	      type: 'PUSH_PROMISE',
	      reserve: 4,
	      chunks: chunks
	    }, function(buf) {
	      buf.writeUInt32BE(frame.promisedId);
	    });
	  }

	  function sendResponse(chunks, callback) {
	    var priority = frame.priority;
	    var isDefaultPriority = self._isDefaultPriority(priority);
	    var flags = isDefaultPriority ? 0 : constants.flags.PRIORITY;

	    // Mostly for testing
	    if (frame.fin)
	      flags |= constants.flags.END_STREAM;

	    self._continuationFrame({
	      id: frame.promisedId,
	      type: 'HEADERS',
	      flags: flags,
	      reserve: isDefaultPriority ? 0 : 5,
	      chunks: chunks
	    }, function(buf) {
	      if (isDefaultPriority)
	        return;

	      buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) |
	                        priority.parent);
	      buf.writeUInt8((priority.weight | 0) - 1);
	    }, callback);
	  }

	  this._checkPush(function(err) {
	    if (err)
	      return callback(err);

	    var pairs = {
	      promise: [],
	      response: []
	    };

	    self._defaultHeaders(frame, pairs.promise);
	    pairs.response.push({ name: ':status', value: (frame.status || 200) + '' });

	    compress(frame.headers, pairs.promise, function(promiseChunks) {
	      sendPromise(promiseChunks);
	      compress(frame.response, pairs.response, function(responseChunks) {
	        sendResponse(responseChunks, callback);
	      });
	    });
	  });
	};

	Framer.prototype.priorityFrame = function priorityFrame(frame, callback) {
	  this._frame({
	    id: frame.id,
	    priority: false,
	    type: 'PRIORITY',
	    flags: 0
	  }, function(buf) {
	    var priority = frame.priority;
	    buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) |
	                      priority.parent);
	    buf.writeUInt8((priority.weight | 0) - 1);
	  }, callback);
	};

	Framer.prototype.dataFrame = function dataFrame(frame, callback) {
	  var frames = this._split({
	    reserve: 0,
	    chunks: [ frame.data ]
	  });

	  var fin = frame.fin ? constants.flags.END_STREAM : 0;

	  var self = this;
	  frames.forEach(function(subFrame, i) {
	    var isLast = i === frames.length - 1;
	    var flags = 0;
	    if (isLast)
	      flags |= fin;

	    self._frame({
	      id: frame.id,
	      priority: frame.priority,
	      type: 'DATA',
	      flags: flags
	    }, function(buf) {
	      buf.reserve(subFrame.size);
	      for (var i = 0; i < subFrame.chunks.length; i++)
	        buf.copyFrom(subFrame.chunks[i]);
	    }, isLast ? callback : null);
	  });

	  // Empty DATA
	  if (frames.length === 0) {
	    this._frame({
	      id: frame.id,
	      priority: frame.priority,
	      type: 'DATA',
	      flags: fin
	    }, function(buf) {
	      // No-op
	    }, callback);
	  }
	};

	Framer.prototype.pingFrame = function pingFrame(frame, callback) {
	  this._frame({
	    id: 0,
	    type: 'PING',
	    flags: frame.ack ? constants.flags.ACK : 0
	  }, function(buf) {
	    buf.copyFrom(frame.opaque);
	  }, callback);
	};

	Framer.prototype.rstFrame = function rstFrame(frame, callback) {
	  this._frame({
	    id: frame.id,
	    type: 'RST_STREAM',
	    flags: 0
	  }, function(buf) {
	    buf.writeUInt32BE(constants.error[frame.code]);
	  }, callback);
	};

	Framer.prototype.prefaceFrame = function prefaceFrame(callback) {
	  debug('preface');
	  this._resetTimeout();
	  this.schedule({
	    stream: 0,
	    priority: false,
	    chunks: [ constants.PREFACE_BUFFER ],
	    callback: callback
	  });
	};

	Framer.prototype.settingsFrame = function settingsFrame(options, callback) {
	  var key = JSON.stringify(options);

	  var settings = Framer.settingsCache[key];
	  if (settings) {
	    debug('cached settings');
	    this._resetTimeout();
	    this.schedule({
	      id: 0,
	      priority: false,
	      chunks: settings,
	      callback: callback
	    });
	    return;
	  }

	  var params = [];
	  for (var i = 0; i < constants.settingsIndex.length; i++) {
	    var name = constants.settingsIndex[i];
	    if (!name)
	      continue;

	    // value: Infinity
	    if (!isFinite(options[name]))
	      continue;

	    if (options[name] !== undefined)
	      params.push({ key: i, value: options[name] });
	  }

	  var bodySize = params.length * 6;

	  var chunks = this._frame({
	    id: 0,
	    type: 'SETTINGS',
	    flags: 0
	  }, function(buffer) {
	    buffer.reserve(bodySize);
	    for (var i = 0; i < params.length; i++) {
	      var param = params[i];

	      buffer.writeUInt16BE(param.key);
	      buffer.writeUInt32BE(param.value);
	    }
	  }, callback);

	  Framer.settingsCache[key] = chunks;
	};
	Framer.settingsCache = {};

	Framer.prototype.ackSettingsFrame = function ackSettingsFrame(callback) {
	  var chunks = this._frame({
	    id: 0,
	    type: 'SETTINGS',
	    flags: constants.flags.ACK
	  }, function(buffer) {
	    // No-op
	  }, callback);
	};

	Framer.prototype.windowUpdateFrame = function windowUpdateFrame(frame,
	                                                                callback) {
	  this._frame({
	    id: frame.id,
	    type: 'WINDOW_UPDATE',
	    flags: 0
	  }, function(buffer) {
	    buffer.reserve(4);
	    buffer.writeInt32BE(frame.delta);
	  }, callback);
	};

	Framer.prototype.goawayFrame = function goawayFrame(frame, callback) {
	  this._frame({
	    type: 'GOAWAY',
	    id: 0,
	    flags: 0
	  }, function(buf) {
	    buf.reserve(8);

	    // Last-good-stream-ID
	    buf.writeUInt32BE(frame.lastId & 0x7fffffff);
	    // Code
	    buf.writeUInt32BE(constants.goaway[frame.code]);

	    // Extra debugging information
	    if (frame.extra)
	      buf.write(frame.extra);
	  }, callback);
	};

	Framer.prototype.xForwardedFor = function xForwardedFor(frame, callback) {
	  this._frame({
	    type: 'X_FORWARDED_FOR',
	    id: 0,
	    flags: 0
	  }, function(buf) {
	    buf.write(frame.host);
	  }, callback);
	};


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var transport = __webpack_require__(147);
	var constants = __webpack_require__(180).constants;

	var hpack = __webpack_require__(185);

	function Pool() {
	}
	module.exports = Pool;

	Pool.create = function create() {
	  return new Pool();
	};

	Pool.prototype.get = function get(version) {
	  var options = {
	    table: {
	      maxSize: constants.HEADER_TABLE_SIZE
	    }
	  };

	  var compress = hpack.compressor.create(options);
	  var decompress = hpack.decompressor.create(options);

	  return {
	    version: version,

	    compress: compress,
	    decompress: decompress
	  };
	};

	Pool.prototype.put = function put() {
	};


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var hpack = exports;

	hpack.utils = __webpack_require__(186);
	hpack.huffman = __webpack_require__(187);
	hpack['static-table'] = __webpack_require__(188);
	hpack.table = __webpack_require__(189);

	hpack.decoder = __webpack_require__(190);
	hpack.decompressor = __webpack_require__(191);

	hpack.encoder = __webpack_require__(192);
	hpack.compressor = __webpack_require__(193);


/***/ },
/* 186 */
/***/ function(module, exports) {

	exports.assert = function assert(cond, text) {
	  if (!cond)
	    throw new Error(text);
	};

	exports.stringify = function stringify(arr) {
	  var res = '';
	  for (var i = 0; i < arr.length; i++)
	    res += String.fromCharCode(arr[i]);
	  return res;
	};

	exports.toArray = function toArray(str) {
	  var res = [];
	  for (var i = 0; i < str.length; i++) {
	    var c = str.charCodeAt(i);
	    var hi = c >>> 8;
	    var lo = c & 0xff;
	    if (hi)
	      res.push(hi, lo);
	    else
	      res.push(lo);
	  }
	  return res;
	};


/***/ },
/* 187 */
/***/ function(module, exports) {

	exports.decode =
	    [2608,2609,2610,2657,2659,2661,2665,2671,2675,2676,0,0,0,0,0,0,0,0,0,0,
	    3104,3109,3117,3118,3119,3123,3124,3125,3126,3127,3128,3129,3133,3137,3167,
	    3170,3172,3174,3175,3176,3180,3181,3182,3184,3186,3189,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    3642,3650,3651,3652,3653,3654,3655,3656,3657,3658,3659,3660,3661,3662,3663,
	    3664,3665,3666,3667,3668,3669,3670,3671,3673,3690,3691,3697,3702,3703,3704,
	    3705,3706,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4134,4138,4140,4155,4184,4186,[1057,
	    1058,1064,1065,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	    [1087,0,1575,1579,1660,0,0,0,0,0,2083,2110,0,0,0,0,0,0,0,0,0,0,0,0,2560,
	    2596,2624,2651,2653,2686,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,3166,3197,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3644,
	    3680,3707,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[1628,1731,1744,0,0,0,2176,2178,
	    2179,2210,2232,2242,2272,2274,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2713,2721,2727,
	    2732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0],[2736,2737,2739,2769,2776,2777,2787,2789,2790,0,0,0,0,0,0,0,0,0,
	    3201,3204,3205,3206,3208,3218,3226,3228,3232,3235,3236,3241,3242,3245,3250,
	    3253,3257,3258,3259,3261,3262,3268,3270,3300,3304,3305,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3585,
	    3719,3721,3722,3723,3724,3725,3727,3731,3733,3734,3735,3736,3739,3741,3742,
	    3749,3750,3752,3758,3759,3764,3766,3767,3772,3775,3781,3815,3823,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,4105,4238,4240,4241,4244,4255,4267,4302,4311,4321,4332,4333,[711,719,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[746,747,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1216,1217,
	    1224,1225,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	    [1226,1229,1234,1237,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0],[1242,1243,1262,1264,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0],[1266,1267,1279,0,0,0,1739,1740,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0],[1747,1748,1750,1757,1758,1759,1777,1780,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1781,1782,1783,1784,1786,
	    1787,1788,1789,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1790,0,
	    2050,2051,2052,2053,2054,2055,2056,2059,2060,2062,2063,2064,2065,2066,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2067,2068,2069,2071,2072,2073,2074,2075,
	    2076,2077,2078,2079,2175,2268,2297,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3082,3085,3094,3328,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0]]]];
	exports.encode =
	    [[13,8184],[23,8388568],[28,268435426],[28,268435427],[28,268435428],[28,
	    268435429],[28,268435430],[28,268435431],[28,268435432],[24,16777194],[30,
	    1073741820],[28,268435433],[28,268435434],[30,1073741821],[28,268435435],
	    [28,268435436],[28,268435437],[28,268435438],[28,268435439],[28,268435440],
	    [28,268435441],[28,268435442],[30,1073741822],[28,268435443],[28,
	    268435444],[28,268435445],[28,268435446],[28,268435447],[28,268435448],[28,
	    268435449],[28,268435450],[28,268435451],[6,20],[10,1016],[10,1017],[12,
	    4090],[13,8185],[6,21],[8,248],[11,2042],[10,1018],[10,1019],[8,249],[11,
	    2043],[8,250],[6,22],[6,23],[6,24],[5,0],[5,1],[5,2],[6,25],[6,26],[6,27],
	    [6,28],[6,29],[6,30],[6,31],[7,92],[8,251],[15,32764],[6,32],[12,4091],[10,
	    1020],[13,8186],[6,33],[7,93],[7,94],[7,95],[7,96],[7,97],[7,98],[7,99],[7,
	    100],[7,101],[7,102],[7,103],[7,104],[7,105],[7,106],[7,107],[7,108],[7,
	    109],[7,110],[7,111],[7,112],[7,113],[7,114],[8,252],[7,115],[8,253],[13,
	    8187],[19,524272],[13,8188],[14,16380],[6,34],[15,32765],[5,3],[6,35],[5,
	    4],[6,36],[5,5],[6,37],[6,38],[6,39],[5,6],[7,116],[7,117],[6,40],[6,41],
	    [6,42],[5,7],[6,43],[7,118],[6,44],[5,8],[5,9],[6,45],[7,119],[7,120],[7,
	    121],[7,122],[7,123],[15,32766],[11,2044],[14,16381],[13,8189],[28,
	    268435452],[20,1048550],[22,4194258],[20,1048551],[20,1048552],[22,
	    4194259],[22,4194260],[22,4194261],[23,8388569],[22,4194262],[23,8388570],
	    [23,8388571],[23,8388572],[23,8388573],[23,8388574],[24,16777195],[23,
	    8388575],[24,16777196],[24,16777197],[22,4194263],[23,8388576],[24,
	    16777198],[23,8388577],[23,8388578],[23,8388579],[23,8388580],[21,2097116],
	    [22,4194264],[23,8388581],[22,4194265],[23,8388582],[23,8388583],[24,
	    16777199],[22,4194266],[21,2097117],[20,1048553],[22,4194267],[22,4194268],
	    [23,8388584],[23,8388585],[21,2097118],[23,8388586],[22,4194269],[22,
	    4194270],[24,16777200],[21,2097119],[22,4194271],[23,8388587],[23,8388588],
	    [21,2097120],[21,2097121],[22,4194272],[21,2097122],[23,8388589],[22,
	    4194273],[23,8388590],[23,8388591],[20,1048554],[22,4194274],[22,4194275],
	    [22,4194276],[23,8388592],[22,4194277],[22,4194278],[23,8388593],[26,
	    67108832],[26,67108833],[20,1048555],[19,524273],[22,4194279],[23,8388594],
	    [22,4194280],[25,33554412],[26,67108834],[26,67108835],[26,67108836],[27,
	    134217694],[27,134217695],[26,67108837],[24,16777201],[25,33554413],[19,
	    524274],[21,2097123],[26,67108838],[27,134217696],[27,134217697],[26,
	    67108839],[27,134217698],[24,16777202],[21,2097124],[21,2097125],[26,
	    67108840],[26,67108841],[28,268435453],[27,134217699],[27,134217700],[27,
	    134217701],[20,1048556],[24,16777203],[20,1048557],[21,2097126],[22,
	    4194281],[21,2097127],[21,2097128],[23,8388595],[22,4194282],[22,4194283],
	    [25,33554414],[25,33554415],[24,16777204],[24,16777205],[26,67108842],[23,
	    8388596],[26,67108843],[27,134217702],[26,67108844],[26,67108845],[27,
	    134217703],[27,134217704],[27,134217705],[27,134217706],[27,134217707],[28,
	    268435454],[27,134217708],[27,134217709],[27,134217710],[27,134217711],[27,
	    134217712],[26,67108846],[30,1073741823]];


/***/ },
/* 188 */
/***/ function(module, exports) {

	exports.table = [
	  {
	    "name": ":authority",
	    "value": "",
	    "nameSize": 10,
	    "totalSize": 42
	  },
	  {
	    "name": ":method",
	    "value": "GET",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": ":method",
	    "value": "POST",
	    "nameSize": 7,
	    "totalSize": 43
	  },
	  {
	    "name": ":path",
	    "value": "/",
	    "nameSize": 5,
	    "totalSize": 38
	  },
	  {
	    "name": ":path",
	    "value": "/index.html",
	    "nameSize": 5,
	    "totalSize": 48
	  },
	  {
	    "name": ":scheme",
	    "value": "http",
	    "nameSize": 7,
	    "totalSize": 43
	  },
	  {
	    "name": ":scheme",
	    "value": "https",
	    "nameSize": 7,
	    "totalSize": 44
	  },
	  {
	    "name": ":status",
	    "value": "200",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": ":status",
	    "value": "204",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": ":status",
	    "value": "206",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": ":status",
	    "value": "304",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": ":status",
	    "value": "400",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": ":status",
	    "value": "404",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": ":status",
	    "value": "500",
	    "nameSize": 7,
	    "totalSize": 42
	  },
	  {
	    "name": "accept-charset",
	    "value": "",
	    "nameSize": 14,
	    "totalSize": 46
	  },
	  {
	    "name": "accept-encoding",
	    "value": "gzip, deflate",
	    "nameSize": 15,
	    "totalSize": 60
	  },
	  {
	    "name": "accept-language",
	    "value": "",
	    "nameSize": 15,
	    "totalSize": 47
	  },
	  {
	    "name": "accept-ranges",
	    "value": "",
	    "nameSize": 13,
	    "totalSize": 45
	  },
	  {
	    "name": "accept",
	    "value": "",
	    "nameSize": 6,
	    "totalSize": 38
	  },
	  {
	    "name": "access-control-allow-origin",
	    "value": "",
	    "nameSize": 27,
	    "totalSize": 59
	  },
	  {
	    "name": "age",
	    "value": "",
	    "nameSize": 3,
	    "totalSize": 35
	  },
	  {
	    "name": "allow",
	    "value": "",
	    "nameSize": 5,
	    "totalSize": 37
	  },
	  {
	    "name": "authorization",
	    "value": "",
	    "nameSize": 13,
	    "totalSize": 45
	  },
	  {
	    "name": "cache-control",
	    "value": "",
	    "nameSize": 13,
	    "totalSize": 45
	  },
	  {
	    "name": "content-disposition",
	    "value": "",
	    "nameSize": 19,
	    "totalSize": 51
	  },
	  {
	    "name": "content-encoding",
	    "value": "",
	    "nameSize": 16,
	    "totalSize": 48
	  },
	  {
	    "name": "content-language",
	    "value": "",
	    "nameSize": 16,
	    "totalSize": 48
	  },
	  {
	    "name": "content-length",
	    "value": "",
	    "nameSize": 14,
	    "totalSize": 46
	  },
	  {
	    "name": "content-location",
	    "value": "",
	    "nameSize": 16,
	    "totalSize": 48
	  },
	  {
	    "name": "content-range",
	    "value": "",
	    "nameSize": 13,
	    "totalSize": 45
	  },
	  {
	    "name": "content-type",
	    "value": "",
	    "nameSize": 12,
	    "totalSize": 44
	  },
	  {
	    "name": "cookie",
	    "value": "",
	    "nameSize": 6,
	    "totalSize": 38
	  },
	  {
	    "name": "date",
	    "value": "",
	    "nameSize": 4,
	    "totalSize": 36
	  },
	  {
	    "name": "etag",
	    "value": "",
	    "nameSize": 4,
	    "totalSize": 36
	  },
	  {
	    "name": "expect",
	    "value": "",
	    "nameSize": 6,
	    "totalSize": 38
	  },
	  {
	    "name": "expires",
	    "value": "",
	    "nameSize": 7,
	    "totalSize": 39
	  },
	  {
	    "name": "from",
	    "value": "",
	    "nameSize": 4,
	    "totalSize": 36
	  },
	  {
	    "name": "host",
	    "value": "",
	    "nameSize": 4,
	    "totalSize": 36
	  },
	  {
	    "name": "if-match",
	    "value": "",
	    "nameSize": 8,
	    "totalSize": 40
	  },
	  {
	    "name": "if-modified-since",
	    "value": "",
	    "nameSize": 17,
	    "totalSize": 49
	  },
	  {
	    "name": "if-none-match",
	    "value": "",
	    "nameSize": 13,
	    "totalSize": 45
	  },
	  {
	    "name": "if-range",
	    "value": "",
	    "nameSize": 8,
	    "totalSize": 40
	  },
	  {
	    "name": "if-unmodified-since",
	    "value": "",
	    "nameSize": 19,
	    "totalSize": 51
	  },
	  {
	    "name": "last-modified",
	    "value": "",
	    "nameSize": 13,
	    "totalSize": 45
	  },
	  {
	    "name": "link",
	    "value": "",
	    "nameSize": 4,
	    "totalSize": 36
	  },
	  {
	    "name": "location",
	    "value": "",
	    "nameSize": 8,
	    "totalSize": 40
	  },
	  {
	    "name": "max-forwards",
	    "value": "",
	    "nameSize": 12,
	    "totalSize": 44
	  },
	  {
	    "name": "proxy-authenticate",
	    "value": "",
	    "nameSize": 18,
	    "totalSize": 50
	  },
	  {
	    "name": "proxy-authorization",
	    "value": "",
	    "nameSize": 19,
	    "totalSize": 51
	  },
	  {
	    "name": "range",
	    "value": "",
	    "nameSize": 5,
	    "totalSize": 37
	  },
	  {
	    "name": "referer",
	    "value": "",
	    "nameSize": 7,
	    "totalSize": 39
	  },
	  {
	    "name": "refresh",
	    "value": "",
	    "nameSize": 7,
	    "totalSize": 39
	  },
	  {
	    "name": "retry-after",
	    "value": "",
	    "nameSize": 11,
	    "totalSize": 43
	  },
	  {
	    "name": "server",
	    "value": "",
	    "nameSize": 6,
	    "totalSize": 38
	  },
	  {
	    "name": "set-cookie",
	    "value": "",
	    "nameSize": 10,
	    "totalSize": 42
	  },
	  {
	    "name": "strict-transport-security",
	    "value": "",
	    "nameSize": 25,
	    "totalSize": 57
	  },
	  {
	    "name": "transfer-encoding",
	    "value": "",
	    "nameSize": 17,
	    "totalSize": 49
	  },
	  {
	    "name": "user-agent",
	    "value": "",
	    "nameSize": 10,
	    "totalSize": 42
	  },
	  {
	    "name": "vary",
	    "value": "",
	    "nameSize": 4,
	    "totalSize": 36
	  },
	  {
	    "name": "via",
	    "value": "",
	    "nameSize": 3,
	    "totalSize": 35
	  },
	  {
	    "name": "www-authenticate",
	    "value": "",
	    "nameSize": 16,
	    "totalSize": 48
	  }
	];
	exports.map = {
	  ":authority": {
	    "index": 1,
	    "values": {
	      "": 1
	    }
	  },
	  ":method": {
	    "index": 2,
	    "values": {
	      "GET": 2,
	      "POST": 3
	    }
	  },
	  ":path": {
	    "index": 4,
	    "values": {
	      "/": 4,
	      "/index.html": 5
	    }
	  },
	  ":scheme": {
	    "index": 6,
	    "values": {
	      "http": 6,
	      "https": 7
	    }
	  },
	  ":status": {
	    "index": 8,
	    "values": {
	      "200": 8,
	      "204": 9,
	      "206": 10,
	      "304": 11,
	      "400": 12,
	      "404": 13,
	      "500": 14
	    }
	  },
	  "accept-charset": {
	    "index": 15,
	    "values": {
	      "": 15
	    }
	  },
	  "accept-encoding": {
	    "index": 16,
	    "values": {
	      "gzip, deflate": 16
	    }
	  },
	  "accept-language": {
	    "index": 17,
	    "values": {
	      "": 17
	    }
	  },
	  "accept-ranges": {
	    "index": 18,
	    "values": {
	      "": 18
	    }
	  },
	  "accept": {
	    "index": 19,
	    "values": {
	      "": 19
	    }
	  },
	  "access-control-allow-origin": {
	    "index": 20,
	    "values": {
	      "": 20
	    }
	  },
	  "age": {
	    "index": 21,
	    "values": {
	      "": 21
	    }
	  },
	  "allow": {
	    "index": 22,
	    "values": {
	      "": 22
	    }
	  },
	  "authorization": {
	    "index": 23,
	    "values": {
	      "": 23
	    }
	  },
	  "cache-control": {
	    "index": 24,
	    "values": {
	      "": 24
	    }
	  },
	  "content-disposition": {
	    "index": 25,
	    "values": {
	      "": 25
	    }
	  },
	  "content-encoding": {
	    "index": 26,
	    "values": {
	      "": 26
	    }
	  },
	  "content-language": {
	    "index": 27,
	    "values": {
	      "": 27
	    }
	  },
	  "content-length": {
	    "index": 28,
	    "values": {
	      "": 28
	    }
	  },
	  "content-location": {
	    "index": 29,
	    "values": {
	      "": 29
	    }
	  },
	  "content-range": {
	    "index": 30,
	    "values": {
	      "": 30
	    }
	  },
	  "content-type": {
	    "index": 31,
	    "values": {
	      "": 31
	    }
	  },
	  "cookie": {
	    "index": 32,
	    "values": {
	      "": 32
	    }
	  },
	  "date": {
	    "index": 33,
	    "values": {
	      "": 33
	    }
	  },
	  "etag": {
	    "index": 34,
	    "values": {
	      "": 34
	    }
	  },
	  "expect": {
	    "index": 35,
	    "values": {
	      "": 35
	    }
	  },
	  "expires": {
	    "index": 36,
	    "values": {
	      "": 36
	    }
	  },
	  "from": {
	    "index": 37,
	    "values": {
	      "": 37
	    }
	  },
	  "host": {
	    "index": 38,
	    "values": {
	      "": 38
	    }
	  },
	  "if-match": {
	    "index": 39,
	    "values": {
	      "": 39
	    }
	  },
	  "if-modified-since": {
	    "index": 40,
	    "values": {
	      "": 40
	    }
	  },
	  "if-none-match": {
	    "index": 41,
	    "values": {
	      "": 41
	    }
	  },
	  "if-range": {
	    "index": 42,
	    "values": {
	      "": 42
	    }
	  },
	  "if-unmodified-since": {
	    "index": 43,
	    "values": {
	      "": 43
	    }
	  },
	  "last-modified": {
	    "index": 44,
	    "values": {
	      "": 44
	    }
	  },
	  "link": {
	    "index": 45,
	    "values": {
	      "": 45
	    }
	  },
	  "location": {
	    "index": 46,
	    "values": {
	      "": 46
	    }
	  },
	  "max-forwards": {
	    "index": 47,
	    "values": {
	      "": 47
	    }
	  },
	  "proxy-authenticate": {
	    "index": 48,
	    "values": {
	      "": 48
	    }
	  },
	  "proxy-authorization": {
	    "index": 49,
	    "values": {
	      "": 49
	    }
	  },
	  "range": {
	    "index": 50,
	    "values": {
	      "": 50
	    }
	  },
	  "referer": {
	    "index": 51,
	    "values": {
	      "": 51
	    }
	  },
	  "refresh": {
	    "index": 52,
	    "values": {
	      "": 52
	    }
	  },
	  "retry-after": {
	    "index": 53,
	    "values": {
	      "": 53
	    }
	  },
	  "server": {
	    "index": 54,
	    "values": {
	      "": 54
	    }
	  },
	  "set-cookie": {
	    "index": 55,
	    "values": {
	      "": 55
	    }
	  },
	  "strict-transport-security": {
	    "index": 56,
	    "values": {
	      "": 56
	    }
	  },
	  "transfer-encoding": {
	    "index": 57,
	    "values": {
	      "": 57
	    }
	  },
	  "user-agent": {
	    "index": 58,
	    "values": {
	      "": 58
	    }
	  },
	  "vary": {
	    "index": 59,
	    "values": {
	      "": 59
	    }
	  },
	  "via": {
	    "index": 60,
	    "values": {
	      "": 60
	    }
	  },
	  "www-authenticate": {
	    "index": 61,
	    "values": {
	      "": 61
	    }
	  }
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var hpack = __webpack_require__(185);
	var utils = hpack.utils;
	var assert = utils.assert;

	function Table(options) {
	  this['static'] = hpack['static-table'];
	  this.dynamic = [];
	  this.size = 0;
	  this.maxSize = 0;
	  this.length = this['static'].table.length;
	  this.protocolMaxSize = options.maxSize;
	  this.maxSize = this.protocolMaxSize;
	  this.lookupDepth = options.lookupDepth || 32;
	}
	module.exports = Table;

	Table.create = function create(options) {
	  return new Table(options);
	};

	Table.prototype.lookup = function lookup(index) {
	  assert(index !== 0, 'Zero indexed field');
	  assert(index <= this.length, 'Indexed field OOB')

	  if (index <= this['static'].table.length)
	    return this['static'].table[index - 1];
	  else
	    return this.dynamic[this.length - index];
	};

	Table.prototype.reverseLookup = function reverseLookup(name, value) {
	  var staticEntry = this['static'].map[name];
	  if (staticEntry && staticEntry.values[value])
	    return staticEntry.values[value];

	  // Reverse search dynamic table (new items are at the end of it)
	  var limit = Math.max(0, this.dynamic.length - this.lookupDepth);
	  for (var i = this.dynamic.length - 1; i >= limit; i--) {
	    var entry = this.dynamic[i];
	    if (entry.name === name && entry.value === value)
	      return this.length - i;

	    if (entry.name === name) {
	      // Prefer smaller index
	      if (staticEntry)
	        break;
	      return -(this.length - i);
	    }
	  }

	  if (staticEntry)
	    return -staticEntry.index;

	  return 0;
	};

	Table.prototype.add = function add(name, value, nameSize, valueSize) {
	  var totalSize = nameSize + valueSize + 32;

	  this.dynamic.push({
	    name: name,
	    value: value,
	    nameSize: nameSize,
	    totalSize: totalSize
	  });
	  this.size += totalSize;
	  this.length++;

	  this.evict();
	};

	Table.prototype.evict = function evict() {
	  while (this.size > this.maxSize) {
	    var entry = this.dynamic.shift();
	    this.size -= entry.totalSize;
	    this.length--;
	  }
	  assert(this.size >= 0, 'Table size sanity check failed');
	};

	Table.prototype.updateSize = function updateSize(size) {
	  assert(size <= this.protocolMaxSize, 'Table size bigger than maximum');
	  this.maxSize = size;
	  this.evict();
	};


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var hpack = __webpack_require__(185);
	var utils = hpack.utils;
	var huffman = hpack.huffman.decode;
	var assert = utils.assert;

	var OffsetBuffer = __webpack_require__(170);

	function Decoder() {
	  this.buffer = new OffsetBuffer();
	  this.bitOffset = 0;

	  // Used internally in decodeStr
	  this._huffmanNode = null;
	}
	module.exports = Decoder;

	Decoder.create = function create() {
	  return new Decoder();
	};

	Decoder.prototype.isEmpty = function isEmpty() {
	  return this.buffer.isEmpty();
	};

	Decoder.prototype.push = function push(chunk) {
	  this.buffer.push(chunk);
	};

	Decoder.prototype.decodeBit = function decodeBit() {
	  // Need at least one octet
	  assert(this.buffer.has(1), 'Buffer too small for an int');

	  var octet;
	  var offset = this.bitOffset;

	  if (++this.bitOffset === 8) {
	    octet = this.buffer.readUInt8();
	    this.bitOffset = 0;
	  } else {
	    octet = this.buffer.peekUInt8();
	  }
	  return (octet >>> (7 - offset)) & 1;
	};

	// Just for testing
	Decoder.prototype.skipBits = function skipBits(n) {
	  this.bitOffset += n;
	  this.buffer.skip(this.bitOffset >> 3);
	  this.bitOffset &= 0x7;
	};

	Decoder.prototype.decodeInt = function decodeInt() {
	  // Need at least one octet
	  assert(this.buffer.has(1), 'Buffer too small for an int');

	  var prefix = 8 - this.bitOffset;

	  // We are going to end up octet-aligned
	  this.bitOffset = 0;

	  var max = (1 << prefix) - 1;
	  var octet = this.buffer.readUInt8() & max;

	  // Fast case - int fits into the prefix
	  if (octet !== max)
	    return octet;

	  // TODO(indutny): what about > 32bit numbers?
	  var res = 0;
	  var isLast = false;
	  var len = 0;
	  do {
	    octet = this.buffer.readUInt8();
	    isLast = (octet & 0x80) === 0;

	    res <<= 7;
	    res |= octet & 0x7f;
	    len++;
	  } while (!isLast);
	  assert(isLast, 'Incomplete data for multi-octet integer');
	  assert(len <= 4, 'Integer does not fit into 32 bits');

	  // Reverse bits
	  res = (res >>> 21) |
	        (((res >> 14) & 0x7f) << 7) |
	        (((res >> 7) & 0x7f) << 14) |
	        ((res & 0x7f) << 21);
	  res >>= (4 - len) * 7;

	  // Append prefix max
	  res += max;

	  return res;
	};

	Decoder.prototype.decodeHuffmanWord = function decodeHuffmanWord(input,
	                                                                 inputBits,
	                                                                 out) {
	  var root = huffman;
	  var node = this._huffmanNode;
	  var word = input;
	  var bits = inputBits;

	  for (; bits > 0; word &= (1 << bits) - 1) {
	    // Nudge the word bit length to match it
	    for (var i = Math.max(0, bits - 8); i < bits; i++) {
	      var subnode = node[word >>> i];
	      if (typeof subnode !== 'number') {
	        node = subnode;
	        bits = i;
	        break;
	      }

	      if (subnode === 0)
	        continue;

	      // Word bit length should match
	      if ((subnode >>> 9) !== bits - i) {
	        subnode = 0;
	        continue;
	      }

	      var octet = subnode & 0x1ff;
	      assert(octet !== 256, 'EOS in encoding');
	      out.push(octet);
	      node = root;

	      bits = i;
	      break;
	    }
	    if (subnode === 0)
	      break;
	  }
	  this._huffmanNode = node;

	  return bits;
	};

	Decoder.prototype.decodeStr = function decodeStr() {
	  var isHuffman = this.decodeBit();
	  var len = this.decodeInt();
	  assert(this.buffer.has(len), 'Not enough octets for string');

	  if (!isHuffman)
	    return this.buffer.take(len);

	  this._huffmanNode = huffman;

	  var out = [];

	  var word = 0;
	  var bits = 0;
	  var lastKey = 0;
	  for (var i = 0; i < len; i++) {
	    word <<= 8;
	    word |= this.buffer.readUInt8();
	    bits += 8;

	    bits = this.decodeHuffmanWord(word, bits, out);
	    lastKey = word >> bits;
	    word &= (1 << bits) - 1;
	  }
	  assert(this._huffmanNode === huffman, '8-bit EOS');
	  assert(word + 1 === (1 << bits), 'Final sequence is not EOS');

	  this._huffmanNode = null;

	  return out;
	};


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var hpack = __webpack_require__(185);
	var utils = hpack.utils;
	var decoder = hpack.decoder;
	var table = hpack.table;
	var assert = utils.assert;

	var inherits = __webpack_require__(46);
	var Duplex = __webpack_require__(156).Duplex;

	function Decompressor(options) {
	  Duplex.call(this, {
	    readableObjectMode: true
	  });

	  this._decoder = decoder.create();
	  this._table = table.create(options.table);
	}
	inherits(Decompressor, Duplex);
	module.exports = Decompressor;

	Decompressor.create = function create(options) {
	  return new Decompressor(options);
	};

	Decompressor.prototype._read = function _read() {
	  // We only push!
	};

	Decompressor.prototype._write = function _write(data, enc, cb) {
	  this._decoder.push(data);

	  cb(null);
	};

	Decompressor.prototype.execute = function execute(cb) {
	  while (!this._decoder.isEmpty()) {
	    try {
	      this._execute();
	    } catch (err) {
	      if (cb)
	        return done(err);
	      else
	        return this.emit('error', err);
	    }
	  }

	  if (cb)
	    done(null);

	  function done(err) {
	    process.nextTick(function() {
	      cb(err);
	    });
	  }
	};

	Decompressor.prototype.updateTableSize = function updateTableSize(size) {
	  this._table.updateSize(size);
	};

	Decompressor.prototype._execute = function _execute() {
	  var isIndexed = this._decoder.decodeBit();
	  if (isIndexed)
	    return this._processIndexed();

	  var isIncremental = this._decoder.decodeBit();
	  var neverIndex = 0;
	  if (!isIncremental) {
	    var isUpdate = this._decoder.decodeBit();
	    if (isUpdate)
	      return this._processUpdate();

	    neverIndex = this._decoder.decodeBit();
	  }

	  this._processLiteral(isIncremental, neverIndex);
	};

	Decompressor.prototype._processIndexed = function _processIndexed() {
	  var index = this._decoder.decodeInt();

	  var lookup = this._table.lookup(index);
	  this.push({ name: lookup.name, value: lookup.value, neverIndex: false });
	};

	Decompressor.prototype._processLiteral = function _processLiteral(inc, never) {
	  var index = this._decoder.decodeInt();

	  var name;
	  var nameSize;

	  // Literal header-name too
	  if (index === 0) {
	    name = this._decoder.decodeStr();
	    nameSize = name.length;
	    name = utils.stringify(name);
	  } else {
	    var lookup = this._table.lookup(index);
	    nameSize = lookup.nameSize;
	    name = lookup.name;
	  }

	  var value = this._decoder.decodeStr();
	  var valueSize = value.length;
	  value = utils.stringify(value);

	  if (inc)
	    this._table.add(name, value, nameSize, valueSize);

	  this.push({ name: name, value: value, neverIndex: never !== 0});
	};

	Decompressor.prototype._processUpdate = function _processUpdate() {
	  var size = this._decoder.decodeInt();
	  this.updateTableSize(size);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var hpack = __webpack_require__(185);
	var utils = hpack.utils;
	var huffman = hpack.huffman.encode;
	var assert = utils.assert;

	var WBuf = __webpack_require__(177);

	function Encoder() {
	  this.buffer = new WBuf();
	  this.word = 0;
	  this.bitOffset = 0;
	}
	module.exports = Encoder;

	Encoder.create = function create() {
	  return new Encoder();
	};

	Encoder.prototype.render = function render() {
	  return this.buffer.render();
	};

	Encoder.prototype.encodeBit = function encodeBit(bit) {
	  var octet;

	  this.word <<= 1;
	  this.word |= bit;
	  this.bitOffset++;

	  if (this.bitOffset === 8) {
	    this.buffer.writeUInt8(this.word);
	    this.word = 0;
	    this.bitOffset = 0;
	  }
	};

	Encoder.prototype.encodeBits = function encodeBits(bits, len) {
	  var left = bits;
	  var leftLen = len;

	  while (leftLen > 0) {
	    var avail = Math.min(leftLen, 8 - this.bitOffset);
	    var toWrite = left >>> (leftLen - avail);

	    if (avail === 8) {
	      this.buffer.writeUInt8(toWrite);
	    } else {
	      this.word <<= avail;
	      this.word |= toWrite;
	      this.bitOffset += avail;
	      if (this.bitOffset === 8) {
	        this.buffer.writeUInt8(this.word);
	        this.word = 0;
	        this.bitOffset = 0;
	      }
	    }

	    leftLen -= avail;
	    left &= (1 << leftLen) - 1;
	  }
	};

	// Just for testing
	Encoder.prototype.skipBits = function skipBits(num) {
	  this.bitOffset += num;
	  this.buffer.skip(this.bitOffset >> 3);
	  this.bitOffset &= 0x7;
	};

	Encoder.prototype.encodeInt = function encodeInt(num) {
	  var prefix = 8 - this.bitOffset;

	  // We are going to end up octet-aligned
	  this.bitOffset = 0;

	  var max = (1 << prefix) - 1;

	  // Fast case - int fits into the prefix
	  if (num < max) {
	    this.buffer.writeUInt8((this.word << prefix) | num);
	    return octet;
	  }

	  var left = num - max;
	  this.buffer.writeUInt8((this.word << prefix) | max);
	  do {
	    var octet = left & 0x7f;
	    left >>= 7;
	    if (left !== 0)
	      octet |= 0x80;

	    this.buffer.writeUInt8(octet);
	  } while (left !== 0);
	};

	Encoder.prototype.encodeStr = function encodeStr(value, isHuffman) {
	  this.encodeBit(isHuffman ? 1 : 0);

	  if (!isHuffman) {
	    this.buffer.reserve(value.length + 1);
	    this.encodeInt(value.length);
	    for (var i = 0; i < value.length; i++)
	      this.buffer.writeUInt8(value[i]);
	    return;
	  }

	  var codes = [];
	  var len = 0;
	  var pad = 0;

	  for (var i = 0; i < value.length; i++) {
	    var code = huffman[value[i]];
	    codes.push(code);
	    len += code[0];
	  }
	  if (len % 8 !== 0)
	    pad = 8 - (len % 8);
	  len += pad;

	  this.buffer.reserve((len / 8) + 1);
	  this.encodeInt(len / 8);
	  for (var i = 0; i < codes.length; i++) {
	    var code = codes[i];
	    this.encodeBits(code[1], code[0]);
	  }

	  // Append padding
	  this.encodeBits(0xff >>> (8 - pad), pad);
	};


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var hpack = __webpack_require__(185);
	var utils = hpack.utils;
	var encoder = hpack.encoder;
	var table = hpack.table;
	var assert = utils.assert;

	var inherits = __webpack_require__(46);
	var Duplex = __webpack_require__(156).Duplex;

	function Compressor(options) {
	  Duplex.call(this, {
	    writableObjectMode: true
	  });

	  this._encoder = null;
	  this._table = table.create(options.table);
	}
	inherits(Compressor, Duplex);
	module.exports = Compressor;

	Compressor.create = function create(options) {
	  return new Compressor(options);
	};

	Compressor.prototype._read = function _read() {
	  // We only push!
	};

	Compressor.prototype._write = function _write(data, enc, cb) {
	  assert(Array.isArray(data), 'Compressor.write() expects list of headers');

	  this._encoder = encoder.create();
	  for (var i = 0; i < data.length; i++)
	    this._encodeHeader(data[i]);

	  var data = this._encoder.render();
	  this._encoder = null;

	  cb(null);
	  for (var i = 0; i < data.length; i++)
	    this.push(data[i]);
	};

	Compressor.prototype.updateTableSize = function updateTableSize(size) {
	  if (size >= this._table.protocolMaxSize) {
	    size = this._table.protocolMaxSize;

	    var enc = encoder.create();

	    // indexed = 0
	    // incremental = 0
	    // update = 1
	    enc.encodeBits(1, 3);
	    enc.encodeInt(size);

	    var data = enc.render();
	    for (var i = 0; i < data.length; i++)
	      this.push(data[i]);
	  }

	  this._table.updateSize(size);
	};

	Compressor.prototype.reset = function reset() {
	  var enc = encoder.create();
	  var size = this._table.maxSize;

	  // indexed = 0
	  // incremental = 0
	  // update = 1
	  enc.encodeBits(1, 3);
	  enc.encodeInt(0);

	  // Evict everything
	  this._table.updateSize(0);

	  // indexed = 0
	  // incremental = 0
	  // update = 1
	  enc.encodeBits(1, 3);
	  enc.encodeInt(size);

	  // Revert size
	  this._table.updateSize(size);

	  var data = enc.render();
	  for (var i = 0; i < data.length; i++)
	    this.push(data[i]);
	};

	Compressor.prototype._encodeHeader = function _encodeHeader(header) {
	  if (header.neverIndex) {
	    var index = 0;
	    var neverIndex = 1;
	    var isIndexed = 0;
	    var isIncremental = 0;
	  } else {
	    var index = this._table.reverseLookup(header.name, header.value);
	    var isIndexed = index > 0;
	    var isIncremental = header.incremental !== false;
	    var neverIndex = 0;
	  }

	  this._encoder.encodeBit(isIndexed);
	  if (isIndexed) {
	    this._encoder.encodeInt(index);
	    return;
	  }

	  var name = utils.toArray(header.name);
	  var value = utils.toArray(header.value);

	  this._encoder.encodeBit(isIncremental);
	  if (isIncremental) {
	    this._table.add(header.name, header.value, name.length, value.length);
	  } else {
	    // Update = false
	    this._encoder.encodeBit(0);
	    this._encoder.encodeBit(neverIndex);
	  }

	  // index is negative for `name`-only headers
	  this._encoder.encodeInt(-index);
	  if (index === 0)
	    this._encoder.encodeStr(name, header.huffman !== false);
	  this._encoder.encodeStr(value, header.huffman !== false);
	};


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var util = __webpack_require__(10);
	var EventEmitter = __webpack_require__(14).EventEmitter;
	var debug = {
	  server: __webpack_require__(153)('spdy:window:server'),
	  client: __webpack_require__(153)('spdy:window:client')
	};

	function Side(window, name, options) {
	  EventEmitter.call(this);

	  this.name = name;
	  this.window = window;
	  this.current = options.size;
	  this.max = options.size;
	  this.limit = options.max;
	  this.lowWaterMark = options.lowWaterMark === undefined ?
	      this.max / 2 :
	      options.lowWaterMark;

	  this._refilling = false;
	  this._refillQueue = [];
	}
	util.inherits(Side, EventEmitter);

	Side.prototype.setMax = function setMax(max) {
	  this.window.debug('id=%d side=%s setMax=%d',
	                    this.window.id,
	                    this.name,
	                    max);
	  this.max = max;
	  this.lowWaterMark = this.max / 2;
	};

	Side.prototype.updateMax = function updateMax(max) {
	  var delta = max - this.max;
	  this.window.debug('id=%d side=%s updateMax=%d delta=%d',
	                    this.window.id,
	                    this.name,
	                    max,
	                    delta);

	  this.max = max;
	  this.lowWaterMark = max / 2;

	  this.update(delta);
	};

	Side.prototype.setLowWaterMark = function setLowWaterMark(lwm) {
	  this.lowWaterMark = lwm;
	};

	Side.prototype.update = function update(size, callback) {
	  // Not enough space for the update, wait for refill
	  if (size <= 0 && callback && this.isEmpty()) {
	    this.window.debug('id=%d side=%s wait for refill=%d [%d/%d]',
	                      this.window.id,
	                      this.name,
	                      -size,
	                      this.current,
	                      this.max);
	    this._refillQueue.push({
	      size: size,
	      callback: callback
	    });
	    return;
	  }

	  this.current += size;

	  if (this.current > this.limit) {
	    this.emit('overflow');
	    return;
	  }

	  this.window.debug('id=%d side=%s update by=%d [%d/%d]',
	                    this.window.id,
	                    this.name,
	                    size,
	                    this.current,
	                    this.max);

	  // Time to send WINDOW_UPDATE
	  if (size < 0 && this.isDraining()) {
	    this.window.debug('id=%d side=%s drained', this.window.id, this.name);
	    this.emit('drain');
	  }

	  // Time to write
	  if (size > 0 && this.current > 0 && this.current <= size) {
	    this.window.debug('id=%d side=%s full', this.window.id, this.name);
	    this.emit('full');
	  }

	  this._processRefillQueue();

	  if (callback)
	    process.nextTick(callback);
	};

	Side.prototype.getCurrent = function getCurrent() {
	  return this.current;
	};

	Side.prototype.getMax = function getMax() {
	  return this.max;
	};

	Side.prototype.getDelta = function getDelta() {
	  return this.max - this.current;
	};

	Side.prototype.isDraining = function isDraining() {
	  return this.current <= this.lowWaterMark;
	};

	Side.prototype.isEmpty = function isEmpty() {
	  return this.current <= 0;
	};

	// Private

	Side.prototype._processRefillQueue = function _processRefillQueue() {
	  // Prevent recursion
	  if (this._refilling)
	    return;
	  this._refilling = true;

	  while (this._refillQueue.length > 0) {
	    var item = this._refillQueue[0];

	    if (this.isEmpty())
	      break;

	    this.window.debug('id=%d side=%s refilled for size=%d',
	                      this.window.id,
	                      this.name,
	                      -item.size);

	    this._refillQueue.shift();
	    this.update(item.size, item.callback);
	  }

	  this._refilling = false;
	};

	function Window(options) {
	  this.id = options.id;
	  this.isServer = options.isServer;
	  this.debug = this.isServer ? debug.server : debug.client;

	  this.recv = new Side(this, 'recv', options.recv);
	  this.send = new Side(this, 'send', options.send);
	}
	module.exports = Window;

	Window.prototype.clone = function clone(id) {
	  return new Window({
	    id: id,
	    isServer: this.isServer,
	    recv: {
	      size: this.recv.max,
	      max: this.recv.limit,
	      lowWaterMark: this.recv.lowWaterMark
	    },
	    send: {
	      size: this.send.max,
	      max: this.send.limit,
	      lowWaterMark: this.send.lowWaterMark
	    }
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var transport = __webpack_require__(147);
	var utils = transport.utils;

	var assert = __webpack_require__(9);
	var debug = __webpack_require__(153)('spdy:priority');

	function PriorityNode(tree, options) {
	  this.tree = tree;

	  this.id = options.id;
	  this.parent = options.parent;
	  this.weight = options.weight;

	  // To be calculated in `addChild`
	  this.priorityFrom = 0;
	  this.priorityTo = 1;
	  this.priority = 1;

	  this.children = {
	    list: [],
	    weight: 0
	  };

	  if (this.parent !== null)
	    this.parent.addChild(this);
	}

	function compareChildren(a, b) {
	  return a.weight === b.weight ? a.id - b.id : a.weight - b.weight;
	}

	PriorityNode.prototype.toJSON = function toJSON() {
	  return {
	    parent: this.parent,
	    weight: this.weight,
	    exclusive: this.exclusive
	  };
	};

	PriorityNode.prototype.getPriority = function getPriority() {
	  return this.priority;
	};

	PriorityNode.prototype.getPriorityRange = function getPriorityRange() {
	  return { from: this.priorityFrom, to: this.priorityTo };
	};

	PriorityNode.prototype.addChild = function addChild(child) {
	  child.parent = this;
	  utils.binaryInsert(this.children.list, child, compareChildren);
	  this.children.weight += child.weight;

	  this._updatePriority(this.priorityFrom, this.priorityTo);
	};

	PriorityNode.prototype.remove = function remove() {
	  assert(this.parent, 'Can\'t remove root node');

	  this.parent.removeChild(this);
	  this.tree._removeNode(this);

	  // Move all children to the parent
	  for (var i = 0; i < this.children.list.length; i++)
	    this.parent.addChild(this.children.list[i]);
	};

	PriorityNode.prototype.removeChild = function removeChild(child) {
	  this.children.weight -= child.weight;
	  var index = utils.binarySearch(this.children.list, child, compareChildren);
	  assert(index !== -1);

	  // Remove the child
	  this.children.list.splice(index, 1);
	};

	PriorityNode.prototype.removeChildren = function removeChildren() {
	  var children = this.children.list;
	  this.children.list = [];
	  this.children.weight = 0;
	  return children;
	};

	PriorityNode.prototype._updatePriority = function _updatePriority(from, to) {
	  this.priority = to - from;
	  this.priorityFrom = from;
	  this.priorityTo = to;

	  var weight = 0;
	  for (var i = 0; i < this.children.list.length; i++) {
	    var node = this.children.list[i];
	    var nextWeight = weight + node.weight;

	    node._updatePriority(
	      from + this.priority * (weight / this.children.weight),
	      from + this.priority * (nextWeight / this.children.weight)
	    );
	    weight = nextWeight;
	  }
	};

	function PriorityTree(options) {
	  this.map = {};
	  this.list = [];
	  this.defaultWeight = options.defaultWeight || 16;

	  this.count = 0;
	  this.maxCount = options.maxCount;

	  // Root
	  this.root = this.add({
	    id: 0,
	    parent: null,
	    weight: 1
	  });
	}
	module.exports = PriorityTree;

	PriorityTree.create = function create(options) {
	  return new PriorityTree(options);
	};

	PriorityTree.prototype.add = function add(options) {
	  if (options.id === options.parent)
	    return this.addDefault(options.id);

	  var parent = options.parent === null ? null : this.map[options.parent];
	  if (parent === undefined)
	    return this.addDefault(options.id);

	  debug('add node=%d parent=%d weight=%d exclusive=%d',
	        options.id,
	        options.parent === null ? -1 : options.parent,
	        options.weight || this.defaultWeight,
	        options.exclusive ? 1 : 0);

	  var children;
	  if (options.exclusive)
	    children = parent.removeChildren();

	  var node = new PriorityNode(this, {
	    id: options.id,
	    parent: parent,
	    weight: options.weight || this.defaultWeight
	  });
	  this.map[options.id] = node;

	  if (options.exclusive) {
	    for (var i = 0; i < children.length; i++)
	      node.addChild(children[i]);
	  }

	  this.count++;
	  if (this.count > this.maxCount) {
	    debug('hit maximum remove id=%d', this.list[0].id);
	    this.list.shift().remove();
	  }

	  // Root node is not subject to removal
	  if (node.parent !== null)
	    this.list.push(node);

	  return node;
	};

	// Only for testing, should use `node`'s methods
	PriorityTree.prototype.get = function get(id) {
	  return this.map[id];
	};

	PriorityTree.prototype.addDefault = function addDefault(id) {
	  debug('creating default node');
	  return this.add({ id: id, parent: 0, weight: this.defaultWeight });
	};

	PriorityTree.prototype._removeNode = function _removeNode(node) {
	  delete this.map[node.id];
	  this.count--;
	};


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var transport = __webpack_require__(147);

	var assert = __webpack_require__(9);
	var util = __webpack_require__(10);
	var debug = {
	  client: __webpack_require__(153)('spdy:stream:client'),
	  server: __webpack_require__(153)('spdy:stream:server')
	};
	var Buffer = __webpack_require__(5).Buffer;
	var Duplex = __webpack_require__(156).Duplex;

	function Stream(connection, options) {
	  Duplex.call(this);

	  var connectionState = connection._spdyState;

	  var state = {};
	  this._spdyState = state;

	  this.id = options.id;
	  this.method = options.method;
	  this.path = options.path;
	  this.host = options.host;
	  this.headers = options.headers || {};
	  this.connection = connection;
	  this.parent = options.parent || null;

	  state.socket = null;
	  state.protocol = connectionState.protocol;
	  state.constants = state.protocol.constants;

	  // See _initPriority()
	  state.priority = null;

	  state.version = this.connection.getVersion();
	  state.isServer = this.connection.isServer();
	  state.debug = state.isServer ? debug.server : debug.client;

	  state.framer = connectionState.framer;
	  state.parser = connectionState.parser;

	  state.request = options.request;
	  state.needResponse = options.request;
	  state.window = connectionState.streamWindow.clone(options.id);
	  state.sessionWindow = connectionState.window;
	  state.maxChunk = connectionState.maxChunk;

	  // Can't send incoming request
	  // (See `.send()` method)
	  state.sent = !state.request;

	  state.readable = options.readable !== false;
	  state.writable = options.writable !== false;

	  state.aborted = false;

	  state.corked = 0;
	  state.corkQueue = [];

	  state.timeout = new transport.utils.Timeout(this);

	  this.on('finish', this._onFinish);
	  this.on('end', this._onEnd);

	  var self = this;
	  function _onWindowOverflow() {
	    self._onWindowOverflow();
	  }

	  state.window.recv.on('overflow', _onWindowOverflow);
	  state.window.send.on('overflow', _onWindowOverflow);

	  this._initPriority(options.priority);

	  if (!state.readable)
	    this.push(null);
	  if (!state.writable) {
	    this._writableState.ended = true;
	    this._writableState.finished = true;
	  }
	}
	util.inherits(Stream, Duplex);
	exports.Stream = Stream;

	Stream.prototype._init = function _init(socket) {
	  this.socket = socket;
	};

	Stream.prototype._initPriority = function _initPriority(priority) {
	  var state = this._spdyState;
	  var connectionState = this.connection._spdyState;
	  var root = connectionState.priorityRoot;

	  if (!priority) {
	    state.priority = root.addDefault(this.id);
	    return;
	  }

	  state.priority = root.add({
	    id: this.id,
	    parent: priority.parent,
	    weight: priority.weight,
	    exclusive: priority.exclusive
	  });
	};

	Stream.prototype._handleFrame = function _handleFrame(frame) {
	  var state = this._spdyState;

	  // Ignore any kind of data after abort
	  if (state.aborted) {
	    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type);
	    return;
	  }

	  // Restart the timer on incoming frames
	  state.timeout.reset();

	  if (frame.type === 'DATA')
	    this._handleData(frame);
	  else if (frame.type === 'HEADERS')
	    this._handleHeaders(frame);
	  else if (frame.type === 'RST')
	    this._handleRST(frame);
	  else if (frame.type === 'WINDOW_UPDATE')
	    this._handleWindowUpdate(frame);
	  else if (frame.type === 'PRIORITY')
	    this._handlePriority(frame);
	  else if (frame.type === 'PUSH_PROMISE')
	    this._handlePushPromise(frame);

	  if (frame.fin) {
	    state.debug('id=%d end', this.id);
	    this.push(null);
	  }
	};

	function checkAborted(stream, state, callback) {
	  if (state.aborted) {
	    state.debug('id=%d abort write', stream.id);
	    process.nextTick(function() {
	      callback(new Error('Stream write aborted'));
	    });
	    return true;
	  }

	  return false;
	}

	function _send(stream, state, data, callback) {
	  if (checkAborted(stream, state, callback))
	    return;

	  state.debug('id=%d presend=%d', stream.id, data.length);

	  state.timeout.reset();

	  state.window.send.update(-data.length, function() {
	    if (checkAborted(stream, state, callback))
	      return;

	    state.debug('id=%d send=%d', stream.id, data.length);

	    state.timeout.reset();

	    state.framer.dataFrame({
	      id: stream.id,
	      priority: state.priority.getPriority(),
	      fin: false,
	      data: data
	    }, function(err) {
	      state.debug('id=%d postsend=%d', stream.id, data.length);
	      callback(err);
	    });
	  });
	}

	Stream.prototype._write = function _write(data, enc, callback) {
	  var state = this._spdyState;

	  // Send the request if it wasn't sent
	  if (!state.sent)
	    this.send();

	  // Writes should come after pending control frames (response and headers)
	  if (state.corked !== 0) {
	    var self = this;
	    state.corkQueue.push(function() {
	      self._write(data, enc, callback);
	    });
	    return;
	  }

	  // Split DATA in chunks to prevent window from going negative
	  this._splitStart(data, _send, callback);
	};

	Stream.prototype._splitStart = function _splitStart(data, onChunk, callback) {
	  return this._split(data, 0, onChunk, callback);
	};

	Stream.prototype._split = function _split(data, offset, onChunk, callback) {
	  if (offset === data.length)
	    return process.nextTick(callback);

	  var state = this._spdyState;
	  var local = state.window.send;
	  var session = state.sessionWindow.send;

	  var availSession = Math.max(0, session.getCurrent());
	  if (availSession === 0)
	    availSession = session.getMax();
	  var availLocal = Math.max(0, local.getCurrent());
	  if (availLocal === 0)
	    availLocal = local.getMax();

	  var avail = Math.min(availSession, availLocal);
	  avail = Math.min(avail, state.maxChunk);

	  if (avail === 0) {
	    var self = this;
	    state.window.send.update(0, function() {
	      self._split(data, offset, onChunk, callback);
	    });
	    return;
	  }

	  // Split data in chunks in a following way:
	  var limit = avail;
	  var size = Math.min(data.length - offset, limit);

	  var chunk = data.slice(offset, offset + size);

	  var self = this;
	  onChunk(this, state, chunk, function(err) {
	    if (err)
	      return callback(err);

	    // Get the next chunk
	    self._split(data, offset + size, onChunk, callback);
	  });
	};

	Stream.prototype._read = function _read() {
	  var state = this._spdyState;

	  if (!state.window.recv.isDraining())
	    return;

	  var delta = state.window.recv.getDelta();

	  state.debug('id=%d window emptying, update by %d', this.id, delta);

	  state.window.recv.update(delta);
	  state.framer.windowUpdateFrame({
	    id: this.id,
	    delta: delta
	  });
	};

	Stream.prototype._handleData = function _handleData(frame) {
	  var state = this._spdyState;

	  // DATA on ended or not readable stream!
	  if (!state.readable || this._readableState.ended) {
	    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' });
	    return;
	  }

	  state.debug('id=%d recv=%d', this.id, frame.data.length);
	  state.window.recv.update(-frame.data.length);

	  this.push(frame.data);
	};

	Stream.prototype._handleRST = function _handleRST(frame) {
	  if (frame.code !== 'CANCEL')
	    this.emit('error', new Error('Got RST: ' + frame.code));
	  this.abort();
	};

	Stream.prototype._handleWindowUpdate = function _handleWindowUpdate(frame) {
	  var state = this._spdyState;

	  state.window.send.update(frame.delta);
	};

	Stream.prototype._onWindowOverflow = function _onWindowOverflow() {
	  var state = this._spdyState;

	  state.debug('id=%d window overflow', this.id);
	  state.framer.rstFrame({ id: this.id, code: 'FLOW_CONTROL_ERROR' });

	  this.aborted = true;
	  this.emit('error', new Error('HTTP2 window overflow'));
	};

	Stream.prototype._handlePriority = function _handlePriority(frame) {
	  var state = this._spdyState;

	  state.priority.remove();
	  state.priority = null;
	  this._initPriority(frame.priority);

	  // Mostly for testing purposes
	  this.emit('priority', frame.priority);
	};

	Stream.prototype._handleHeaders = function _handleHeaders(frame) {
	  var state = this._spdyState;

	  if (!state.readable || this._readableState.ended) {
	    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' });
	    return;
	  }

	  if (state.needResponse)
	    return this._handleResponse(frame);

	  this.emit('headers', frame.headers);
	};

	Stream.prototype._handleResponse = function _handleResponse(frame) {
	  var state = this._spdyState;

	  if (frame.headers[':status'] === undefined) {
	    state.framer.rstFrame({ id: this.id, code: 'PROTOCOL_ERROR' });
	    return;
	  }

	  state.needResponse = false;
	  this.emit('response', frame.headers[':status'] | 0, frame.headers);
	};

	Stream.prototype._onFinish = function _onFinish() {
	  var state = this._spdyState;

	  // Send the request if it wasn't sent
	  if (!state.sent) {
	    // NOTE: will send HEADERS with FIN flag
	    this.send();
	  } else {
	    // Just an `.end()` without any writes will trigger immediate `finish` event
	    // without any calls to `_write()`.
	    if (state.corked !== 0) {
	      var self = this;
	      state.corkQueue.push(function() {
	        self._onFinish();
	      });
	      return;
	    }

	    state.framer.dataFrame({
	      id: this.id,
	      priority: state.priority.getPriority(),
	      fin: true,
	      data: new Buffer(0)
	    });
	  }

	  this._maybeClose();
	};

	Stream.prototype._onEnd = function _onEnd() {
	  this._maybeClose();
	};

	Stream.prototype._checkEnded = function _checkEnded(callback) {
	  var state = this._spdyState;

	  var ended = false;
	  if (state.aborted)
	    ended = true;

	  if (!state.writable || this._writableState.finished)
	    ended = true;

	  if (!ended)
	    return true;

	  if (!callback)
	    return false;

	  var err = new Error('Ended stream can\'t send frames');
	  process.nextTick(function() {
	    callback(err);
	  });

	  return false;
	};

	Stream.prototype._maybeClose = function _maybeClose() {
	  var state = this._spdyState;

	  // .abort() emits `close`
	  if (state.aborted)
	    return;

	  if ((!state.readable || this._readableState.ended) &&
	      this._writableState.finished) {
	    // Clear timeout
	    state.timeout.set(0);

	    this.emit('close');
	  }
	};

	Stream.prototype._handlePushPromise = function _handlePushPromise(frame) {
	  var push = this.connection._createStream({
	    id: frame.promisedId,
	    parent: this,
	    push: true,
	    request: true,
	    method: frame.headers[':method'],
	    path: frame.headers[':path'],
	    host: frame.headers[':authority'],
	    priority: frame.priority,
	    headers: frame.headers,
	    writable: false
	  });

	  // GOAWAY
	  if (this.connection._isGoaway(push.id))
	    return;

	  if (!this.emit('pushPromise', push))
	    push.abort();
	};

	Stream.prototype._hardCork = function _hardCork() {
	  var state = this._spdyState;

	  this.cork();
	  state.corked++;
	};

	Stream.prototype._hardUncork = function _hardUncork() {
	  var state = this._spdyState;

	  this.uncork();
	  state.corked--;
	  if (state.corked !== 0)
	    return;

	  // Invoke callbacks
	  var queue = state.corkQueue;
	  state.corkQueue = [];
	  for (var i = 0; i < queue.length; i++)
	    queue[i]();
	};

	Stream.prototype._sendPush = function _sendPush(status, response, callback) {
	  var self = this;
	  var state = this._spdyState;

	  this._hardCork();
	  state.framer.pushFrame({
	    id: this.parent.id,
	    promisedId: this.id,
	    priority: state.priority.toJSON(),
	    path: this.path,
	    host: this.host,
	    method: this.method,
	    status: status,
	    headers: this.headers,
	    response: response
	  }, function(err) {
	    self._hardUncork();

	    callback(err);
	  });
	};

	Stream.prototype._wasSent = function _wasSent() {
	  var state = this._spdyState;
	  return state.sent;
	};

	// Public API

	Stream.prototype.send = function send(callback) {
	  var state = this._spdyState;

	  if (state.sent) {
	    var err = new Error('Stream was already sent');
	    process.nextTick(function() {
	      if (callback)
	        callback(err);
	    });
	    return;
	  }

	  state.sent = true;
	  state.timeout.reset();

	  // GET requests should always be auto-finished
	  if (this.method === 'GET') {
	    this._writableState.ended = true;
	    this._writableState.finished = true;
	  }

	  // TODO(indunty): ideally it should just take a stream object as an input
	  var self = this;
	  this._hardCork();
	  state.framer.requestFrame({
	    id: this.id,
	    method: this.method,
	    path: this.path,
	    host: this.host,
	    priority: state.priority.toJSON(),
	    headers: this.headers,
	    fin: this._writableState.finished
	  }, function(err) {
	    self._hardUncork();

	    if (!callback)
	      return;

	    callback(err);
	  });
	};

	Stream.prototype.respond = function respond(status, headers, callback) {
	  var self = this;
	  var state = this._spdyState;
	  assert(!state.request, 'Can\'t respond on request');

	  state.timeout.reset();

	  if (!this._checkEnded(callback))
	    return;

	  var frame = {
	    id: this.id,
	    status: status,
	    headers: headers
	  };
	  this._hardCork();
	  state.framer.responseFrame(frame, function(err) {
	    self._hardUncork();
	    if (callback)
	      callback(err);
	  });
	};

	Stream.prototype.setWindow = function setWindow(size) {
	  var state = this._spdyState;

	  state.timeout.reset();

	  if (!this._checkEnded())
	    return;

	  state.debug('id=%d force window max=%d', this.id, size);
	  state.window.recv.setMax(size);

	  var delta = state.window.recv.getDelta();
	  if (delta === 0)
	    return;

	  state.framer.windowUpdateFrame({
	    id: this.id,
	    delta: delta
	  });
	  state.window.recv.update(delta);
	};

	Stream.prototype.sendHeaders = function sendHeaders(headers, callback) {
	  var self = this;
	  var state = this._spdyState;

	  state.timeout.reset();

	  if (!this._checkEnded(callback))
	    return;

	  // Request wasn't yet send, coalesce headers
	  if (!state.sent) {
	    this.headers = util._extend({}, this.headers);
	    util._extend(this.headers, headers);
	    process.nextTick(function() {
	      if (callback)
	        callback(null);
	    });
	    return;
	  }

	  this._hardCork();
	  state.framer.headersFrame({
	    id: this.id,
	    headers: headers
	  }, function(err) {
	    self._hardUncork();
	    if (callback)
	      callback(err);
	  });
	};

	Stream.prototype.destroy = function destroy() {
	  this.abort();
	};

	Stream.prototype.abort = function abort(code, callback) {
	  var state = this._spdyState;

	  // .abort(callback)
	  if (typeof code === 'function') {
	    callback = code;
	    code = null;
	  }

	  if (this._readableState.ended && this._writableState.finished) {
	    state.debug('id=%d already closed', this.id);
	    if (callback)
	      process.nextTick(callback);
	    return;
	  }

	  if (state.aborted) {
	    state.debug('id=%d already aborted', this.id);
	    if (callback)
	      process.nextTick(callback);
	    return;
	  }

	  state.aborted = true;
	  state.debug('id=%d abort', this.id);

	  this.setTimeout(0);

	  var abortCode = code || 'CANCEL';

	  state.framer.rstFrame({
	    id: this.id,
	    code: abortCode
	  });

	  var self = this;
	  process.nextTick(function() {
	    if (callback)
	      callback(null);
	    self.emit('close', new Error('Aborted, code: ' + abortCode));
	  });
	};

	Stream.prototype.setPriority = function setPriority(info) {
	  var state = this._spdyState;

	  state.timeout.reset();

	  if (!this._checkEnded())
	    return;

	  state.debug('id=%d priority change', this.id, info);

	  var frame = { id: this.id, priority: info };

	  // Change priority on this side
	  this._handlePriority(frame);

	  // And on the other too
	  state.framer.priorityFrame(frame);
	};

	Stream.prototype.pushPromise = function pushPromise(uri, callback) {
	  if (!this._checkEnded(callback))
	    return;

	  var self = this;
	  this._hardCork();
	  var push = this.connection.pushPromise(this, uri, function(err) {
	    self._hardUncork();
	    if (!err)
	      push._hardUncork();

	    if (callback)
	      return callback(err, push);

	    if (err)
	      push.emit('error', err);
	  });
	  push._hardCork();

	  return push;
	};

	Stream.prototype.setMaxChunk = function setMaxChunk(size) {
	  var state = this._spdyState;
	  state.maxChunk = size;
	};

	Stream.prototype.setTimeout = function setTimeout(delay, callback) {
	  var state = this._spdyState;

	  state.timeout.set(delay, callback);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {'use strict';

	var util = __webpack_require__(10);
	var transport = __webpack_require__(147);

	var debug = {
	  server: __webpack_require__(153)('spdy:connection:server'),
	  client: __webpack_require__(153)('spdy:connection:client')
	};
	var EventEmitter = __webpack_require__(14).EventEmitter;

	var Stream = transport.Stream;

	function Connection(socket, options) {
	  EventEmitter.call(this);

	  var state = {};
	  this._spdyState = state;

	  // NOTE: There's a big trick here. Connection is used as a `this` argument
	  // to the wrapped `connection` event listener.
	  // socket end doesn't necessarly mean connection drop
	  this.httpAllowHalfOpen = true;

	  state.timeout = new transport.utils.Timeout(this);

	  // Protocol info
	  state.protocol = transport.protocol[options.protocol];
	  state.version = null;
	  state.constants = state.protocol.constants;
	  state.pair = null;
	  state.isServer = options.isServer;

	  // Root of priority tree (i.e. stream id = 0)
	  state.priorityRoot = new transport.Priority({
	    defaultWeight: state.constants.DEFAULT_WEIGHT,
	    maxCount: transport.protocol.base.constants.MAX_PRIORITY_STREAMS
	  });

	  // Defaults
	  state.maxStreams = options.maxStreams ||
	                     state.constants.MAX_CONCURRENT_STREAMS;

	  state.autoSpdy31 = options.protocol.name !== 'h2' && options.autoSpdy31;
	  state.acceptPush = options.acceptPush === undefined ?
	      !state.isServer :
	      options.acceptPush;

	  if (options.maxChunk === false)
	    state.maxChunk = Infinity;
	  else if (options.maxChunk === undefined)
	    state.maxChunk = transport.protocol.base.constants.DEFAULT_MAX_CHUNK;
	  else
	    state.maxChunk = options.maxChunk;

	  // Connection-level flow control
	  var windowSize = options.windowSize || 1 << 20;
	  state.window = new transport.Window({
	    id: 0,
	    isServer: state.isServer,
	    recv: {
	      size: state.constants.DEFAULT_WINDOW,
	      max: state.constants.MAX_INITIAL_WINDOW_SIZE
	    },
	    send: {
	      size: state.constants.DEFAULT_WINDOW,
	      max: state.constants.MAX_INITIAL_WINDOW_SIZE
	    }
	  });

	  // It starts with DEFAULT_WINDOW, update must be sent to change it on client
	  state.window.recv.setMax(windowSize);

	  // Boilerplate for Stream constructor
	  state.streamWindow = new transport.Window({
	    id: -1,
	    isServer: state.isServer,
	    recv: {
	      size: windowSize,
	      max: state.constants.MAX_INITIAL_WINDOW_SIZE
	    },
	    send: {
	      size: state.constants.DEFAULT_WINDOW,
	      max: state.constants.MAX_INITIAL_WINDOW_SIZE
	    }
	  });

	  // Interleaving configuration
	  state.maxChunk = options.maxChunk === undefined ? 8 * 1024 : options.maxChunk;

	  // Various state info
	  state.pool = state.protocol.compressionPool.create(options.headerCompression);
	  state.counters = {
	    push: 0,
	    stream: 0
	  };

	  // Init streams list
	  state.stream = {
	    map: {},
	    count: 0,
	    nextId: state.isServer ? 2 : 1,
	    lastId: {
	      both: 0,
	      received: 0
	    }
	  };
	  state.ping = {
	    nextId: state.isServer ? 2 : 1,
	    map: {}
	  };
	  state.goaway = false;

	  // Debug
	  state.debug = state.isServer ? debug.server : debug.client;

	  // X-Forwarded feature
	  state.xForward = null;

	  // Create parser and hole for framer
	  state.parser = state.protocol.parser.create({
	    // NOTE: needed to distinguish ping from ping ACK in SPDY
	    isServer: state.isServer,
	    window: state.window
	  });
	  state.framer = state.protocol.framer.create({
	    window: state.window,
	    timeout: state.timeout
	  });

	  // SPDY has PUSH enabled on servers
	  if (state.protocol.name === 'spdy')
	    state.framer.enablePush(state.isServer);

	  if (!state.isServer)
	    state.parser.skipPreface();

	  this.socket = socket;

	  this._init();
	}
	util.inherits(Connection, EventEmitter);
	exports.Connection = Connection;

	Connection.create = function create(socket, options) {
	  return new Connection(socket, options);
	};

	Connection.prototype._init = function init() {
	  var self = this;
	  var state = this._spdyState;
	  var pool = state.pool;

	  // Initialize session window
	  state.window.recv.on('drain', function() {
	    self._onSessionWindowDrain();
	  });

	  // Initialize parser
	  state.parser.on('data', function(frame) {
	    self._handleFrame(frame);
	  });
	  state.parser.once('version', function(version) {
	    self._onVersion(version);
	  });

	  // Propagate parser errors
	  state.parser.on('error', function(err) {
	    self._onParserError(err);
	  });

	  // Propagate framer errors
	  state.framer.on('error', function(err) {
	    self.emit('error', err);
	  });

	  this.socket.pipe(state.parser);
	  state.framer.pipe(this.socket);

	  // Allow high-level api to catch socket errors
	  this.socket.on('error', function onSocketError(e) {
	    self.emit('error', e);
	  });

	  this.socket.once('close', function onclose() {
	    var err = new Error('socket hang up');
	    err.code = 'ECONNRESET';
	    self.destroyStreams(err);
	    self.emit('close', err);

	    if (state.pair)
	      pool.put(state.pair);

	    state.framer.resume();
	  });

	  // Reset timeout on close
	  this.once('close', function() {
	    self.setTimeout(0);
	  });

	  function _onWindowOverflow() {
	    self._onWindowOverflow();
	  }

	  state.window.recv.on('overflow', _onWindowOverflow);
	  state.window.send.on('overflow', _onWindowOverflow);

	  // Do not allow half-open connections
	  this.socket.allowHalfOpen = false;
	};

	Connection.prototype._onVersion = function _onVersion(version) {
	  var state = this._spdyState;
	  var prev = state.version;
	  var parser = state.parser;
	  var framer = state.framer;
	  var pool = state.pool;

	  state.version = version;
	  state.debug('id=0 version=%d', version);

	  // Ignore transition to 3.1
	  if (!prev) {
	    state.pair = pool.get(version);
	    parser.setCompression(state.pair);
	    framer.setCompression(state.pair);
	  }
	  framer.setVersion(version);

	  if (!state.isServer) {
	    framer.prefaceFrame();
	    if (state.xForward !== null)
	      framer.xForwardedFor({ host: state.xForward });
	  }

	  // Send preface+settings frame (once)
	  framer.settingsFrame({
	    max_header_list_size: state.constants.DEFAULT_MAX_HEADER_LIST_SIZE,
	    max_concurrent_streams: state.maxStreams,
	    enable_push: state.acceptPush ? 1 : 0,
	    initial_window_size: state.window.recv.max
	  });

	  // Update session window
	  if (state.version >= 3.1 || (state.isServer && state.autoSpdy31))
	    this._onSessionWindowDrain();

	  this.emit('version', version);
	};

	Connection.prototype._onParserError = function _onParserError(err) {
	  var state = this._spdyState;

	  // Prevent further errors
	  state.parser.kill();

	  // Send GOAWAY
	  if (err instanceof transport.protocol.base.utils.ProtocolError) {
	    this._goaway({
	      lastId: state.stream.lastId.both,
	      code: err.code,
	      extra: err.message,
	      send: true
	    });
	  }

	  this.emit('error', err);
	};

	Connection.prototype._handleFrame = function _handleFrame(frame) {
	  var state = this._spdyState;

	  state.debug('id=0 frame', frame);
	  state.timeout.reset();

	  // For testing purposes
	  this.emit('frame', frame);

	  var stream;

	  // Session window update
	  if (frame.type === 'WINDOW_UPDATE' && frame.id === 0) {
	    if (state.version < 3.1 && state.autoSpdy31) {
	      state.debug('id=0 switch version to 3.1');
	      state.version = 3.1;
	      this.emit('version', 3.1);
	    }
	    state.window.send.update(frame.delta);
	    return;
	  }

	  if (state.isServer && frame.type === 'PUSH_PROMISE') {
	    state.debug('id=0 server PUSH_PROMISE');
	    this._goaway({
	      lastId: state.stream.lastId.both,
	      code: 'PROTOCOL_ERROR',
	      send: true
	    });
	    return;
	  }

	  if (!stream && frame.id !== undefined) {
	    // Load created one
	    stream = state.stream.map[frame.id];

	    // Fail if not found
	    if (!stream &&
	        frame.type !== 'HEADERS' &&
	        frame.type !== 'PRIORITY' &&
	        frame.type !== 'RST') {
	      // Other side should destroy the stream upon receiving GOAWAY
	      if (this._isGoaway(frame.id))
	        return;

	      state.debug('id=0 stream=%d not found', frame.id);
	      state.framer.rstFrame({ id: frame.id, code: 'INVALID_STREAM' });
	      return;
	    }
	  }

	  // Create new stream
	  if (!stream && frame.type === 'HEADERS') {
	    this._handleHeaders(frame);
	    return;
	  }

	  if (stream) {
	    stream._handleFrame(frame);
	  } else if (frame.type === 'SETTINGS') {
	    this._handleSettings(frame.settings);
	  } else if (frame.type === 'ACK_SETTINGS') {
	    // TODO(indutny): handle it one day
	  } else if (frame.type === 'PING') {
	    this._handlePing(frame);
	  } else if (frame.type === 'GOAWAY') {
	    this._handleGoaway(frame);
	  } else if (frame.type === 'X_FORWARDED_FOR') {
	    // Set X-Forwarded-For only once
	    if (state.xForward === null)
	      state.xForward = frame.host;
	  } else if (frame.type === 'PRIORITY') {
	    // TODO(indutny): handle this
	  } else {
	    state.debug('id=0 unknown frame type: %s', frame.type);
	  }
	};

	Connection.prototype._onWindowOverflow = function _onWindowOverflow() {
	  var state = this._spdyState;
	  state.debug('id=0 window overflow');
	  this._goaway({
	    lastId: state.stream.lastId.both,
	    code: 'FLOW_CONTROL_ERROR',
	    send: true
	  });
	};

	Connection.prototype._isGoaway = function _isGoaway(id) {
	  var state = this._spdyState;
	  if (state.goaway !== false && state.goaway < id)
	    return true;
	  return false;
	};

	Connection.prototype._getId = function _getId() {
	  var state = this._spdyState;

	  var id = state.stream.nextId;
	  state.stream.nextId += 2;
	  return id;
	};

	Connection.prototype._createStream = function _createStream(uri) {
	  var state = this._spdyState;
	  var id = uri.id;
	  if (id === undefined)
	    id = this._getId();

	  var isGoaway = this._isGoaway(id);

	  if (uri.push && !state.acceptPush) {
	    state.debug('id=0 push disabled promisedId=%d', id);

	    // Fatal error
	    this._goaway({
	      lastId: state.stream.lastId.both,
	      code: 'PROTOCOL_ERROR',
	      send: true
	    });
	    isGoaway = true;
	  }

	  var stream = new Stream(this, {
	    id: id,
	    request: uri.request !== false,
	    method: uri.method,
	    path: uri.path,
	    host: uri.host,
	    priority: uri.priority,
	    headers: uri.headers,
	    parent: uri.parent,
	    readable: !isGoaway && uri.readable,
	    writable: !isGoaway && uri.writable
	  });
	  var self = this;

	  // Just an empty stream for API consistency
	  if (isGoaway)
	    return stream;

	  state.stream.lastId.both = Math.max(state.stream.lastId.both, id);

	  state.debug('id=0 add stream=%d', stream.id);
	  state.stream.map[stream.id] = stream;
	  state.stream.count++;
	  state.counters.stream++;
	  if (stream.parent !== null)
	    state.counters.push++;

	  stream.once('close', function() {
	    self._removeStream(stream);
	  });

	  return stream;
	};

	Connection.prototype._handleHeaders = function _handleHeaders(frame) {
	  var state = this._spdyState;

	  // Must be HEADERS frame after stream close
	  if (frame.id <= state.stream.lastId.received)
	    return;

	  // Someone is using our ids!
	  if ((frame.id + state.stream.nextId) % 2 === 0) {
	    state.framer.rstFrame({ id: frame.id, code: 'PROTOCOL_ERROR' });
	    return;
	  }

	  var stream = this._createStream({
	    id: frame.id,
	    request: false,
	    method: frame.headers[':method'],
	    path: frame.headers[':path'],
	    host: frame.headers[':authority'],
	    priority: frame.priority,
	    headers: frame.headers,
	    writable: frame.writable
	  });

	  // GOAWAY
	  if (this._isGoaway(stream.id))
	    return;

	  state.stream.lastId.received = Math.max(state.stream.lastId.received,
	                                          stream.id);

	  // TODO(indutny) handle stream limit
	  if (!this.emit('stream', stream)) {
	    // No listeners was set - abort the stream
	    stream.abort();
	    return;
	  }

	  // Create fake frame to simulate end of the data
	  if (frame.fin)
	    stream._handleFrame({ type: 'FIN', fin: true });

	  return stream;
	};

	Connection.prototype._onSessionWindowDrain = function _onSessionWindowDrain() {
	  var state = this._spdyState;
	  if (state.version < 3.1 && !(state.isServer && state.autoSpdy31))
	    return;

	  var delta = state.window.recv.getDelta();
	  if (delta === 0)
	    return;

	  state.debug('id=0 session window drain, update by %d', delta);

	  state.framer.windowUpdateFrame({
	    id: 0,
	    delta: delta
	  });
	  state.window.recv.update(delta);
	};

	Connection.prototype.start = function start(version) {
	  this._spdyState.parser.setVersion(version);
	};

	// Mostly for testing
	Connection.prototype.getVersion = function getVersion() {
	  return this._spdyState.version;
	};

	Connection.prototype._handleSettings = function _handleSettings(settings) {
	  var state = this._spdyState;

	  state.framer.ackSettingsFrame();

	  this._setDefaultWindow(settings);
	  if (settings.max_frame_size)
	    state.framer.setMaxFrameSize(settings.max_frame_size);

	  // TODO(indutny): handle max_header_list_size
	  if (settings.header_table_size) {
	    try {
	      state.pair.compress.updateTableSize(settings.header_table_size);
	    } catch (e) {
	      this._goaway({
	        lastId: 0,
	        code: 'PROTOCOL_ERROR',
	        send: true
	      });
	      return;
	    }
	  }

	  // HTTP2 clients needs to enable PUSH streams explicitly
	  if (state.protocol.name !== 'spdy') {
	    if (settings.enable_push === undefined)
	      state.framer.enablePush(state.isServer);
	    else
	      state.framer.enablePush(settings.enable_push === 1);
	  }

	  // TODO(indutny): handle max_concurrent_streams
	};

	Connection.prototype._setDefaultWindow = function _setDefaultWindow(settings) {
	  if (settings.initial_window_size === undefined)
	    return;

	  var state = this._spdyState;

	  // Update defaults
	  var window = state.streamWindow;
	  window.send.setMax(settings.initial_window_size);

	  // Update existing streams
	  Object.keys(state.stream.map).forEach(function(id) {
	    var stream = state.stream.map[id];
	    var window = stream._spdyState.window;

	    window.send.updateMax(settings.initial_window_size);
	  });
	};

	Connection.prototype._handlePing = function handlePing(frame) {
	  var self = this;
	  var state = this._spdyState;

	  // Handle incoming PING
	  if (!frame.ack) {
	    state.framer.pingFrame({
	      opaque: frame.opaque,
	      ack: true
	    });

	    self.emit('ping', frame.opaque);
	    return;
	  }

	  // Handle reply PING
	  var hex = frame.opaque.toString('hex');
	  if (!state.ping.map[hex])
	    return;
	  var ping = state.ping.map[hex];
	  delete state.ping.map[hex];

	  if (ping.cb)
	    ping.cb(null);
	};

	Connection.prototype._handleGoaway = function handleGoaway(frame) {
	  this._goaway({
	    lastId: frame.lastId,
	    code: frame.code,
	    send: false
	  });
	};

	Connection.prototype.ping = function ping(callback) {
	  var state = this._spdyState;

	  // HTTP2 is using 8-byte opaque
	  var opaque = new Buffer(state.constants.PING_OPAQUE_SIZE);
	  opaque.fill(0);
	  opaque.writeUInt32BE(state.ping.nextId, opaque.length - 4);
	  state.ping.nextId += 2;

	  state.ping.map[opaque.toString('hex')] = { cb: callback };
	  state.framer.pingFrame({
	    opaque: opaque,
	    ack: false
	  });
	};

	Connection.prototype.getCounter = function getCounter(name) {
	  return this._spdyState.counters[name];
	};

	Connection.prototype.reserveStream = function reserveStream(uri, callback) {
	  var stream = this._createStream(uri);

	  // GOAWAY
	  if (this._isGoaway(stream.id)) {
	    var err = new Error('Can\'t send request after GOAWAY');
	    process.nextTick(function() {
	      if (callback)
	        callback(err);
	      else
	        stream.emit('error', err);
	    });
	    return stream;
	  }

	  if (callback) {
	    process.nextTick(function() {
	      callback(null, stream);
	    });
	  }

	  return stream;
	};

	Connection.prototype.request = function request(uri, callback) {
	  var stream = this.reserveStream(uri, function(err) {
	    if (err) {
	      if (callback)
	        callback(err);
	      else
	        stream.emit('error', err);
	      return;
	    }

	    if (stream._wasSent()) {
	      if (callback)
	        callback(null, stream);
	      return;
	    }

	    stream.send(function(err) {
	      if (err) {
	        if (callback)
	          return callback(err);
	        else
	          return stream.emit('error', err);
	      }

	      if (callback)
	        callback(null, stream);
	    });
	  });

	  return stream;
	};

	Connection.prototype._removeStream = function _removeStream(stream) {
	  var state = this._spdyState;

	  state.debug('id=0 remove stream=%d', stream.id);
	  delete state.stream.map[stream.id];
	  state.stream.count--;

	  if (state.stream.count === 0)
	    this.emit('_streamDrain');
	};

	Connection.prototype._goaway = function _goaway(params) {
	  var state = this._spdyState;
	  var self = this;

	  state.goaway = params.lastId;
	  state.debug('id=0 goaway from=%d', state.goaway);

	  Object.keys(state.stream.map).forEach(function(id) {
	    var stream = state.stream.map[id];

	    // Abort every stream started after GOAWAY
	    if (stream.id <= params.lastId)
	      return;

	    stream.abort();
	    stream.emit('error', new Error('New stream after GOAWAY'));
	  });

	  function finish() {
	    // Destroy socket if there are no streams
	    if (state.stream.count === 0 || params.code !== 'OK') {
	      // No further frames should be processed
	      state.parser.kill();

	      process.nextTick(function() {
	        var err = new Error('Fatal error: ' + params.code);
	        self._onStreamDrain(err);
	      });
	      return;
	    }

	    self.on('_streamDrain', self._onStreamDrain);
	  }

	  if (params.send) {
	    // Make sure that GOAWAY frame is sent before dumping framer
	    state.framer.goawayFrame({
	      lastId: params.lastId,
	      code: params.code,
	      extra: params.extra
	    }, finish);
	  } else {
	    finish();
	  }
	};

	Connection.prototype._onStreamDrain = function _onStreamDrain(error) {
	  var state = this._spdyState;

	  state.debug('id=0 _onStreamDrain');

	  state.framer.dump();
	  state.framer.unpipe(this.socket);
	  state.framer.resume();

	  if (this.socket.destroySoon)
	    this.socket.destroySoon();
	  this.emit('close', error);
	};

	Connection.prototype.end = function end(callback) {
	  var state = this._spdyState;

	  if (callback)
	    this.once('close', callback);
	  this._goaway({
	    lastId: state.stream.lastId.both,
	    code: 'OK',
	    send: true
	  });
	};

	Connection.prototype.destroyStreams = function destroyStreams(err) {
	  var state = this._spdyState;
	  Object.keys(state.stream.map).forEach(function(id) {
	    var stream = state.stream.map[id];

	    stream.abort();
	    stream.emit('error', err);
	  });
	};

	Connection.prototype.isServer = function isServer() {
	  return this._spdyState.isServer;
	};

	Connection.prototype.getXForwardedFor = function getXForwardFor() {
	  return this._spdyState.xForward;
	};

	Connection.prototype.sendXForwardedFor = function sendXForwardedFor(host) {
	  var state = this._spdyState;
	  if (state.version !== null)
	    state.framer.xForwardedFor({ host: host });
	  else
	    state.xForward = host;
	};

	Connection.prototype.pushPromise = function pushPromise(parent, uri, callback) {
	  var state = this._spdyState;

	  var stream = this._createStream({
	    request: false,
	    parent: parent,
	    method: uri.method,
	    path: uri.path,
	    host: uri.host,
	    priority: uri.priority,
	    headers: uri.headers,
	    readable: false
	  });

	  // TODO(indutny): deduplicate this logic somehow
	  if (this._isGoaway(stream.id)) {
	    var err = new Error('Can\'t send PUSH_PROMISE after GOAWAY');
	    process.nextTick(function() {
	      if (callback)
	        callback(err);
	      else
	        stream.emit('error', err);
	    });
	    return stream;
	  }

	  if (uri.push && !state.acceptPush) {
	    var err = new Error(
	        'Can\'t send PUSH_PROMISE, other side won\'t accept it');
	    process.nextTick(function() {
	      if (callback)
	        callback(err);
	      else
	        stream.emit('error', err);
	    });
	    return stream;
	  }

	  stream._sendPush(uri.status, uri.response, function(err) {
	    if (!callback) {
	      if (err)
	        stream.emit('error', err);
	      return;
	    }

	    if (err)
	      return callback(err);
	    callback(null, stream);
	  });

	  return stream;
	};

	Connection.prototype.setTimeout = function setTimeout(delay, callback) {
	  var state = this._spdyState;

	  state.timeout.set(delay, callback);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(2)))

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var assert = __webpack_require__(9);
	var https = __webpack_require__(87);
	var http = __webpack_require__(76);
	var tls = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tls\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var util = __webpack_require__(10);
	var selectHose = __webpack_require__(199);
	var transport = __webpack_require__(147);
	var debug = __webpack_require__(153)('spdy:server');
	var EventEmitter = __webpack_require__(14).EventEmitter;

	var spdy = __webpack_require__(138);

	var proto = {};

	function instantiate(base) {
	  function Server(options, handler) {
	    this._init(base, options, handler);
	  }
	  util.inherits(Server, base);

	  Server.create = function create(options, handler) {
	    return new Server(options, handler);
	  };

	  Object.keys(proto).forEach(function(key) {
	    Server.prototype[key] = proto[key];
	  });

	  return Server;
	}

	proto._init = function _init(base, options, handler) {
	  var state = {};
	  this._spdyState = state;

	  state.options = options.spdy || {};

	  var protocols = state.options.protocols || [
	    'h2',
	    'spdy/3.1', 'spdy/3', 'spdy/2',
	    'http/1.1', 'http/1.0'
	  ];

	  var actualOptions = util._extend({
	    NPNProtocols: protocols,

	    // Future-proof
	    ALPNProtocols: protocols
	  }, options);

	  state.secure = this instanceof tls.Server;

	  if (state.secure)
	    base.call(this, actualOptions);
	  else
	    base.call(this);

	  // Support HEADERS+FIN
	  this.httpAllowHalfOpen = true;

	  var event = state.secure ? 'secureConnection' : 'connection';

	  state.listeners = this.listeners(event).slice();
	  assert(state.listeners.length > 0, 'Server does not have default listeners');
	  this.removeAllListeners(event);

	  if (state.options.plain)
	    this.on(event, this._onPlainConnection);
	  else
	    this.on(event, this._onConnection);

	  if (handler)
	    this.on('request', handler);

	  debug('server init secure=%d', state.secure);
	};

	proto._onConnection = function _onConnection(socket) {
	  var state = this._spdyState;

	  var protocol;
	  if (state.secure)
	    protocol = socket.npnProtocol || socket.alpnProtocol;

	  this._handleConnection(socket, protocol);
	};

	proto._handleConnection = function _handleConnection(socket, protocol) {
	  var state = this._spdyState;

	  if (!protocol)
	    protocol = state.options.protocol;

	  debug('incoming socket protocol=%j', protocol);

	  // No way we can do anything with the socket
	  if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {
	    debug('to default handler it goes');
	    return this._invokeDefault(socket);
	  }

	  socket.setNoDelay(true);

	  var connection = transport.connection.create(socket, util._extend({
	    protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',
	    isServer: true
	  }, state.options.connection || {}));

	  // Set version when we are certain
	  if (protocol === 'http2')
	    connection.start(4);
	  else if (protocol === 'spdy/3.1')
	    connection.start(3.1);
	  else if (protocol === 'spdy/3')
	    connection.start(3);
	  else if (protocol === 'spdy/2')
	    connection.start(2);

	  connection.on('error', function() {
	    socket.destroy();
	  });

	  var self = this;
	  connection.on('stream', function(stream) {
	    self._onStream(stream);
	  });
	};

	// HTTP2 preface
	var PREFACE = 'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n';
	var PREFACE_BUFFER = new Buffer(PREFACE);

	function hoseFilter(data, callback) {
	  if (data.length < 1)
	    return callback(null, null);

	  // SPDY!
	  if (data[0] === 0x80)
	    return callback(null, 'spdy');

	  var avail = Math.min(data.length, PREFACE_BUFFER.length);
	  for (var i = 0; i < avail; i++)
	    if (data[i] !== PREFACE_BUFFER[i])
	      return callback(null, 'http/1.1');

	  // Not enough bytes to be sure about HTTP2
	  if (avail !== PREFACE_BUFFER.length)
	    return callback(null, null);

	  return callback(null, 'h2');
	}

	proto._onPlainConnection = function _onPlainConnection(socket) {
	  var hose = selectHose.create(socket, {}, hoseFilter);

	  var self = this;
	  hose.on('select', function(protocol, socket) {
	    self._handleConnection(socket, protocol);
	  });

	  hose.on('error', function(err) {
	    debug('hose error %j', err.message);
	    socket.destroy();
	  });
	};

	proto._invokeDefault = function _invokeDefault(socket) {
	  var state = this._spdyState;

	  for (var i = 0; i < state.listeners.length; i++)
	    state.listeners[i].call(this, socket);
	};

	proto._onStream = function _onStream(stream) {
	  var state = this._spdyState;

	  var handle = spdy.handle.create(this._spdyState.options, stream);

	  var socketOptions = {
	    handle: handle,
	    allowHalfOpen: true
	  };

	  var socket;
	  if (state.secure)
	    socket = new spdy.Socket(stream.connection.socket, socketOptions);
	  else
	    socket = new net.Socket(socketOptions);

	  handle.assignSocket(socket);

	  // For v0.8
	  socket.readable = true;
	  socket.writable = true;

	  this._invokeDefault(socket);

	  // Add lazy `checkContinue` listener, otherwise `res.writeContinue` will be
	  // called before the response object was patched by us.
	  if (stream.headers.expect !== undefined &&
	      /100-continue/i.test(stream.headers.expect) &&
	      EventEmitter.listenerCount(this, 'checkContinue') === 0) {
	    this.once('checkContinue', function(req, res) {
	      res.writeContinue();

	      this.emit('request', req, res);
	    });
	  }

	  handle.emitRequest();
	};

	proto.emit = function emit(event, req, res) {
	  if (event !== 'request' && event !== 'checkContinue')
	    return EventEmitter.prototype.emit.apply(this, arguments);

	  if (!(req.socket._handle instanceof spdy.handle)) {
	    debug('not spdy req/res');
	    req.isSpdy = false;
	    req.spdyVersion = 1;
	    res.isSpdy = false;
	    res.spdyVersion = 1;
	    return EventEmitter.prototype.emit.apply(this, arguments);
	  }

	  var handle = req.connection._handle;

	  req.isSpdy = true;
	  req.spdyVersion = handle.getStream().connection.getVersion();
	  res.isSpdy = true;
	  res.spdyVersion = req.spdyVersion;
	  req.spdyStream = handle.getStream();

	  debug('override req/res');
	  res.writeHead = spdy.response.writeHead;
	  res.end = spdy.response.end;
	  res.push = spdy.response.push;
	  res.writeContinue = spdy.response.writeContinue;
	  res.spdyStream = handle.getStream();

	  res._req = req;

	  handle.assignRequest(req);
	  handle.assignResponse(res);

	  return EventEmitter.prototype.emit.apply(this, arguments);
	};

	exports.Server = instantiate(https.Server);
	exports.PlainServer = instantiate(http.Server);

	exports.create = function create(base, options, handler) {
	  if (typeof base === 'object') {
	    handler = options;
	    options = base;
	    base = null;
	  }

	  if (base)
	    return instantiate(base).create(options, handler);

	  if (options.spdy && options.spdy.plain)
	    return exports.PlainServer.create(options, handler);
	  else
	    return exports.Server.create(options, handler);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var util = __webpack_require__(10);
	var EventEmitter = __webpack_require__(14).EventEmitter;

	function Hose(socket, options, filter) {
	  EventEmitter.call(this);

	  if (typeof options === 'function') {
	    filter = options;
	    options = {};
	  }

	  this.socket = socket;
	  this.options = options;
	  this.filter = filter;

	  this.buffer = null;

	  var self = this;
	  this.listeners = {
	    error: function(err) {
	      return self.onError(err);
	    },
	    data: function(chunk) {
	      return self.onData(chunk);
	    },
	    end: function() {
	      return self.onEnd();
	    }
	  };

	  this.socket.on('error', this.listeners.error);
	  this.socket.on('data', this.listeners.data);
	  this.socket.on('end', this.listeners.end);
	}
	util.inherits(Hose, EventEmitter);
	module.exports = Hose;

	Hose.create = function create(socket, options, filter) {
	  return new Hose(socket, options, filter);
	};

	Hose.prototype.detach = function detach() {
	  // Stop the flow
	  this.socket.pause();

	  this.socket.removeListener('error', this.listeners.error);
	  this.socket.removeListener('data', this.listeners.data);
	  this.socket.removeListener('end', this.listeners.end);
	};

	Hose.prototype.reemit = function reemit() {
	  var buffer = this.buffer;
	  this.buffer = null;

	  // Modern age
	  if (this.socket.unshift) {
	    this.socket.unshift(buffer);
	    if (this.socket.listeners('data').length > 0)
	      this.socket.resume();
	    return;
	  }

	  // Rusty node v0.8
	  if (this.socket.ondata)
	    this.socket.ondata(buffer, 0, buffer.length);
	  this.socket.emit('data', buffer);
	  this.socket.resume();
	};

	Hose.prototype.onError = function onError(err) {
	  this.detach();
	  this.emit('error', err);
	};

	Hose.prototype.onData = function onData(chunk) {
	  if (this.buffer)
	    this.buffer = Buffer.concat([ this.buffer, chunk ]);
	  else
	    this.buffer = chunk;

	  var self = this;
	  this.filter(this.buffer, function(err, protocol) {
	    if (err)
	      return self.onError(err);

	    // No protocol selected yet
	    if (!protocol)
	      return;

	    self.detach();
	    self.emit('select', protocol, self.socket);
	    self.reemit();
	  });
	};

	Hose.prototype.onEnd = function onEnd() {
	  this.detach();
	  this.emit('error', new Error('Not enough data to recognize protocol'));
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Exports

	module.exports = {
	    'application/javascript; q=0.1': __webpack_require__(201),
	    'application/json; q=0.4': __webpack_require__(202),
	    'text/plain; q=0.3': __webpack_require__(203),
	    'application/octet-stream; q=0.2': __webpack_require__(204)
	};


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Exports

	/**
	 * JSONP formatter. like JSON, but with a callback invocation.
	 * @public
	 * @function formatJSONP
	 * @param    {Object} req  the request object
	 * @param    {Object} res  the response object
	 * @param    {Object} body response body
	 * @param    {Function} cb cb
	 * @returns  {String}
	 */
	function formatJSONP(req, res, body, cb) {
	    if (!body) {
	        res.setHeader('Content-Length', 0);
	        return (null);
	    }

	    if (body instanceof Error) {
	        if ((body.restCode || body.httpCode) && body.body) {
	            body = body.body;
	        } else {
	            body = {
	                message: body.message
	            };
	        }
	    }

	    if (Buffer.isBuffer(body)) {
	        body = body.toString('base64');
	    }

	    var _cb = req.query.callback || req.query.jsonp;
	    var data;

	    if (_cb) {
	        data = 'typeof ' + _cb + ' === \'function\' && ' +
	                _cb + '(' + JSON.stringify(body) + ');';
	    } else {
	        data = JSON.stringify(body);
	    }

	    res.setHeader('Content-Length', Buffer.byteLength(data));
	    return cb(null, data);
	}

	module.exports = formatJSONP;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Exports

	/**
	 * JSON formatter.
	 * @public
	 * @function formatJSON
	 * @param    {Object} req  the request object
	 * @param    {Object} res  the response object
	 * @param    {Object} body response body
	 * @param    {Function} cb cb
	 * @returns  {String}
	 */
	function formatJSON(req, res, body, cb) {
	    if (body instanceof Error) {
	        // snoop for RestError or HttpError, but don't rely on
	        // instanceof
	        res.statusCode = body.statusCode || 500;

	        if (body.body) {
	            body = body.body;
	        } else {
	            body = {
	                message: body.message
	            };
	        }
	    } else if (Buffer.isBuffer(body)) {
	        body = body.toString('base64');
	    }

	    var data = JSON.stringify(body);
	    res.setHeader('Content-Length', Buffer.byteLength(data));

	    return cb(null, data);
	}

	module.exports = formatJSON;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Exports

	/**
	 * JSONP formatter. like JSON, but with a callback invocation.
	 * @public
	 * @function formatJSONP
	 * @param    {Object} req  the request object
	 * @param    {Object} res  the response object
	 * @param    {Object} body response body
	 * @param    {Function} cb cb
	 * @returns  {String}
	 */
	function formatText(req, res, body, cb) {
	    if (body instanceof Error) {
	        res.statusCode = body.statusCode || 500;
	        body = body.message;
	    } else if (typeof (body) === 'object') {
	        body = JSON.stringify(body);
	    } else {
	        body = body.toString();
	    }

	    res.setHeader('Content-Length', Buffer.byteLength(body));
	    return cb(null, body);
	}

	module.exports = formatText;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Exports

	/**
	 * binary formatter.
	 * @public
	 * @function formatBinary
	 * @param    {Object} req  the request object
	 * @param    {Object} res  the response object
	 * @param    {Object} body response body
	 * @param    {Function} cb cb
	 * @returns  {Buffer}
	 */
	function formatBinary(req, res, body, cb) {
	    if (body instanceof Error) {
	        res.statusCode = body.statusCode || 500;
	    }

	    if (!Buffer.isBuffer(body)) {
	        body = new Buffer(body.toString());
	    }

	    res.setHeader('Content-Length', body.length);
	    return cb(null, body);
	}

	module.exports = formatBinary;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright (c) 2013, Joyent, Inc. All rights reserved.

	'use strict';

	var EventEmitter = __webpack_require__(14).EventEmitter;
	var util = __webpack_require__(10);
	var assert = __webpack_require__(4);

	/**
	 * an custom error for capturing an invalid upgrade state.
	 * @public
	 * @class
	 * @param {String} msg an error message
	 */
	function InvalidUpgradeStateError(msg) {
	    if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, InvalidUpgradeStateError);
	    }

	    this.message = msg;
	    this.name = 'InvalidUpgradeStateError';
	}
	util.inherits(InvalidUpgradeStateError, Error);

	//
	// The Node HTTP Server will, if we handle the 'upgrade' event, swallow any
	// Request with the 'Connection: upgrade' header set.  While doing this it
	// detaches from the 'data' events on the Socket and passes the socket to
	// us, so that we may take over handling for the connection.
	//
	// Unfortunately, the API does not presently provide a http.ServerResponse
	// for us to use in the event that we do not wish to upgrade the connection.
	// This factory method provides a skeletal implementation of a
	// restify-compatible response that is sufficient to allow the existing
	// request handling path to work, while allowing us to perform _at most_ one
	// of either:
	//
	//   - Return a basic HTTP Response with a provided Status Code and
	//     close the socket.
	//   - Upgrade the connection and stop further processing.
	//
	// To determine if an upgrade is requested, a route handler would check for
	// the 'claimUpgrade' method on the Response.  The object this method
	// returns will have the 'socket' and 'head' Buffer emitted with the
	// 'upgrade' event by the http.Server.  If the upgrade is not possible, such
	// as when the HTTP head (or a full request) has already been sent by some
	// other handler, this method will throw.
	//

	/**
	 * create a new upgraded response.
	 * @public
	 * @function createServerUpgradeResponse
	 * @param    {Object} req    the request object
	 * @param    {Object} socket the network socket
	 * @param    {Object} head   a buffer, the first packet of the upgraded stream
	 * @returns  {Object}        an upgraded reponses
	 */
	function createServerUpgradeResponse(req, socket, head) {
	    return (new ServerUpgradeResponse(socket, head));
	}


	/**
	 * upgrade the http response
	 * @private
	 * @class
	 * @param   {Object}    socket the network socket
	 * @param   {Object}    head   a buffer, the first packet of the upgraded stream
	 * @returns {undefined}
	 */
	function ServerUpgradeResponse(socket, head) {
	    assert.object(socket, 'socket');
	    assert.buffer(head, 'head');

	    EventEmitter.call(this);

	    this.sendDate = true;
	    this.statusCode = 400;

	    this._upgrade = {
	        socket: socket,
	        head: head
	    };

	    this._headWritten = false;
	    this._upgradeClaimed = false;
	}
	util.inherits(ServerUpgradeResponse, EventEmitter);


	/**
	 * a function generator for all programatically attaching methods on to
	 * the ServerUpgradeResponse class.
	 * @private
	 * @function notImplemented
	 * @param    {Object}   method an object containing configuration
	 * @returns  {Function}
	 */
	function notImplemented(method) {
	    if (!method.throws) {
	        return function () {
	            return (method.returns);
	        };
	    } else {
	        return function () {
	            throw (new Error('Method ' + method.name + ' is not ' +
	                'implemented!'));
	        };
	    }
	}

	var NOT_IMPLEMENTED = [
	    { name: 'writeContinue', throws: true },
	    { name: 'setHeader', throws: false, returns: null },
	    { name: 'getHeader', throws: false, returns: null },
	    { name: 'getHeaders', throws: false, returns: {} },
	    { name: 'removeHeader', throws: false, returns: null },
	    { name: 'addTrailer', throws: false, returns: null },
	    { name: 'cache', throws: false, returns: 'public' },
	    { name: 'format', throws: true },
	    { name: 'set', throws: false, returns: null },
	    { name: 'get', throws: false, returns: null },
	    { name: 'headers', throws: false, returns: {} },
	    { name: 'header', throws: false, returns: null },
	    { name: 'json', throws: false, returns: null },
	    { name: 'link', throws: false, returns: null }
	];

	// programatically add a bunch of methods to the ServerUpgradeResponse proto
	NOT_IMPLEMENTED.forEach(function (method) {
	    ServerUpgradeResponse.prototype[method.name] = notImplemented(method);
	});


	/**
	 * internal implementation of writeHead
	 * @private
	 * @function _writeHeadImpl
	 * @param   {Number} statusCode the http status code
	 * @param   {String} reason     a message
	 * @returns {undefined}
	 */
	ServerUpgradeResponse.prototype._writeHeadImpl =
	    function _writeHeadImpl(statusCode, reason) {
	        if (this._headWritten) {
	            return;
	        }
	        this._headWritten = true;

	        if (this._upgradeClaimed) {
	            throw new InvalidUpgradeStateError('Upgrade already claimed!');
	        }

	        var head = [
	            'HTTP/1.1 ' + statusCode + ' ' + reason,
	            'Connection: close'
	        ];

	        if (this.sendDate) {
	            head.push('Date: ' + new Date().toUTCString());
	        }

	        this._upgrade.socket.write(head.join('\r\n') + '\r\n');
	    };


	/**
	 * set the status code of the response
	 * @public
	 * @function  status
	 * @param     {Number} code the http status code
	 * @returns   {undefined}
	 */
	ServerUpgradeResponse.prototype.status = function status(code) {
	    assert.number(code, 'code');
	    this.statusCode = code;
	    return (code);
	};


	/**
	 * sends the response
	 * @public
	 * @function  send
	 * @param     {Number}           code the http status code
	 * @param     {Object | String}  body the response to send out
	 * @returns   {undefined}
	 */
	ServerUpgradeResponse.prototype.send = function send(code, body) {
	    if (typeof (code) === 'number') {
	        this.statusCode = code;
	    } else {
	        body = code;
	    }

	    if (typeof (body) === 'object') {
	        if (typeof (body.statusCode) === 'number') {
	            this.statusCode = body.statusCode;
	        }

	        if (typeof (body.message) === 'string') {
	            this.statusReason = body.message;
	        }
	    }

	    return (this.end());
	};


	/**
	 * end the response
	 * @public
	 * @function end
	 * @returns  {Boolean} always returns true
	 */
	ServerUpgradeResponse.prototype.end = function end() {
	    this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');
	    this._upgrade.socket.end('\r\n');
	    return (true);
	};


	/**
	 * write to the response
	 * @public
	 * @function write
	 * @returns  {Boolean} always returns true
	 */
	ServerUpgradeResponse.prototype.write = function write() {
	    this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');
	    return (true);
	};


	/**
	 * write to the head of the response
	 * @public
	 * @function writeHead
	 * @param   {Number} statusCode the http status code
	 * @param   {String} reason     a message
	 * @returns {undefined}
	 */
	ServerUpgradeResponse.prototype.writeHead =
	    function writeHead(statusCode, reason) {
	        assert.number(statusCode, 'statusCode');
	        assert.optionalString(reason, 'reason');

	        this.statusCode = statusCode;

	        if (!reason) {
	            reason = 'Connection Not Upgraded';
	        }

	        if (this._headWritten) {
	            throw new Error('Head already written!');
	        }

	        return (this._writeHeadImpl(statusCode, reason));
	    };


	/**
	 * attempt to upgrade
	 * @public
	 * @function claimUpgrade
	 * @returns  {Object}     an object containing the socket and head
	 */
	ServerUpgradeResponse.prototype.claimUpgrade = function claimUpgrade() {
	    if (this._upgradeClaimed) {
	        throw new InvalidUpgradeStateError('Upgrade already claimed!');
	    }

	    if (this._headWritten) {
	        throw new InvalidUpgradeStateError('Upgrade already aborted!');
	    }

	    this._upgradeClaimed = true;

	    return (this._upgrade);
	};


	module.exports = {
	    createResponse: createServerUpgradeResponse,
	    InvalidUpgradeStateError: InvalidUpgradeStateError
	};



/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var http = __webpack_require__(76);
	var url = __webpack_require__(81);
	var sprintf = __webpack_require__(10).format;

	var assert = __webpack_require__(4);
	var mime = __webpack_require__(100);
	var Negotatior = __webpack_require__(130);
	var uuid = __webpack_require__(58);

	var dtrace = __webpack_require__(103);


	///--- Globals

	var Request = http.IncomingMessage;


	///-- Helpers
	/**
	 * creates and sets negotiator on request if one doesn't already exist,
	 * then returns it.
	 * @private
	 * @function negotiator
	 * @param    {Object} req the request object
	 * @returns  {Object}     a negotiator
	 */
	function negotiator(req) {
	    var h = req.headers;

	    if (!req._negotatiator) {
	        req._negotiator = new Negotatior({
	            headers: {
	                accept: h.accept || '*/*',
	                'accept-encoding': h['accept-encoding'] ||
	                    'identity'
	            }
	        });
	    }

	    return (req._negotiator);
	}


	///--- API

	///--- Patches

	/**
	 * builds an absolute URI for the request.
	 * @private
	 * @function absoluteUri
	 * @param    {String} path a url path
	 * @returns  {String}
	 */
	Request.prototype.absoluteUri = function absoluteUri(path) {
	    assert.string(path, 'path');

	    var protocol = this.secure ? 'https://' : 'http://';
	    var hostname = this.headers.host;
	    return (url.resolve(protocol + hostname + this.path() + '/', path));
	};


	/**
	 * checks if the accept header is present and has the value requested.
	 * e.g., req.accepts('html');
	 * @public
	 * @function accepts
	 * @param    {String | Array} types an array of accept type headers
	 * @returns  {Boolean}
	 */
	Request.prototype.accepts = function accepts(types) {
	    if (typeof (types) === 'string') {
	        types = [types];
	    }

	    types = types.map(function (t) {
	        assert.string(t, 'type');

	        if (t.indexOf('/') === -1) {
	            t = mime.lookup(t);
	        }
	        return (t);
	    });

	    negotiator(this);

	    return (this._negotiator.preferredMediaType(types));
	};


	/**
	 * checks if the request accepts the encoding types.
	 * @public
	 * @function acceptsEncoding
	 * @param    {String | Array} types an array of accept type headers
	 * @returns  {Boolean}
	 */
	Request.prototype.acceptsEncoding = function acceptsEncoding(types) {
	    if (typeof (types) === 'string') {
	        types = [types];
	    }

	    assert.arrayOfString(types, 'types');

	    negotiator(this);

	    return (this._negotiator.preferredEncoding(types));
	};


	/**
	 * gets the content-length header off the request.
	 * @public
	 * @function getContentLength
	 * @returns {Number}
	 */
	Request.prototype.getContentLength = function getContentLength() {
	    if (this._clen !== undefined) {
	        return (this._clen === false ? undefined : this._clen);
	    }

	    // We should not attempt to read and parse the body of an
	    // Upgrade request, so force Content-Length to zero:
	    if (this.isUpgradeRequest()) {
	        return (0);
	    }

	    var len = this.header('content-length');

	    if (!len) {
	        this._clen = false;
	    } else {
	        this._clen = parseInt(len, 10);
	    }

	    return (this._clen === false ? undefined : this._clen);
	};
	/**
	 * pass through to getContentLength
	 * @public
	 * @function contentLength
	 * @returns {Number}
	 */
	Request.prototype.contentLength = Request.prototype.getContentLength;


	/**
	 * gets the content-type header.
	 * @public
	 * @function getContentType
	 * @returns {String}
	 */
	Request.prototype.getContentType = function getContentType() {
	    if (this._contentType !== undefined) {
	        return (this._contentType);
	    }

	    var index;
	    var type = this.headers['content-type'];

	    if (!type) {
	        // RFC2616 section 7.2.1
	        this._contentType = 'application/octet-stream';
	    } else {
	        if ((index = type.indexOf(';')) === -1) {
	            this._contentType = type;
	        } else {
	            this._contentType = type.substring(0, index);
	        }
	    }

	    // #877 content-types need to be case insensitive.
	    this._contentType = this._contentType.toLowerCase();

	    return (this._contentType);
	};
	Request.prototype.contentType = Request.prototype.getContentType;


	/**
	 * gets the _date property off the request. was created when the request
	 * was setup.
	 * @private
	 * @function date
	 * @returns  {Date}
	 */
	Request.prototype.date = function date() {
	    if (this._date !== undefined) {
	        return (this._date);
	    }

	    this._date = new Date(this._time);
	    return (this._date);
	};


	/**
	 * retrieves the complete URI requested by the client.
	 * @public
	 * @function getHref
	 * @returns {String}
	 */
	Request.prototype.getHref = function getHref() {
	    return (this.getUrl().href);
	};
	Request.prototype.href = Request.prototype.getHref;


	/**
	 * retrieves the request uuid. was created when the request was setup.
	 * @public
	 * @function getId
	 * @returns  {String}
	 */
	Request.prototype.getId = function getId() {
	    if (this._id !== undefined) {
	        return (this._id);
	    }

	    this._id = this.headers['request-id'] ||
	        this.headers['x-request-id'] ||
	        uuid.v4();

	    return (this._id);
	};
	Request.prototype.id = Request.prototype.getId;


	/**
	 * retrieves the cleaned up url path.
	 * e.g., /foo?a=1  =>  /foo
	 * @public
	 * @function getPath
	 * @returns  {String}
	 */
	Request.prototype.getPath = function getPath() {
	    return (this.getUrl().pathname);
	};
	Request.prototype.path = Request.prototype.getPath;


	/**
	 * returns the raw query string
	 * @public
	 * @function getQuery
	 * @returns  {String}
	 */
	Request.prototype.getQuery = function getQuery() {
	    // always return a string, because this is the raw query string.
	    // if the queryParser plugin is used, req.query will provide an empty
	    // object fallback.
	    return (this.getUrl().query || '');
	};
	Request.prototype.query = Request.prototype.getQuery;


	/**
	 * returns ms since epoch when request was setup.
	 * @public
	 * @function time
	 * @returns  {Number}
	 */
	Request.prototype.time = function time() {
	    return (this._time);
	};


	/**
	 * returns a parsed URL object.
	 * @public
	 * @function getUrl
	 * @returns  {Object}
	 */
	Request.prototype.getUrl = function getUrl() {
	    if (this._cacheURL !== this.url) {
	        this._url = url.parse(this.url);
	        this._cacheURL = this.url;
	    }
	    return (this._url);
	};


	/**
	 * returns the accept-version header.
	 * @public
	 * @function getVersion
	 * @returns  {String}
	 */
	Request.prototype.getVersion = function getVersion() {
	    if (this._version !== undefined) {
	        return (this._version);
	    }

	    this._version =
	        this.headers['accept-version'] ||
	            this.headers['x-api-version'] ||
	            '*';

	    return (this._version);
	};
	Request.prototype.version = Request.prototype.getVersion;

	Request.prototype.matchedVersion = function matchedVersion() {
	    if (this._matchedVersion !== undefined) {
	        return (this._matchedVersion);
	    } else {
	        return (this.version());
	    }
	};

	/**
	 * returns any header off the request. also, 'correct' any
	 * correctly spelled 'referrer' header to the actual spelling used.
	 * @public
	 * @function header
	 * @param    {String} name  the name of the header
	 * @param    {String} value default value if header isn't found on the req
	 * @returns  {String}
	 */
	Request.prototype.header = function header(name, value) {
	    assert.string(name, 'name');

	    name = name.toLowerCase();

	    if (name === 'referer' || name === 'referrer') {
	        name = 'referer';
	    }

	    return (this.headers[name] || value);
	};


	/**
	 * returns any trailer header off the request. also, 'correct' any
	 * correctly spelled 'referrer' header to the actual spelling used.
	 * @public
	 * @function trailer
	 * @param    {String} name  the name of the header
	 * @param    {String} value default value if header isn't found on the req
	 * @returns  {String}
	 */
	Request.prototype.trailer = function trailer(name, value) {
	    assert.string(name, 'name');
	    name = name.toLowerCase();

	    if (name === 'referer' || name === 'referrer') {
	        name = 'referer';
	    }

	    return ((this.trailers || {})[name] || value);
	};


	/**
	 * Check if the incoming request contains the Content-Type header field, and
	 * if it contains the given mime type.
	 * @public
	 * @function is
	 * @param    {String} type  a content-type header value
	 * @returns  {Boolean}
	 */
	Request.prototype.is = function is(type) {
	    assert.string(type, 'type');

	    var contentType = this.getContentType();
	    var matches = true;

	    if (!contentType) {
	        return (false);
	    }

	    if (type.indexOf('/') === -1) {
	        type = mime.lookup(type);
	    }

	    if (type.indexOf('*') !== -1) {
	        type = type.split('/');
	        contentType = contentType.split('/');
	        matches &= (type[0] === '*' || type[0] === contentType[0]);
	        matches &= (type[1] === '*' || type[1] === contentType[1]);
	    } else {
	        matches = (contentType === type);
	    }

	    return (matches);
	};


	/**
	 * Check if the incoming request is chunked.
	 * @public
	 * @function isChunked
	 * @returns  {Boolean}
	 */
	Request.prototype.isChunked = function isChunked() {
	    return (this.headers['transfer-encoding'] === 'chunked');
	};


	/**
	 * Check if the incoming request is kept alive.
	 * @public
	 * @function isKeepAlive
	 * @returns  {Boolean}
	 */
	Request.prototype.isKeepAlive = function isKeepAlive() {
	    if (this._keepAlive !== undefined) {
	        return (this._keepAlive);
	    }

	    if (this.headers.connection) {
	        this._keepAlive = /keep-alive/i.test(this.headers.connection);
	    } else {
	        this._keepAlive = this.httpVersion === '1.0' ? false : true;
	    }

	    return (this._keepAlive);
	};


	/**
	 * Check if the incoming request is encrypted.
	 * @public
	 * @function isSecure
	 * @returns  {Boolean}
	 */
	Request.prototype.isSecure = function isSecure() {
	    if (this._secure !== undefined) {
	        return (this._secure);
	    }

	    this._secure = this.connection.encrypted ? true : false;
	    return (this._secure);
	};


	/**
	 * Check if the incoming request has been upgraded.
	 * @public
	 * @function isUpgradeRequest
	 * @returns  {Boolean}
	 */
	Request.prototype.isUpgradeRequest = function isUpgradeRequest() {
	    if (this._upgradeRequest !== undefined) {
	        return (this._upgradeRequest);
	    } else {
	        return (false);
	    }
	};


	/**
	 * Check if the incoming request is an upload verb.
	 * @public
	 * @function isUpload
	 * @returns  {Boolean}
	 */
	Request.prototype.isUpload = function isUpload() {
	    var m = this.method;
	    return (m === 'PATCH' || m === 'POST' || m === 'PUT');
	};


	/**
	 * toString serialization
	 * @public
	 * @function toString
	 * @returns  {String}
	 */
	Request.prototype.toString = function toString() {
	    var headers = '';
	    var self = this;
	    var str;

	    Object.keys(this.headers).forEach(function (k) {
	        headers += sprintf('%s: %s\n', k, self.headers[k]);
	    });

	    str = sprintf('%s %s HTTP/%s\n%s',
	        this.method,
	        this.url,
	        this.httpVersion,
	        headers);

	    return (str);
	};


	/**
	 * retrieves the user-agent header.
	 * @public
	 * @function userAgent
	 * @returns  {String}
	 */
	Request.prototype.userAgent = function userAgent() {
	    return (this.headers['user-agent']);
	};


	/**
	 * Start the timer for a request handler function. You must explicitly invoke
	 * endHandlerTimer() after invoking this function. Otherwise timing information
	 * will be inaccurate.
	 * @public
	 * @function startHandlerTimer
	 * @param    {String}    handlerName The name of the handler.
	 * @returns  {undefined}
	 */
	Request.prototype.startHandlerTimer = function startHandlerTimer(handlerName) {
	    var self = this;

	    // For nested handlers, we prepend the top level handler func name
	    var name = (self._currentHandler === handlerName ?
	                handlerName : self._currentHandler + '-' + handlerName);

	    if (!self._timerMap) {
	        self._timerMap = {};
	    }

	    self._timerMap[name] = process.hrtime();

	    dtrace._rstfy_probes['handler-start'].fire(function () {
	        return ([
	            self.serverName,
	            self._currentRoute, // set in server._run
	            name,
	            self._dtraceId
	        ]);
	    });
	};


	/**
	 * Stop the timer for a request handler function.
	 * @public
	 * @function endHandlerTimer
	 * @param    {String}    handlerName The name of the handler.
	 * @returns  {undefined}
	 */
	Request.prototype.endHandlerTimer = function endHandlerTimer(handlerName) {
	    var self = this;

	    // For nested handlers, we prepend the top level handler func name
	    var name = (self._currentHandler === handlerName ?
	                handlerName : self._currentHandler + '-' + handlerName);

	    if (!self.timers) {
	        self.timers = [];
	    }

	    self._timerMap[name] = process.hrtime(self._timerMap[name]);
	    self.timers.push({
	        name: name,
	        time: self._timerMap[name]
	    });

	    dtrace._rstfy_probes['handler-done'].fire(function () {
	        return ([
	            self.serverName,
	            self._currentRoute, // set in server._run
	            name,
	            self._dtraceId
	        ]);
	    });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var http = __webpack_require__(76);
	var sprintf = __webpack_require__(10).format;
	var url = __webpack_require__(81);

	var assert = __webpack_require__(4);
	var mime = __webpack_require__(100);

	var httpDate = __webpack_require__(208);
	var utils = __webpack_require__(3);
	var errors = __webpack_require__(105);

	///--- Globals

	var InternalServerError = errors.InternalServerError;

	var Response = http.ServerResponse;


	///--- API

	/**
	 * sets the cache-control header. `type` defaults to _public_,
	 * and options currently only takes maxAge.
	 * @public
	 * @function cache
	 * @param    {String} type    value of the header
	 * @param    {Object} options an options object
	 * @returns  {String}         the value set to the header
	 */
	Response.prototype.cache = function cache(type, options) {
	    if (typeof (type) !== 'string') {
	        options = type;
	        type = 'public';
	    }

	    if (options && options.maxAge !== undefined) {
	        assert.number(options.maxAge, 'options.maxAge');
	        type += ', max-age=' + options.maxAge;
	    }

	    return (this.header('Cache-Control', type));
	};


	/**
	 * turns off all cache related headers.
	 * @public
	 * @function noCache
	 * @returns  {Object} self, the response object
	 */
	Response.prototype.noCache = function noCache() {
	    // HTTP 1.1
	    this.header('Cache-Control', 'no-cache, no-store, must-revalidate');

	    // HTTP 1.0
	    this.header('Pragma', 'no-cache');

	    // Proxies
	    this.header('Expires', '0');

	    return (this);
	};


	/**
	 * Appends the provided character set to the response's Content-Type.
	 * e.g., res.charSet('utf-8');
	 * @public
	 * @function charSet
	 * @param    {String} type char-set value
	 * @returns  {Object} self, the response object
	 */
	Response.prototype.charSet = function charSet(type) {
	    assert.string(type, 'charset');

	    this._charSet = type;

	    return (this);
	};


	/**
	 * the response formatter. formats the response in preparation to send it off.
	 * callback only used in async formatters. restify does not ship with any
	 * async formatters currently.
	 * @public
	 * @function format
	 * @param    {Object | String} body the response body to format
	 * @param    {Function}        cb   callback function
	 * @returns  {undefined}
	 */
	Response.prototype.format = function format(body, cb) {
	    var log = this.log;
	    var formatter;
	    var type = this.contentType || this.getHeader('Content-Type');
	    var self = this;

	    if (!type) {
	        if (this.req.accepts(this.acceptable)) {
	            type = this.req.accepts(this.acceptable);
	        }

	        if (!type) {
	            // The importance of a status code outside of the
	            // 2xx range probably outweighs that of unable being to
	            // format the response body
	            if (this.statusCode >= 200 && this.statusCode < 300) {
	                this.statusCode = 406;
	            }

	            return cb(null);
	        }
	    } else if (type.indexOf(';') !== '-1') {
	        type = type.split(';')[0];
	    }

	    if (!(formatter = this.formatters[type])) {
	        if (type.indexOf('/') === -1) {
	            type = mime.lookup(type);
	        }

	        if (this.acceptable.indexOf(type) === -1) {
	            type = 'application/octet-stream';
	        }

	        formatter = this.formatters[type] || this.formatters['*/*'];

	        // this is a catastrophic case - should always fall back on octet-stream
	        // but if for some reason that's gone, return a 500.
	        if (!formatter) {
	            log.warn({
	                req: self.req
	            }, 'no formatter found. Returning 500.');
	            this.statusCode = 500;
	            return cb(null);
	        }
	    }

	    if (this._charSet) {
	        type = type + '; charset=' + this._charSet;
	    }

	    this.setHeader('Content-Type', type);

	    if (body instanceof Error && body.statusCode !== undefined) {
	        this.statusCode = body.statusCode;
	    }
	    return (formatter.call(this, this.req, this, body, cb));
	};


	/**
	 * retrieves a header off the response.
	 * @public
	 * @function get
	 * @param    {Object} name the header name
	 * @returns  {String}
	 */
	Response.prototype.get = function get(name) {
	    assert.string(name, 'name');

	    return (this.getHeader(name));
	};


	/**
	 * retrieves all headers off the response.
	 * @public
	 * @function getHeaders
	 * @returns  {Object}
	 */
	Response.prototype.getHeaders = function getHeaders() {
	    return (this._headers || {});
	};
	Response.prototype.headers = Response.prototype.getHeaders;


	/**
	 * sets headers on the response.
	 * @public
	 * @function header
	 * @param    {String} name  the name of the header
	 * @param    {String} value the value of the header
	 * @returns  {Object}
	 */
	Response.prototype.header = function header(name, value) {
	    assert.string(name, 'name');

	    if (value === undefined) {
	        return (this.getHeader(name));
	    }

	    if (value instanceof Date) {
	        value = httpDate(value);
	    } else if (arguments.length > 2) {
	        // Support res.header('foo', 'bar %s', 'baz');
	        var arg = Array.prototype.slice.call(arguments).slice(2);
	        value = sprintf(value, arg);
	    }

	    var current = this.getHeader(name);

	    // #779, don't use comma separated values for set-cookie, see
	    // http://tools.ietf.org/html/rfc6265#section-3
	    if (current && name.toLowerCase() !== 'set-cookie') {
	        if (Array.isArray(current)) {
	            current.push(value);
	            value = current;
	        } else {
	            value = [current, value];
	        }
	    }

	    this.setHeader(name, value);
	    return (value);
	};


	/**
	 * short hand method for:
	 *     res.contentType = 'json';
	 *     res.send({hello: 'world'});
	 * @public
	 * @function json
	 * @param    {Number} code    http status code
	 * @param    {Object} object  value to json.stringify
	 * @param    {Object} headers headers to set on the response
	 * @returns  {Object}
	 */
	Response.prototype.json = function json(code, object, headers) {
	    if (!/application\/json/.test(this.header('content-type'))) {
	        this.header('Content-Type', 'application/json');
	    }

	    return (this.send(code, object, headers));
	};


	/**
	 * sets the link heaader.
	 * @public
	 * @function link
	 * @param    {String} l   the link key
	 * @param    {String} rel the link value
	 * @returns  {String}     the header value set to res
	 */
	Response.prototype.link = function link(l, rel) {
	    assert.string(l, 'link');
	    assert.string(rel, 'rel');

	    var _link = sprintf('<%s>; rel="%s"', l, rel);
	    return (this.header('Link', _link));
	};


	/**
	 * sends the response object. convenience method that handles:
	 *     writeHead(), write(), end()
	 * @public
	 * @function send
	 * @param    {Number} code                      http status code
	 * @param    {Object | Buffer | Error} body     the content to send
	 * @param    {Object}                  headers  any add'l headers to set
	 * @returns  {Object}                           self, the response object
	 */
	Response.prototype.send = function send(code, body, headers) {
	    var isHead = (this.req.method === 'HEAD');
	    var log = this.log;
	    var self = this;

	    if (code === undefined) {
	        this.statusCode = 200;
	    } else if (code.constructor.name === 'Number') {
	        this.statusCode = code;

	        if (body instanceof Error) {
	            body.statusCode = this.statusCode;
	        }
	    } else {
	        headers = body;
	        body = code;
	        code = null;
	    }

	    headers = headers || {};

	    if (log.trace()) {
	        var _props = {
	            code: self.statusCode,
	            headers: headers
	        };

	        if (body instanceof Error) {
	            _props.err = body;
	        } else {
	            _props.body = body;
	        }
	        log.trace(_props, 'response::send entered');
	    }

	    this._body = body;

	    function _cb(err, _body) {
	        // the problem here is that if the formatter throws an error, we can't
	        // actually format the error again, since the formatter already failed.
	        // So all we can do is send back a 500 with no body, since we don't
	        // know at this point what format to send the error as. Additionally,
	        // the current 'after' event is emitted _before_ we send the response,
	        // so there's no way to re-emit the error here. TODO: clean up 'after'
	        // even emitter so we pick up the error here.
	        if (err) {
	            self._data = null;
	            self.statusCode = 500;
	            log.error(err, 'unable to format response');
	        } else {
	            self._data = _body;
	        }
	        Object.keys(headers).forEach(function (k) {
	            self.setHeader(k, headers[k]);
	        });

	        self.writeHead(self.statusCode);

	        if (self._data && !(isHead || code === 204 || code === 304)) {
	            self.write(self._data);
	        }

	        self.end();

	        if (log.trace()) {
	            log.trace({res: self}, 'response sent');
	        }
	    }

	    if (body !== undefined) {
	        this.format(body, _cb);
	    } else {
	        _cb(null, null);
	    }

	    return (this);
	};


	/**
	 * sets a header on the response.
	 * @public
	 * @function set
	 * @param    {String} name name of the header
	 * @param    {String} val  value of the header
	 * @returns  {Object}      self, the response object
	 */
	Response.prototype.set = function set(name, val) {
	    var self = this;

	    if (arguments.length === 2) {
	        assert.string(name, 'name');
	        this.header(name, val);
	    } else {
	        assert.object(name, 'object');
	        Object.keys(name).forEach(function (k) {
	            self.header(k, name[k]);
	        });
	    }

	    return (this);
	};


	/**
	 * sets the http status code on the response.
	 * @public
	 * @function status
	 * @param    {Number} code http status code
	 * @returns  {Number}     the status code passed in
	 */
	Response.prototype.status = function status(code) {
	    assert.number(code, 'code');

	    this.statusCode = code;
	    return (code);
	};


	/**
	 * toString() serialization.
	 * @public
	 * @function toString
	 * @returns  {String}
	 */
	Response.prototype.toString = function toString() {
	    var headers = this.getHeaders();
	    var headerString = '';
	    var str;

	    Object.keys(headers).forEach(function (k) {
	        headerString += k + ': ' + headers[k] + '\n';
	    });
	    str = sprintf('HTTP/1.1 %s %s\n%s',
	        this.statusCode,
	        http.STATUS_CODES[this.statusCode],
	        headerString);

	    return (str);
	};

	if (!Response.prototype.hasOwnProperty('_writeHead')) {
	    Response.prototype._writeHead = Response.prototype.writeHead;
	}


	/**
	 * pass through to native response.writeHead()
	 * @public
	 * @function writeHead
	 * @returns  {undefined}
	 */
	Response.prototype.writeHead = function restifyWriteHead() {
	    this.emit('header');

	    if (this.statusCode === 204 || this.statusCode === 304) {
	        this.removeHeader('Content-Length');
	        this.removeHeader('Content-MD5');
	        this.removeHeader('Content-Type');
	        this.removeHeader('Content-Encoding');
	    }

	    this._writeHead.apply(this, arguments);
	};


	/*
	 * redirect is sugar method for redirecting. takes a few different signatures:
	 * 1) res.redirect(301, 'www.foo.com', next);
	 * 2) res.redirect('www.foo.com', next);
	 * 3) res.redirect({...}, next);
	 * `next` is mandatory, to complete the response and trigger audit logger.
	 * @public
	 * @param    {Number | String}   arg1 the status code or url to direct to
	 * @param    {String | Function} arg2 the url to redirect to, or `next` fn
	 * @param    {Function}          arg3 `next` fn
	 * @function redirect
	 * @return   {undefined}
	 */
	Response.prototype.redirect = function redirect(arg1, arg2, arg3) {

	    var self = this;
	    var statusCode = 302;
	    var finalUri;
	    var next;

	    // 1) this is signature 1, where an explicit status code is passed in.
	    //    MUST guard against null here, passing null is likely indicative
	    //    of an attempt to call res.redirect(null, next);
	    //    as a way to do a reload of the current page.
	    if (arg1 && !isNaN(arg1)) {
	        statusCode = arg1;
	        finalUri = arg2;
	        next = arg3;
	    }

	    // 2) this is signaure number 2
	    else if (typeof (arg1) === 'string') {
	        // otherwise, it's a string, and use it directly
	        finalUri = arg1;
	        next = arg2;
	    }

	    // 3) signature number 3, using an options object.
	    else if (typeof (arg1) === 'object') {

	        // set next, then go to work.
	        next = arg2;

	        var req = self.req;
	        var opt = arg1 || {};
	        var currentFullPath = req.href();
	        var secure = (opt.hasOwnProperty('secure')) ?
	                        opt.secure :
	                        req.isSecure();

	        // if hostname is passed in, use that as the base,
	        // otherwise fall back on current url.
	        var parsedUri = url.parse(opt.hostname || currentFullPath, true);

	        // create the object we'll use to format for the final uri.
	        // this object will eventually get passed to url.format().
	        // can't use parsedUri to seed it, as it confuses the url module
	        // with some existing parsed state. instead, we'll pick the things
	        // we want and use that as a starting point.
	        finalUri = {
	            port: parsedUri.port,
	            hostname: parsedUri.hostname,
	            query: parsedUri.query,
	            pathname: parsedUri.pathname
	        };

	        // start building url based on options.
	        // first, set protocol.
	        finalUri.protocol = (secure === true) ? 'https' : 'http';

	        // then set host
	        if (opt.hostname) {
	            finalUri.hostname = opt.hostname;
	        }

	        // then set current path after the host
	        if (opt.pathname) {
	            finalUri.pathname = opt.pathname;
	        }

	        // then add query params
	        if (opt.query) {
	            if (opt.overrideQuery === true) {
	                finalUri.query = opt.query;
	            } else {
	                finalUri.query = utils.mergeQs(opt.query, finalUri.query);
	            }
	        }

	        // change status code to 301 permanent if specified
	        if (opt.permanent) {
	            statusCode = 301;
	        }
	    }

	    // if we're missing a next we should probably throw. if user wanted
	    // to redirect but we were unable to do so, we should not continue
	    // down the handler stack.
	    assert.func(next, 'res.redirect() requires a next param');

	    // if we are missing a finalized uri
	    // by this point, pass an error to next.
	    if (!finalUri) {
	        return (next(new InternalServerError('could not construct url')));
	    }

	    // now we're done constructing url, send the res
	    self.send(statusCode, null, {
	        location: url.format(finalUri)
	    });

	    // tell server to stop processing the handler stack.
	    return (next(false));
	};


/***/ },
/* 208 */
/***/ function(module, exports) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	/**
	 * takes an instance of a date object, formats it UTC
	 *     e.g., Wed, 17 Jun 2015 01:30:26 GMT
	 * @public
	 * @function httpDate
	 * @param    {Object} now a date object
	 * @returns  {String}     formatted dated object
	 */
	module.exports = function httpDate(now) {
	    if (!now) {
	        now = new Date();
	    }

	    return (now.toUTCString());
	};


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Exports

	module.exports = {
	    acceptParser: __webpack_require__(210),
	    auditLogger: __webpack_require__(211),
	    authorizationParser: __webpack_require__(212),
	    bodyParser: __webpack_require__(227),
	    conditionalRequest: __webpack_require__(253),
	    CORS: __webpack_require__(135),
	    dateParser: __webpack_require__(254),
	    jsonp: __webpack_require__(255),
	    urlEncodedBodyParser: __webpack_require__(230),
	    requestLogger: __webpack_require__(256),
	    gzipResponse: __webpack_require__(257),
	    fullResponse: __webpack_require__(258),
	    jsonBodyParser: __webpack_require__(229),
	    multipartBodyParser: __webpack_require__(236),
	    queryParser: __webpack_require__(259),
	    requestExpiry: __webpack_require__(260),
	    sanitizePath: __webpack_require__(261),
	    serveStatic: __webpack_require__(262),
	    throttle: __webpack_require__(264),

	    pre: {
	        pause: __webpack_require__(265),
	        sanitizePath: __webpack_require__(261),
	        userAgentConnection: __webpack_require__(266)
	    }
	};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);
	var mime = __webpack_require__(100);

	var NotAcceptableError = __webpack_require__(105).NotAcceptableError;


	/**
	 * Returns a plugin that will check the client's Accept header can be handled
	 * by this server.
	 *
	 * Note you can get the set of types allowed from a restify server by doing
	 * `server.acceptable`.
	 *
	 * @public
	 * @function acceptParser
	 * @throws   {NotAcceptableError}
	 * @param    {String}    acceptable array of accept types.
	 * @returns  {Function}             restify handler.
	 */
	function acceptParser(acceptable) {
	    if (!Array.isArray(acceptable)) {
	        acceptable = [acceptable];
	    }
	    assert.arrayOfString(acceptable, 'acceptable');

	    acceptable = acceptable.filter(function (a) {
	        return (a);
	    }).map(function (a) {
	            return ((a.indexOf('/') === -1) ? mime.lookup(a) : a);
	        }).filter(function (a) {
	            return (a);
	        });

	    var e = new NotAcceptableError('Server accepts: ' + acceptable.join());

	    function parseAccept(req, res, next) {
	        if (req.accepts(acceptable)) {
	            next();
	            return;
	        }

	        res.json(e);
	        next(false);
	    }

	    return (parseAccept);
	}

	module.exports = acceptParser;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);
	var bunyan = __webpack_require__(32);

	var HttpError = __webpack_require__(105).HttpError;


	///--- API

	/**
	 * Returns a Bunyan audit logger suitable to be used in a server.on('after')
	 * event.  I.e.:
	 *
	 * server.on('after', restify.auditLogger({ log: myAuditStream }));
	 *
	 * This logs at the INFO level.
	 *
	 * @public
	 * @function auditLogger
	 * @param   {Object}   options at least a bunyan logger (log).
	 * @returns {Function}         to be used in server.after.
	 */
	function auditLogger(options) {
	    assert.object(options, 'options');
	    assert.object(options.log, 'options.log');
	    var errSerializer = bunyan.stdSerializers.err;

	    if (options.log.serializers && options.log.serializers.err) {
	        errSerializer = options.log.serializers.err;
	    }

	    var log = options.log.child({
	        audit: true,
	        serializers: {
	            err: errSerializer,
	            req: function auditRequestSerializer(req) {
	                if (!req) {
	                    return (false);
	                }

	                var timers = {};
	                (req.timers || []).forEach(function (time) {
	                    var t = time.time;
	                    var _t = Math.floor((1000000 * t[0]) +
	                        (t[1] / 1000));
	                    timers[time.name] = _t;
	                });
	                return ({
	                    // account for native and queryParser plugin usage
	                    query: (typeof req.query === 'function') ?
	                            req.query() : req.query,
	                    method: req.method,
	                    url: req.url,
	                    headers: req.headers,
	                    httpVersion: req.httpVersion,
	                    trailers: req.trailers,
	                    version: req.version(),
	                    body: options.body === true ?
	                        req.body : undefined,
	                    timers: timers
	                });
	            },
	            res: function auditResponseSerializer(res) {
	                if (!res) {
	                    return (false);
	                }


	                var body;

	                if (options.body === true) {
	                    if (res._body instanceof HttpError) {
	                        body = res._body.body;
	                    } else {
	                        body = res._body;
	                    }
	                }

	                return ({
	                    statusCode: res.statusCode,
	                    headers: res._headers,
	                    trailer: res._trailer || false,
	                    body: body
	                });
	            }
	        }
	    });

	    function audit(req, res, route, err) {
	        var latency = res.get('Response-Time');

	        if (typeof (latency) !== 'number') {
	            latency = Date.now() - req._time;
	        }

	        var obj = {
	            remoteAddress: req.connection.remoteAddress,
	            remotePort: req.connection.remotePort,
	            req_id: req.getId(),
	            req: req,
	            res: res,
	            err: err,
	            latency: latency,
	            secure: req.secure,
	            _audit: true
	        };

	        log.info(obj, 'handled: %d', res.statusCode);

	        return (true);
	    }

	    return (audit);
	}


	///-- Exports

	module.exports = auditLogger;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var httpSignature = __webpack_require__(213);

	var errors = __webpack_require__(105);


	///--- Globals

	var InvalidHeaderError = errors.InvalidHeaderError;

	var OPTIONS = {
	    algorithms: [
	        'rsa-sha1',
	        'rsa-sha256',
	        'rsa-sha512',
	        'dsa-sha1',
	        'hmac-sha1',
	        'hmac-sha256',
	        'hmac-sha512'
	    ]
	};


	///--- Helpers

	function parseBasic(string) {
	    var decoded;
	    var index;
	    var pieces;

	    decoded = (new Buffer(string, 'base64')).toString('utf8');

	    if (!decoded) {
	        throw new InvalidHeaderError('Authorization header invalid');
	    }

	    index = decoded.indexOf(':');

	    if (index === -1) {
	        pieces = [decoded];
	    } else {
	        pieces = [decoded.slice(0, index), decoded.slice(index + 1)];
	    }

	    if (!pieces || typeof (pieces[0]) !== 'string') {
	        throw new InvalidHeaderError('Authorization header invalid');
	    }

	    // Allows for usernameless authentication
	    if (!pieces[0]) {
	        pieces[0] = null;
	    }

	    // Allows for passwordless authentication
	    if (!pieces[1]) {
	        pieces[1] = null;
	    }

	    return ({
	        username: pieces[0],
	        password: pieces[1]
	    });
	}


	function parseSignature(request, options) {
	    options = options || {};
	    options.algorithms = OPTIONS.algorithms;

	    try {
	        return (httpSignature.parseRequest(request, options));
	    } catch (e) {
	        throw new InvalidHeaderError('Authorization header invalid: ' +
	            e.message);
	    }
	}


	/**
	 * Returns a plugin that will parse the client's Authorization header.
	 *
	 * Subsequent handlers will see `req.authorization`, which looks like:
	 *
	 * {
	 *   scheme: <Basic|Signature|...>,
	 *   credentials: <Undecoded value of header>,
	 *   basic: {
	 *     username: $user
	 *     password: $password
	 *   }
	 * }
	 *
	 * `req.username` will also be set, and defaults to 'anonymous'.
	 *
	 * @public
	 * @function authorizationParser
	 * @throws   {InvalidArgumentError}
	 * @param    {Object} options an options object
	 * @returns  {Function}
	 */
	function authorizationParser(options) {

	    function parseAuthorization(req, res, next) {
	        req.authorization = {};
	        req.username = 'anonymous';

	        if (!req.headers.authorization) {
	            return (next());
	        }

	        var pieces = req.headers.authorization.split(' ', 2);

	        if (!pieces || pieces.length !== 2) {
	            var e = new InvalidHeaderError('BasicAuth content ' +
	                'is invalid.');
	            return (next(e));
	        }

	        req.authorization.scheme = pieces[0];
	        req.authorization.credentials = pieces[1];

	        try {
	            switch (pieces[0].toLowerCase()) {
	                case 'basic':
	                    req.authorization.basic = parseBasic(pieces[1]);
	                    req.username = req.authorization.basic.username;
	                    break;

	                case 'signature':
	                    req.authorization.signature =
	                        parseSignature(req, options);
	                    req.username =
	                        req.authorization.signature.keyId;
	                    break;

	                default:
	                    break;
	            }
	        } catch (e2) {
	            return (next(e2));
	        }

	        return (next());
	    }

	    return (parseAuthorization);
	}

	module.exports = authorizationParser;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.

	var parser = __webpack_require__(214);
	var signer = __webpack_require__(215);
	var verify = __webpack_require__(216);
	var util = __webpack_require__(217);



	///--- API

	module.exports = {

	  parse: parser.parseRequest,
	  parseRequest: parser.parseRequest,

	  sign: signer.signRequest,
	  signRequest: signer.signRequest,

	  sshKeyToPEM: util.sshKeyToPEM,
	  sshKeyFingerprint: util.fingerprint,
	  pemToRsaSSHKey: util.pemToRsaSSHKey,

	  verify: verify.verifySignature,
	  verifySignature: verify.verifySignature,
	  verifyHMAC: verify.verifyHMAC
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = __webpack_require__(4);
	var util = __webpack_require__(10);



	///--- Globals

	var Algorithms = {
	  'rsa-sha1': true,
	  'rsa-sha256': true,
	  'rsa-sha512': true,
	  'dsa-sha1': true,
	  'hmac-sha1': true,
	  'hmac-sha256': true,
	  'hmac-sha512': true
	};

	var State = {
	  New: 0,
	  Params: 1
	};

	var ParamsState = {
	  Name: 0,
	  Quote: 1,
	  Value: 2,
	  Comma: 3
	};



	///--- Specific Errors

	function HttpSignatureError(message, caller) {
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, caller || HttpSignatureError);

	  this.message = message;
	  this.name = caller.name;
	}
	util.inherits(HttpSignatureError, Error);

	function ExpiredRequestError(message) {
	  HttpSignatureError.call(this, message, ExpiredRequestError);
	}
	util.inherits(ExpiredRequestError, HttpSignatureError);


	function InvalidHeaderError(message) {
	  HttpSignatureError.call(this, message, InvalidHeaderError);
	}
	util.inherits(InvalidHeaderError, HttpSignatureError);


	function InvalidParamsError(message) {
	  HttpSignatureError.call(this, message, InvalidParamsError);
	}
	util.inherits(InvalidParamsError, HttpSignatureError);


	function MissingHeaderError(message) {
	  HttpSignatureError.call(this, message, MissingHeaderError);
	}
	util.inherits(MissingHeaderError, HttpSignatureError);



	///--- Exported API

	module.exports = {

	  /**
	   * Parses the 'Authorization' header out of an http.ServerRequest object.
	   *
	   * Note that this API will fully validate the Authorization header, and throw
	   * on any error.  It will not however check the signature, or the keyId format
	   * as those are specific to your environment.  You can use the options object
	   * to pass in extra constraints.
	   *
	   * As a response object you can expect this:
	   *
	   *     {
	   *       "scheme": "Signature",
	   *       "params": {
	   *         "keyId": "foo",
	   *         "algorithm": "rsa-sha256",
	   *         "headers": [
	   *           "date" or "x-date",
	   *           "content-md5"
	   *         ],
	   *         "signature": "base64"
	   *       },
	   *       "signingString": "ready to be passed to crypto.verify()"
	   *     }
	   *
	   * @param {Object} request an http.ServerRequest.
	   * @param {Object} options an optional options object with:
	   *                   - clockSkew: allowed clock skew in seconds (default 300).
	   *                   - headers: required header names (def: date or x-date)
	   *                   - algorithms: algorithms to support (default: all).
	   * @return {Object} parsed out object (see above).
	   * @throws {TypeError} on invalid input.
	   * @throws {InvalidHeaderError} on an invalid Authorization header error.
	   * @throws {InvalidParamsError} if the params in the scheme are invalid.
	   * @throws {MissingHeaderError} if the params indicate a header not present,
	   *                              either in the request headers from the params,
	   *                              or not in the params from a required header
	   *                              in options.
	   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
	   */
	  parseRequest: function parseRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(request.headers, 'request.headers');
	    if (options === undefined) {
	      options = {};
	    }
	    if (options.headers === undefined) {
	      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
	    }
	    assert.object(options, 'options');
	    assert.arrayOfString(options.headers, 'options.headers');
	    assert.optionalNumber(options.clockSkew, 'options.clockSkew');

	    if (!request.headers.authorization)
	      throw new MissingHeaderError('no authorization header present in ' +
	                                   'the request');

	    options.clockSkew = options.clockSkew || 300;


	    var i = 0;
	    var state = State.New;
	    var substate = ParamsState.Name;
	    var tmpName = '';
	    var tmpValue = '';

	    var parsed = {
	      scheme: '',
	      params: {},
	      signingString: '',

	      get algorithm() {
	        return this.params.algorithm.toUpperCase();
	      },

	      get keyId() {
	        return this.params.keyId;
	      }

	    };

	    var authz = request.headers.authorization;
	    for (i = 0; i < authz.length; i++) {
	      var c = authz.charAt(i);

	      switch (Number(state)) {

	      case State.New:
	        if (c !== ' ') parsed.scheme += c;
	        else state = State.Params;
	        break;

	      case State.Params:
	        switch (Number(substate)) {

	        case ParamsState.Name:
	          var code = c.charCodeAt(0);
	          // restricted name of A-Z / a-z
	          if ((code >= 0x41 && code <= 0x5a) || // A-Z
	              (code >= 0x61 && code <= 0x7a)) { // a-z
	            tmpName += c;
	          } else if (c === '=') {
	            if (tmpName.length === 0)
	              throw new InvalidHeaderError('bad param format');
	            substate = ParamsState.Quote;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        case ParamsState.Quote:
	          if (c === '"') {
	            tmpValue = '';
	            substate = ParamsState.Value;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        case ParamsState.Value:
	          if (c === '"') {
	            parsed.params[tmpName] = tmpValue;
	            substate = ParamsState.Comma;
	          } else {
	            tmpValue += c;
	          }
	          break;

	        case ParamsState.Comma:
	          if (c === ',') {
	            tmpName = '';
	            substate = ParamsState.Name;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        default:
	          throw new Error('Invalid substate');
	        }
	        break;

	      default:
	        throw new Error('Invalid substate');
	      }

	    }

	    if (!parsed.params.headers || parsed.params.headers === '') {
	      if (request.headers['x-date']) {
	        parsed.params.headers = ['x-date'];
	      } else {
	        parsed.params.headers = ['date'];
	      }
	    } else {
	      parsed.params.headers = parsed.params.headers.split(' ');
	    }

	    // Minimally validate the parsed object
	    if (!parsed.scheme || parsed.scheme !== 'Signature')
	      throw new InvalidHeaderError('scheme was not "Signature"');

	    if (!parsed.params.keyId)
	      throw new InvalidHeaderError('keyId was not specified');

	    if (!parsed.params.algorithm)
	      throw new InvalidHeaderError('algorithm was not specified');

	    if (!parsed.params.signature)
	      throw new InvalidHeaderError('signature was not specified');

	    // Check the algorithm against the official list
	    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
	    if (!Algorithms[parsed.params.algorithm])
	      throw new InvalidParamsError(parsed.params.algorithm +
	                                   ' is not supported');

	    // Build the signingString
	    for (i = 0; i < parsed.params.headers.length; i++) {
	      var h = parsed.params.headers[i].toLowerCase();
	      parsed.params.headers[i] = h;

	      if (h !== 'request-line') {
	        var value = request.headers[h];
	        if (!value)
	          throw new MissingHeaderError(h + ' was not in the request');
	        parsed.signingString += h + ': ' + value;
	      } else {
	        parsed.signingString +=
	          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
	      }

	      if ((i + 1) < parsed.params.headers.length)
	        parsed.signingString += '\n';
	    }

	    // Check against the constraints
	    var date;
	    if (request.headers.date || request.headers['x-date']) {
	        if (request.headers['x-date']) {
	          date = new Date(request.headers['x-date']);
	        } else {
	          date = new Date(request.headers.date);
	        }
	      var now = new Date();
	      var skew = Math.abs(now.getTime() - date.getTime());

	      if (skew > options.clockSkew * 1000) {
	        throw new ExpiredRequestError('clock skew of ' +
	                                      (skew / 1000) +
	                                      's was greater than ' +
	                                      options.clockSkew + 's');
	      }
	    }

	    options.headers.forEach(function (hdr) {
	      // Remember that we already checked any headers in the params
	      // were in the request, so if this passes we're good.
	      if (parsed.params.headers.indexOf(hdr) < 0)
	        throw new MissingHeaderError(hdr + ' was not a signed header');
	    });

	    if (options.algorithms) {
	      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
	        throw new InvalidParamsError(parsed.params.algorithm +
	                                     ' is not a supported algorithm');
	    }

	    return parsed;
	  }

	};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = __webpack_require__(4);
	var crypto = __webpack_require__(59);
	var http = __webpack_require__(76);

	var sprintf = __webpack_require__(10).format;



	///--- Globals

	var Algorithms = {
	  'rsa-sha1': true,
	  'rsa-sha256': true,
	  'rsa-sha512': true,
	  'dsa-sha1': true,
	  'hmac-sha1': true,
	  'hmac-sha256': true,
	  'hmac-sha512': true
	};

	var Authorization =
	  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';



	///--- Specific Errors

	function MissingHeaderError(message) {
	    this.name = 'MissingHeaderError';
	    this.message = message;
	    this.stack = (new Error()).stack;
	}
	MissingHeaderError.prototype = new Error();


	function InvalidAlgorithmError(message) {
	    this.name = 'InvalidAlgorithmError';
	    this.message = message;
	    this.stack = (new Error()).stack;
	}
	InvalidAlgorithmError.prototype = new Error();



	///--- Internal Functions

	function _pad(val) {
	  if (parseInt(val, 10) < 10) {
	    val = '0' + val;
	  }
	  return val;
	}


	function _rfc1123() {
	  var date = new Date();

	  var months = ['Jan',
	                'Feb',
	                'Mar',
	                'Apr',
	                'May',
	                'Jun',
	                'Jul',
	                'Aug',
	                'Sep',
	                'Oct',
	                'Nov',
	                'Dec'];
	  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	  return days[date.getUTCDay()] + ', ' +
	    _pad(date.getUTCDate()) + ' ' +
	    months[date.getUTCMonth()] + ' ' +
	    date.getUTCFullYear() + ' ' +
	    _pad(date.getUTCHours()) + ':' +
	    _pad(date.getUTCMinutes()) + ':' +
	    _pad(date.getUTCSeconds()) +
	    ' GMT';
	}



	///--- Exported API

	module.exports = {

	  /**
	   * Adds an 'Authorization' header to an http.ClientRequest object.
	   *
	   * Note that this API will add a Date header if it's not already set. Any
	   * other headers in the options.headers array MUST be present, or this
	   * will throw.
	   *
	   * You shouldn't need to check the return type; it's just there if you want
	   * to be pedantic.
	   *
	   * @param {Object} request an instance of http.ClientRequest.
	   * @param {Object} options signing parameters object:
	   *                   - {String} keyId required.
	   *                   - {String} key required (either a PEM or HMAC key).
	   *                   - {Array} headers optional; defaults to ['date'].
	   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
	   *                   - {String} httpVersion optional; defaults to '1.1'.
	   * @return {Boolean} true if Authorization (and optionally Date) were added.
	   * @throws {TypeError} on bad parameter types (input).
	   * @throws {InvalidAlgorithmError} if algorithm was bad.
	   * @throws {MissingHeaderError} if a header to be signed was specified but
	   *                              was not present.
	   */
	  signRequest: function signRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(options, 'options');
	    assert.optionalString(options.algorithm, 'options.algorithm');
	    assert.string(options.keyId, 'options.keyId');
	    assert.optionalArrayOfString(options.headers, 'options.headers');
	    assert.optionalString(options.httpVersion, 'options.httpVersion');

	    if (!request.getHeader('Date'))
	      request.setHeader('Date', _rfc1123());
	    if (!options.headers)
	      options.headers = ['date'];
	    if (!options.algorithm)
	      options.algorithm = 'rsa-sha256';
	    if (!options.httpVersion)
	      options.httpVersion = '1.1';

	    options.algorithm = options.algorithm.toLowerCase();

	    if (!Algorithms[options.algorithm])
	      throw new InvalidAlgorithmError(options.algorithm + ' is not supported');

	    var i;
	    var stringToSign = '';
	    for (i = 0; i < options.headers.length; i++) {
	      if (typeof (options.headers[i]) !== 'string')
	        throw new TypeError('options.headers must be an array of Strings');

	      var h = options.headers[i].toLowerCase();

	      if (h !== 'request-line') {
	        var value = request.getHeader(h);
	        if (!value) {
	          throw new MissingHeaderError(h + ' was not in the request');
	        }
	        stringToSign += h + ': ' + value;
	      } else {
	        stringToSign +=
	          request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
	      }

	      if ((i + 1) < options.headers.length)
	        stringToSign += '\n';
	    }

	    var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
	    var signature;
	    if (alg[1] === 'hmac') {
	      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
	      hmac.update(stringToSign);
	      signature = hmac.digest('base64');
	    } else {
	      var signer = crypto.createSign(options.algorithm.toUpperCase());
	      signer.update(stringToSign);
	      signature = signer.sign(options.key, 'base64');
	    }

	    request.setHeader('Authorization', sprintf(Authorization,
	                                               options.keyId,
	                                               options.algorithm,
	                                               options.headers.join(' '),
	                                               signature));

	    return true;
	  }

	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.

	var assert = __webpack_require__(4);
	var crypto = __webpack_require__(59);



	///--- Exported API

	module.exports = {
	  /**
	   * Verify RSA/DSA signature against public key.  You are expected to pass in
	   * an object that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} pubkey RSA/DSA private key PEM.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   */
	  verifySignature: function verifySignature(parsedSignature, pubkey) {
	    assert.object(parsedSignature, 'parsedSignature');
	    assert.string(pubkey, 'pubkey');

	    var alg = parsedSignature.algorithm.match(/^(RSA|DSA)-(\w+)/);
	    if (!alg || alg.length !== 3)
	      throw new TypeError('parsedSignature: unsupported algorithm ' +
	                          parsedSignature.algorithm);

	    var verify = crypto.createVerify(alg[0]);
	    verify.update(parsedSignature.signingString);
	    return verify.verify(pubkey, parsedSignature.params.signature, 'base64');
	  },

	  /**
	   * Verify HMAC against shared secret.  You are expected to pass in an object
	   * that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} secret HMAC shared secret.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   */
	  verifyHMAC: function verifyHMAC(parsedSignature, secret) {
	    assert.object(parsedSignature, 'parsedHMAC');
	    assert.string(secret, 'secret');

	    var alg = parsedSignature.algorithm.match(/^HMAC-(\w+)/);
	    if (!alg || alg.length !== 2)
	      throw new TypeError('parsedSignature: unsupported algorithm ' +
	                          parsedSignature.algorithm);

	    var hmac = crypto.createHmac(alg[1].toUpperCase(), secret);
	    hmac.update(parsedSignature.signingString);
	    return (hmac.digest('base64') === parsedSignature.params.signature);
	  }
	};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = __webpack_require__(4);
	var crypto = __webpack_require__(59);

	var asn1 = __webpack_require__(218);
	var ctype = __webpack_require__(224);



	///--- Helpers

	function readNext(buffer, offset) {
	  var len = ctype.ruint32(buffer, 'big', offset);
	  offset += 4;

	  var newOffset = offset + len;

	  return {
	    data: buffer.slice(offset, newOffset),
	    offset: newOffset
	  };
	}


	function writeInt(writer, buffer) {
	  writer.writeByte(0x02); // ASN1.Integer
	  writer.writeLength(buffer.length);

	  for (var i = 0; i < buffer.length; i++)
	    writer.writeByte(buffer[i]);

	  return writer;
	}


	function rsaToPEM(key) {
	  var buffer;
	  var der;
	  var exponent;
	  var i;
	  var modulus;
	  var newKey = '';
	  var offset = 0;
	  var type;
	  var tmp;

	  try {
	    buffer = new Buffer(key.split(' ')[1], 'base64');

	    tmp = readNext(buffer, offset);
	    type = tmp.data.toString();
	    offset = tmp.offset;

	    if (type !== 'ssh-rsa')
	      throw new Error('Invalid ssh key type: ' + type);

	    tmp = readNext(buffer, offset);
	    exponent = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    modulus = tmp.data;
	  } catch (e) {
	    throw new Error('Invalid ssh key: ' + key);
	  }

	  // DER is a subset of BER
	  der = new asn1.BerWriter();

	  der.startSequence();

	  der.startSequence();
	  der.writeOID('1.2.840.113549.1.1.1');
	  der.writeNull();
	  der.endSequence();

	  der.startSequence(0x03); // bit string
	  der.writeByte(0x00);

	  // Actual key
	  der.startSequence();
	  writeInt(der, modulus);
	  writeInt(der, exponent);
	  der.endSequence();

	  // bit string
	  der.endSequence();

	  der.endSequence();

	  tmp = der.buffer.toString('base64');
	  for (i = 0; i < tmp.length; i++) {
	    if ((i % 64) === 0)
	      newKey += '\n';
	    newKey += tmp.charAt(i);
	  }

	  if (!/\\n$/.test(newKey))
	    newKey += '\n';

	  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
	}


	function dsaToPEM(key) {
	  var buffer;
	  var offset = 0;
	  var tmp;
	  var der;
	  var newKey = '';

	  var type;
	  var p;
	  var q;
	  var g;
	  var y;

	  try {
	    buffer = new Buffer(key.split(' ')[1], 'base64');

	    tmp = readNext(buffer, offset);
	    type = tmp.data.toString();
	    offset = tmp.offset;

	    /* JSSTYLED */
	    if (!/^ssh-ds[as].*/.test(type))
	      throw new Error('Invalid ssh key type: ' + type);

	    tmp = readNext(buffer, offset);
	    p = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    q = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    g = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    y = tmp.data;
	  } catch (e) {
	    console.log(e.stack);
	    throw new Error('Invalid ssh key: ' + key);
	  }

	  // DER is a subset of BER
	  der = new asn1.BerWriter();

	  der.startSequence();

	  der.startSequence();
	  der.writeOID('1.2.840.10040.4.1');

	  der.startSequence();
	  writeInt(der, p);
	  writeInt(der, q);
	  writeInt(der, g);
	  der.endSequence();

	  der.endSequence();

	  der.startSequence(0x03); // bit string
	  der.writeByte(0x00);
	  writeInt(der, y);
	  der.endSequence();

	  der.endSequence();

	  tmp = der.buffer.toString('base64');
	  for (var i = 0; i < tmp.length; i++) {
	    if ((i % 64) === 0)
	      newKey += '\n';
	    newKey += tmp.charAt(i);
	  }

	  if (!/\\n$/.test(newKey))
	    newKey += '\n';

	  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
	}


	///--- API

	module.exports = {

	  /**
	   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
	   *
	   * The intent of this module is to interoperate with OpenSSL only,
	   * specifically the node crypto module's `verify` method.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} PEM encoded form of the RSA public key.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} on invalid ssh key formatted data.
	   */
	  sshKeyToPEM: function sshKeyToPEM(key) {
	    assert.string(key, 'ssh_key');

	    /* JSSTYLED */
	    if (/^ssh-rsa.*/.test(key))
	      return rsaToPEM(key);

	    /* JSSTYLED */
	    if (/^ssh-ds[as].*/.test(key))
	      return dsaToPEM(key);

	    throw new Error('Only RSA and DSA public keys are allowed');
	  },


	  /**
	   * Generates an OpenSSH fingerprint from an ssh public key.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} key fingerprint.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} if what you passed doesn't look like an ssh public key.
	   */
	  fingerprint: function fingerprint(key) {
	    assert.string(key, 'ssh_key');

	    var pieces = key.split(' ');
	    if (!pieces || !pieces.length || pieces.length < 2)
	      throw new Error('invalid ssh key');

	    var data = new Buffer(pieces[1], 'base64');

	    var hash = crypto.createHash('md5');
	    hash.update(data);
	    var digest = hash.digest('hex');

	    var fp = '';
	    for (var i = 0; i < digest.length; i++) {
	      if (i && i % 2 === 0)
	        fp += ':';

	      fp += digest[i];
	    }

	    return fp;
	  },

	  /**
	   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
	   *
	   * The reverse of the above function.
	   */
	  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
	    assert.equal('string', typeof (pem), 'typeof pem');

	    // chop off the BEGIN PUBLIC KEY and END PUBLIC KEY portion
	    var cleaned = pem.split('\n').slice(1, -2).join('');

	    var buf = new Buffer(cleaned, 'base64');

	    var der = new asn1.BerReader(buf);

	    der.readSequence();
	    der.readSequence();

	    var oid = der.readOID();
	    assert.equal(oid, '1.2.840.113549.1.1.1', 'pem not in RSA format');

	    // Null -- XXX this probably isn't good practice
	    der.readByte();
	    der.readByte();

	    // bit string sequence
	    der.readSequence(0x03);
	    der.readByte();
	    der.readSequence();

	    // modulus
	    assert.equal(der.peek(), asn1.Ber.Integer, 'modulus not an integer');
	    der._offset = der.readLength(der.offset + 1);
	    var modulus = der._buf.slice(der.offset, der.offset + der.length);
	    der._offset += der.length;

	    // exponent
	    assert.equal(der.peek(), asn1.Ber.Integer, 'exponent not an integer');
	    der._offset = der.readLength(der.offset + 1);
	    var exponent = der._buf.slice(der.offset, der.offset + der.length);
	    der._offset += der.length;

	    // now, make the key
	    var type = new Buffer('ssh-rsa');
	    var buffer = new Buffer(4 + type.length + 4 + modulus.length +
	      4 + exponent.length);
	    var i = 0;
	    buffer.writeUInt32BE(type.length, i);     i += 4;
	    type.copy(buffer, i);                     i += type.length;
	    buffer.writeUInt32BE(exponent.length, i); i += 4;
	    exponent.copy(buffer, i);                 i += exponent.length;
	    buffer.writeUInt32BE(modulus.length, i);  i += 4;
	    modulus.copy(buffer, i);                  i += modulus.length;

	    var s = (type.toString() + ' ' + buffer.toString('base64') + ' ' +
	      (comment || ''));
	    return s;
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	// If you have no idea what ASN.1 or BER is, see this:
	// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

	var Ber = __webpack_require__(219);



	///--- Exported API

	module.exports = {

	  Ber: Ber,

	  BerReader: Ber.Reader,

	  BerWriter: Ber.Writer

	};


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var errors = __webpack_require__(220);
	var types = __webpack_require__(221);

	var Reader = __webpack_require__(222);
	var Writer = __webpack_require__(223);


	///--- Exports

	module.exports = {

	  Reader: Reader,

	  Writer: Writer

	};

	for (var t in types) {
	  if (types.hasOwnProperty(t))
	    module.exports[t] = types[t];
	}
	for (var e in errors) {
	  if (errors.hasOwnProperty(e))
	    module.exports[e] = errors[e];
	}


/***/ },
/* 220 */
/***/ function(module, exports) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


	module.exports = {

	  newInvalidAsn1Error: function(msg) {
	    var e = new Error();
	    e.name = 'InvalidAsn1Error';
	    e.message = msg || '';
	    return e;
	  }

	};


/***/ },
/* 221 */
/***/ function(module, exports) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


	module.exports = {
	  EOC: 0,
	  Boolean: 1,
	  Integer: 2,
	  BitString: 3,
	  OctetString: 4,
	  Null: 5,
	  OID: 6,
	  ObjectDescriptor: 7,
	  External: 8,
	  Real: 9, // float
	  Enumeration: 10,
	  PDV: 11,
	  Utf8String: 12,
	  RelativeOID: 13,
	  Sequence: 16,
	  Set: 17,
	  NumericString: 18,
	  PrintableString: 19,
	  T61String: 20,
	  VideotexString: 21,
	  IA5String: 22,
	  UTCTime: 23,
	  GeneralizedTime: 24,
	  GraphicString: 25,
	  VisibleString: 26,
	  GeneralString: 28,
	  UniversalString: 29,
	  CharacterString: 30,
	  BMPString: 31,
	  Constructor: 32,
	  Context: 128
	};


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var assert = __webpack_require__(9);

	var ASN1 = __webpack_require__(221);
	var errors = __webpack_require__(220);


	///--- Globals

	var newInvalidAsn1Error = errors.newInvalidAsn1Error;



	///--- API

	function Reader(data) {
	  if (!data || !Buffer.isBuffer(data))
	    throw new TypeError('data must be a node Buffer');

	  this._buf = data;
	  this._size = data.length;

	  // These hold the "current" state
	  this._len = 0;
	  this._offset = 0;

	  var self = this;
	  this.__defineGetter__('length', function() { return self._len; });
	  this.__defineGetter__('offset', function() { return self._offset; });
	  this.__defineGetter__('remain', function() {
	    return self._size - self._offset;
	  });
	  this.__defineGetter__('buffer', function() {
	    return self._buf.slice(self._offset);
	  });
	}


	/**
	 * Reads a single byte and advances offset; you can pass in `true` to make this
	 * a "peek" operation (i.e., get the byte, but don't advance the offset).
	 *
	 * @param {Boolean} peek true means don't move offset.
	 * @return {Number} the next byte, null if not enough data.
	 */
	Reader.prototype.readByte = function(peek) {
	  if (this._size - this._offset < 1)
	    return null;

	  var b = this._buf[this._offset] & 0xff;

	  if (!peek)
	    this._offset += 1;

	  return b;
	};


	Reader.prototype.peek = function() {
	  return this.readByte(true);
	};


	/**
	 * Reads a (potentially) variable length off the BER buffer.  This call is
	 * not really meant to be called directly, as callers have to manipulate
	 * the internal buffer afterwards.
	 *
	 * As a result of this call, you can call `Reader.length`, until the
	 * next thing called that does a readLength.
	 *
	 * @return {Number} the amount of offset to advance the buffer.
	 * @throws {InvalidAsn1Error} on bad ASN.1
	 */
	Reader.prototype.readLength = function(offset) {
	  if (offset === undefined)
	    offset = this._offset;

	  if (offset >= this._size)
	    return null;

	  var lenB = this._buf[offset++] & 0xff;
	  if (lenB === null)
	    return null;

	  if ((lenB & 0x80) == 0x80) {
	    lenB &= 0x7f;

	    if (lenB == 0)
	      throw newInvalidAsn1Error('Indefinite length not supported');

	    if (lenB > 4)
	      throw newInvalidAsn1Error('encoding too long');

	    if (this._size - offset < lenB)
	      return null;

	    this._len = 0;
	    for (var i = 0; i < lenB; i++)
	      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

	  } else {
	    // Wasn't a variable length
	    this._len = lenB;
	  }

	  return offset;
	};


	/**
	 * Parses the next sequence in this BER buffer.
	 *
	 * To get the length of the sequence, call `Reader.length`.
	 *
	 * @return {Number} the sequence's tag.
	 */
	Reader.prototype.readSequence = function(tag) {
	  var seq = this.peek();
	  if (seq === null)
	    return null;
	  if (tag !== undefined && tag !== seq)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + seq.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  this._offset = o;
	  return seq;
	};


	Reader.prototype.readInt = function() {
	  return this._readTag(ASN1.Integer);
	};


	Reader.prototype.readBoolean = function() {
	  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
	};


	Reader.prototype.readEnumeration = function() {
	  return this._readTag(ASN1.Enumeration);
	};


	Reader.prototype.readString = function(tag, retbuf) {
	  if (!tag)
	    tag = ASN1.OctetString;

	  var b = this.peek();
	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`

	  if (o === null)
	    return null;

	  if (this.length > this._size - o)
	    return null;

	  this._offset = o;

	  if (this.length === 0)
	    return '';

	  var str = this._buf.slice(this._offset, this._offset + this.length);
	  this._offset += this.length;

	  return retbuf ? str : str.toString('utf8');
	};

	Reader.prototype.readOID = function(tag) {
	  if (!tag)
	    tag = ASN1.OID;

	  var b = this.peek();
	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  if (this.length > this._size - o)
	    return null;

	  this._offset = o;

	  var values = [];
	  var value = 0;

	  for (var i = 0; i < this.length; i++) {
	    var byte = this._buf[this._offset++] & 0xff;

	    value <<= 7;
	    value += byte & 0x7f;
	    if ((byte & 0x80) == 0) {
	      values.push(value);
	      value = 0;
	    }
	  }

	  value = values.shift();
	  values.unshift(value % 40);
	  values.unshift((value / 40) >> 0);

	  return values.join('.');
	};


	Reader.prototype._readTag = function(tag) {
	  assert.ok(tag !== undefined);

	  var b = this.peek();

	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  if (this.length > 4)
	    throw newInvalidAsn1Error('Integer too long: ' + this.length);

	  if (this.length > this._size - o)
	    return null;
	  this._offset = o;

	  var fb = this._buf[this._offset++];
	  var value = 0;

	  value = fb & 0x7F;
	  for (var i = 1; i < this.length; i++) {
	    value <<= 8;
	    value |= (this._buf[this._offset++] & 0xff);
	  }

	  if ((fb & 0x80) == 0x80)
	    value = -value;

	  return value;
	};



	///--- Exported API

	module.exports = Reader;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var assert = __webpack_require__(9);
	var ASN1 = __webpack_require__(221);
	var errors = __webpack_require__(220);


	///--- Globals

	var newInvalidAsn1Error = errors.newInvalidAsn1Error;

	var DEFAULT_OPTS = {
	  size: 1024,
	  growthFactor: 8
	};


	///--- Helpers

	function merge(from, to) {
	  assert.ok(from);
	  assert.equal(typeof(from), 'object');
	  assert.ok(to);
	  assert.equal(typeof(to), 'object');

	  var keys = Object.getOwnPropertyNames(from);
	  keys.forEach(function(key) {
	    if (to[key])
	      return;

	    var value = Object.getOwnPropertyDescriptor(from, key);
	    Object.defineProperty(to, key, value);
	  });

	  return to;
	}



	///--- API

	function Writer(options) {
	  options = merge(DEFAULT_OPTS, options || {});

	  this._buf = new Buffer(options.size || 1024);
	  this._size = this._buf.length;
	  this._offset = 0;
	  this._options = options;

	  // A list of offsets in the buffer where we need to insert
	  // sequence tag/len pairs.
	  this._seq = [];

	  var self = this;
	  this.__defineGetter__('buffer', function() {
	    if (self._seq.length)
	      throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');

	    return self._buf.slice(0, self._offset);
	  });
	}


	Writer.prototype.writeByte = function(b) {
	  if (typeof(b) !== 'number')
	    throw new TypeError('argument must be a Number');

	  this._ensure(1);
	  this._buf[this._offset++] = b;
	};


	Writer.prototype.writeInt = function(i, tag) {
	  if (typeof(i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Integer;

	  var sz = 4;

	  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) &&
	         (sz > 1)) {
	    sz--;
	    i <<= 8;
	  }

	  if (sz > 4)
	    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');

	  this._ensure(2 + sz);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = sz;

	  while (sz-- > 0) {
	    this._buf[this._offset++] = ((i & 0xff000000) >> 24);
	    i <<= 8;
	  }

	};


	Writer.prototype.writeNull = function() {
	  this.writeByte(ASN1.Null);
	  this.writeByte(0x00);
	};


	Writer.prototype.writeEnumeration = function(i, tag) {
	  if (typeof(i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Enumeration;

	  return this.writeInt(i, tag);
	};


	Writer.prototype.writeBoolean = function(b, tag) {
	  if (typeof(b) !== 'boolean')
	    throw new TypeError('argument must be a Boolean');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Boolean;

	  this._ensure(3);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = 0x01;
	  this._buf[this._offset++] = b ? 0xff : 0x00;
	};


	Writer.prototype.writeString = function(s, tag) {
	  if (typeof(s) !== 'string')
	    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.OctetString;

	  var len = Buffer.byteLength(s);
	  this.writeByte(tag);
	  this.writeLength(len);
	  if (len) {
	    this._ensure(len);
	    this._buf.write(s, this._offset);
	    this._offset += len;
	  }
	};


	Writer.prototype.writeBuffer = function(buf, tag) {
	  if (typeof(tag) !== 'number')
	    throw new TypeError('tag must be a number');
	  if (!Buffer.isBuffer(buf))
	    throw new TypeError('argument must be a buffer');

	  this.writeByte(tag);
	  this.writeLength(buf.length);
	  this._ensure(buf.length);
	  buf.copy(this._buf, this._offset, 0, buf.length);
	  this._offset += buf.length;
	};


	Writer.prototype.writeStringArray = function(strings) {
	  if ((!strings instanceof Array))
	    throw new TypeError('argument must be an Array[String]');

	  var self = this;
	  strings.forEach(function(s) {
	    self.writeString(s);
	  });
	};

	// This is really to solve DER cases, but whatever for now
	Writer.prototype.writeOID = function(s, tag) {
	  if (typeof(s) !== 'string')
	    throw new TypeError('argument must be a string');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.OID;

	  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
	    throw new Error('argument is not a valid OID string');

	  function encodeOctet(bytes, octet) {
	    if (octet < 128) {
	        bytes.push(octet);
	    } else if (octet < 16384) {
	        bytes.push((octet >>> 7) | 0x80);
	        bytes.push(octet & 0x7F);
	    } else if (octet < 2097152) {
	      bytes.push((octet >>> 14) | 0x80);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else if (octet < 268435456) {
	      bytes.push((octet >>> 21) | 0x80);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else {
	      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    }
	  }

	  var tmp = s.split('.');
	  var bytes = [];
	  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
	  tmp.slice(2).forEach(function(b) {
	    encodeOctet(bytes, parseInt(b, 10));
	  });

	  var self = this;
	  this._ensure(2 + bytes.length);
	  this.writeByte(tag);
	  this.writeLength(bytes.length);
	  bytes.forEach(function(b) {
	    self.writeByte(b);
	  });
	};


	Writer.prototype.writeLength = function(len) {
	  if (typeof(len) !== 'number')
	    throw new TypeError('argument must be a Number');

	  this._ensure(4);

	  if (len <= 0x7f) {
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xff) {
	    this._buf[this._offset++] = 0x81;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffff) {
	    this._buf[this._offset++] = 0x82;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffffff) {
	    this._shift(start, len, 1);
	    this._buf[this._offset++] = 0x83;
	    this._buf[this._offset++] = len >> 16;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else {
	    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
	  }
	};

	Writer.prototype.startSequence = function(tag) {
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Sequence | ASN1.Constructor;

	  this.writeByte(tag);
	  this._seq.push(this._offset);
	  this._ensure(3);
	  this._offset += 3;
	};


	Writer.prototype.endSequence = function() {
	  var seq = this._seq.pop();
	  var start = seq + 3;
	  var len = this._offset - start;

	  if (len <= 0x7f) {
	    this._shift(start, len, -2);
	    this._buf[seq] = len;
	  } else if (len <= 0xff) {
	    this._shift(start, len, -1);
	    this._buf[seq] = 0x81;
	    this._buf[seq + 1] = len;
	  } else if (len <= 0xffff) {
	    this._buf[seq] = 0x82;
	    this._buf[seq + 1] = len >> 8;
	    this._buf[seq + 2] = len;
	  } else if (len <= 0xffffff) {
	    this._shift(start, len, 1);
	    this._buf[seq] = 0x83;
	    this._buf[seq + 1] = len >> 16;
	    this._buf[seq + 2] = len >> 8;
	    this._buf[seq + 3] = len;
	  } else {
	    throw new InvalidAsn1Error('Sequence too long');
	  }
	};


	Writer.prototype._shift = function(start, len, shift) {
	  assert.ok(start !== undefined);
	  assert.ok(len !== undefined);
	  assert.ok(shift);

	  this._buf.copy(this._buf, start + shift, start, start + len);
	  this._offset += shift;
	};

	Writer.prototype._ensure = function(len) {
	  assert.ok(len);

	  if (this._size - this._offset < len) {
	    var sz = this._size * this._options.growthFactor;
	    if (sz - this._offset < len)
	      sz += len;

	    var buf = new Buffer(sz);

	    this._buf.copy(buf, 0, 0, this._offset);
	    this._buf = buf;
	    this._size = sz;
	  }
	};



	///--- Exported API

	module.exports = Writer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	 * rm - Feb 2011
	 * ctype.js
	 *
	 * This module provides a simple abstraction towards reading and writing
	 * different types of binary data. It is designed to use ctio.js and provide a
	 * richer and more expressive API on top of it.
	 *
	 * By default we support the following as built in basic types:
	 *	int8_t
	 *	int16_t
	 *	int32_t
	 *	uint8_t
	 *	uint16_t
	 *	uint32_t
	 *	uint64_t
	 *	float
	 *	double
	 *	char
	 *	char[]
	 *
	 * Each type is returned as a Number, with the exception of char and char[]
	 * which are returned as Node Buffers. A char is considered a uint8_t.
	 *
	 * Requests to read and write data are specified as an array of JSON objects.
	 * This is also the same way that one declares structs. Even if just a single
	 * value is requested, it must be done as a struct. The array order determines
	 * the order that we try and read values. Each entry has the following format
	 * with values marked with a * being optional.
	 *
	 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
	 *
	 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
	 * value. Value is defined when we're writing out data, otherwise it's ignored.
	 *
	 */

	var mod_ctf = __webpack_require__(225);
	var mod_ctio = __webpack_require__(226);
	var mod_assert = __webpack_require__(9);

	/*
	 * This is the set of basic types that we support.
	 *
	 *	read		The function to call to read in a value from a buffer
	 *
	 *	write		The function to call to write a value to a buffer
	 *
	 */
	var deftypes = {
	    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
	    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
	    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
	    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
	    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
	    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
	    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
	    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
	    'float': { read: ctReadFloat, write: ctWriteFloat },
	    'double': { read: ctReadDouble, write: ctWriteDouble },
	    'char': { read: ctReadChar, write: ctWriteChar },
	    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
	};

	/*
	 * The following are wrappers around the CType IO low level API. They encode
	 * knowledge about the size and return something in the expected format.
	 */
	function ctReadUint8(endian, buffer, offset)
	{
		var val = mod_ctio.ruint8(buffer, endian, offset);
		return ({ value: val, size: 1 });
	}

	function ctReadUint16(endian, buffer, offset)
	{
		var val = mod_ctio.ruint16(buffer, endian, offset);
		return ({ value: val, size: 2 });
	}

	function ctReadUint32(endian, buffer, offset)
	{
		var val = mod_ctio.ruint32(buffer, endian, offset);
		return ({ value: val, size: 4 });
	}

	function ctReadUint64(endian, buffer, offset)
	{
		var val = mod_ctio.ruint64(buffer, endian, offset);
		return ({ value: val, size: 8 });
	}

	function ctReadSint8(endian, buffer, offset)
	{
		var val = mod_ctio.rsint8(buffer, endian, offset);
		return ({ value: val, size: 1 });
	}

	function ctReadSint16(endian, buffer, offset)
	{
		var val = mod_ctio.rsint16(buffer, endian, offset);
		return ({ value: val, size: 2 });
	}

	function ctReadSint32(endian, buffer, offset)
	{
		var val = mod_ctio.rsint32(buffer, endian, offset);
		return ({ value: val, size: 4 });
	}

	function ctReadSint64(endian, buffer, offset)
	{
		var val = mod_ctio.rsint64(buffer, endian, offset);
		return ({ value: val, size: 8 });
	}

	function ctReadFloat(endian, buffer, offset)
	{
		var val = mod_ctio.rfloat(buffer, endian, offset);
		return ({ value: val, size: 4 });
	}

	function ctReadDouble(endian, buffer, offset)
	{
		var val = mod_ctio.rdouble(buffer, endian, offset);
		return ({ value: val, size: 8 });
	}

	/*
	 * Reads a single character into a node buffer
	 */
	function ctReadChar(endian, buffer, offset)
	{
		var res = new Buffer(1);
		res[0] = mod_ctio.ruint8(buffer, endian, offset);
		return ({ value: res, size: 1 });
	}

	function ctReadCharArray(length, endian, buffer, offset)
	{
		var ii;
		var res = new Buffer(length);

		for (ii = 0; ii < length; ii++)
			res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);

		return ({ value: res, size: length });
	}

	function ctWriteUint8(value, endian, buffer, offset)
	{
		mod_ctio.wuint8(value, endian, buffer, offset);
		return (1);
	}

	function ctWriteUint16(value, endian, buffer, offset)
	{
		mod_ctio.wuint16(value, endian, buffer, offset);
		return (2);
	}

	function ctWriteUint32(value, endian, buffer, offset)
	{
		mod_ctio.wuint32(value, endian, buffer, offset);
		return (4);
	}

	function ctWriteUint64(value, endian, buffer, offset)
	{
		mod_ctio.wuint64(value, endian, buffer, offset);
		return (8);
	}

	function ctWriteSint8(value, endian, buffer, offset)
	{
		mod_ctio.wsint8(value, endian, buffer, offset);
		return (1);
	}

	function ctWriteSint16(value, endian, buffer, offset)
	{
		mod_ctio.wsint16(value, endian, buffer, offset);
		return (2);
	}

	function ctWriteSint32(value, endian, buffer, offset)
	{
		mod_ctio.wsint32(value, endian, buffer, offset);
		return (4);
	}

	function ctWriteSint64(value, endian, buffer, offset)
	{
		mod_ctio.wsint64(value, endian, buffer, offset);
		return (8);
	}

	function ctWriteFloat(value, endian, buffer, offset)
	{
		mod_ctio.wfloat(value, endian, buffer, offset);
		return (4);
	}

	function ctWriteDouble(value, endian, buffer, offset)
	{
		mod_ctio.wdouble(value, endian, buffer, offset);
		return (8);
	}

	/*
	 * Writes a single character into a node buffer
	 */
	function ctWriteChar(value, endian, buffer, offset)
	{
		if (!(value instanceof Buffer))
			throw (new Error('Input must be a buffer'));

		mod_ctio.ruint8(value[0], endian, buffer, offset);
		return (1);
	}

	/*
	 * We're going to write 0s into the buffer if the string is shorter than the
	 * length of the array.
	 */
	function ctWriteCharArray(value, length, endian, buffer, offset)
	{
		var ii;

		if (!(value instanceof Buffer))
			throw (new Error('Input must be a buffer'));

		if (value.length > length)
			throw (new Error('value length greater than array length'));

		for (ii = 0; ii < value.length && ii < length; ii++)
			mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);

		for (; ii < length; ii++)
			mod_ctio.wuint8(0, endian, offset + ii);


		return (length);
	}

	/*
	 * Each parser has their own set of types. We want to make sure that they each
	 * get their own copy as they may need to modify it.
	 */
	function ctGetBasicTypes()
	{
		var ret = {};
		var key;
		for (key in deftypes)
			ret[key] = deftypes[key];

		return (ret);
	}

	/*
	 * Given a string in the form of type[length] we want to split this into an
	 * object that extracts that information. We want to note that we could possibly
	 * have nested arrays so this should only check the furthest one. It may also be
	 * the case that we have no [] pieces, in which case we just return the current
	 * type.
	 */
	function ctParseType(str)
	{
		var begInd, endInd;
		var type, len;
		if (typeof (str) != 'string')
			throw (new Error('type must be a Javascript string'));

		endInd = str.lastIndexOf(']');
		if (endInd == -1) {
			if (str.lastIndexOf('[') != -1)
				throw (new Error('found invalid type with \'[\' but ' +
				    'no corresponding \']\''));

			return ({ type: str });
		}

		begInd = str.lastIndexOf('[');
		if (begInd == -1)
			throw (new Error('found invalid type with \']\' but ' +
			    'no corresponding \'[\''));

		if (begInd >= endInd)
			throw (new Error('malformed type, \']\' appears before \'[\''));

		type = str.substring(0, begInd);
		len = str.substring(begInd + 1, endInd);

		return ({ type: type, len: len });
	}

	/*
	 * Given a request validate that all of the fields for it are valid and make
	 * sense. This includes verifying the following notions:
	 *  - Each type requested is present in types
	 *  - Only allow a name for a field to be specified once
	 *  - If an array is specified, validate that the requested field exists and
	 *    comes before it.
	 *  - If fields is defined, check that each entry has the occurrence of field
	 */
	function ctCheckReq(def, types, fields)
	{
		var ii, jj;
		var req, keys, key;
		var found = {};

		if (!(def instanceof Array))
			throw (new Error('definition is not an array'));

		if (def.length === 0)
			throw (new Error('definition must have at least one element'));

		for (ii = 0; ii < def.length; ii++) {
			req = def[ii];
			if (!(req instanceof Object))
				throw (new Error('definition must be an array of' +
				    'objects'));

			keys = Object.keys(req);
			if (keys.length != 1)
				throw (new Error('definition entry must only have ' +
				    'one key'));

			if (keys[0] in found)
				throw (new Error('Specified name already ' +
				    'specified: ' + keys[0]));

			if (!('type' in req[keys[0]]))
				throw (new Error('missing required type definition'));

			key = ctParseType(req[keys[0]]['type']);

			/*
			 * We may have nested arrays, we need to check the validity of
			 * the types until the len field is undefined in key. However,
			 * each time len is defined we need to verify it is either an
			 * integer or corresponds to an already seen key.
			 */
			while (key['len'] !== undefined) {
				if (isNaN(parseInt(key['len'], 10))) {
					if (!(key['len'] in found))
						throw (new Error('Given an array ' +
						    'length without a matching type'));

				}

				key = ctParseType(key['type']);
			}

			/* Now we can validate if the type is valid */
			if (!(key['type'] in types))
				throw (new Error('type not found or typdefed: ' +
				    key['type']));

			/* Check for any required fields */
			if (fields !== undefined) {
				for (jj = 0; jj < fields.length; jj++) {
					if (!(fields[jj] in req[keys[0]]))
						throw (new Error('Missing required ' +
						    'field: ' + fields[jj]));
				}
			}

			found[keys[0]] = true;
		}
	}


	/*
	 * Create a new instance of the parser. Each parser has its own store of
	 * typedefs and endianness. Conf is an object with the following required
	 * values:
	 *
	 *	endian		Either 'big' or 'little' do determine the endianness we
	 *			want to read from or write to.
	 *
	 * And the following optional values:
	 *
	 * 	char-type	Valid options here are uint8 and int8. If uint8 is
	 * 			specified this changes the default behavior of a single
	 * 			char from being a buffer of a single character to being
	 * 			a uint8_t. If int8, it becomes an int8_t instead.
	 */
	function CTypeParser(conf)
	{
		if (!conf) throw (new Error('missing required argument'));

		if (!('endian' in conf))
			throw (new Error('missing required endian value'));

		if (conf['endian'] != 'big' && conf['endian'] != 'little')
			throw (new Error('Invalid endian type'));

		if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
		    conf['char-type'] != 'int8'))
			throw (new Error('invalid option for char-type: ' +
			    conf['char-type']));

		this.endian = conf['endian'];
		this.types = ctGetBasicTypes();

		/*
		 * There may be a more graceful way to do this, but this will have to
		 * serve.
		 */
		if ('char-type' in conf && conf['char-type'] == 'uint8')
			this.types['char'] = this.types['uint8_t'];

		if ('char-type' in conf && conf['char-type'] == 'int8')
			this.types['char'] = this.types['int8_t'];
	}

	/*
	 * Sets the current endian value for the Parser. If the value is not valid,
	 * throws an Error.
	 *
	 *	endian		Either 'big' or 'little' do determine the endianness we
	 *			want to read from or write to.
	 *
	 */
	CTypeParser.prototype.setEndian = function (endian)
	{
		if (endian != 'big' && endian != 'little')
			throw (new Error('invalid endian type, must be big or ' +
			    'little'));

		this.endian = endian;
	};

	/*
	 * Returns the current value of the endian value for the parser.
	 */
	CTypeParser.prototype.getEndian = function ()
	{
		return (this.endian);
	};

	/*
	 * A user has requested to add a type, let us honor their request. Yet, if their
	 * request doth spurn us, send them unto the Hells which Dante describes.
	 *
	 * 	name		The string for the type definition we're adding
	 *
	 *	value		Either a string that is a type/array name or an object
	 *			that describes a struct.
	 */
	CTypeParser.prototype.typedef = function (name, value)
	{
		var type;

		if (name === undefined)
			throw (new (Error('missing required typedef argument: name')));

		if (value === undefined)
			throw (new (Error('missing required typedef argument: value')));

		if (typeof (name) != 'string')
			throw (new (Error('the name of a type must be a string')));

		type = ctParseType(name);

		if (type['len'] !== undefined)
			throw (new Error('Cannot have an array in the typedef name'));

		if (name in this.types)
			throw (new Error('typedef name already present: ' + name));

		if (typeof (value) != 'string' && !(value instanceof Array))
			throw (new Error('typedef value must either be a string or ' +
			    'struct'));

		if (typeof (value) == 'string') {
			type = ctParseType(value);
			if (type['len'] !== undefined) {
				if (isNaN(parseInt(type['len'], 10)))
					throw (new (Error('typedef value must use ' +
					    'fixed size array when outside of a ' +
					    'struct')));
			}

			this.types[name] = value;
		} else {
			/* We have a struct, validate it */
			ctCheckReq(value, this.types);
			this.types[name] = value;
		}
	};

	/*
	 * Include all of the typedefs, but none of the built in types. This should be
	 * treated as read-only.
	 */
	CTypeParser.prototype.lstypes = function ()
	{
		var key;
		var ret = {};

		for (key in this.types) {
			if (key in deftypes)
				continue;
			ret[key] = this.types[key];
		}

		return (ret);
	};

	/*
	 * Given a type string that may have array types that aren't numbers, try and
	 * fill them in from the values object. The object should be of the format where
	 * indexing into it should return a number for that type.
	 *
	 *	str		The type string
	 *
	 *	values		An object that can be used to fulfill type information
	 */
	function ctResolveArray(str, values)
	{
		var ret = '';
		var type = ctParseType(str);

		while (type['len'] !== undefined) {
			if (isNaN(parseInt(type['len'], 10))) {
				if (typeof (values[type['len']]) != 'number')
					throw (new Error('cannot sawp in non-number ' +
					    'for array value'));
				ret = '[' + values[type['len']] + ']' + ret;
			} else {
				ret = '[' + type['len'] + ']' + ret;
			}
			type = ctParseType(type['type']);
		}

		ret = type['type'] + ret;

		return (ret);
	}

	/*
	 * [private] Either the typedef resolves to another type string or to a struct.
	 * If it resolves to a struct, we just pass it off to read struct. If not, we
	 * can just pass it off to read entry.
	 */
	CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
	    offset, value)
	{
		var pt;

		mod_assert.ok(type in this.types);
		if (typeof (this.types[type]) == 'string') {
			pt = ctParseType(this.types[type]);
			if (dispatch == 'read')
				return (this.readEntry(pt, buffer, offset));
			else if (dispatch == 'write')
				return (this.writeEntry(value, pt, buffer, offset));
			else
				throw (new Error('invalid dispatch type to ' +
				    'resolveTypedef'));
		} else {
			if (dispatch == 'read')
				return (this.readStruct(this.types[type], buffer,
				    offset));
			else if (dispatch == 'write')
				return (this.writeStruct(value, this.types[type],
				    buffer, offset));
			else
				throw (new Error('invalid dispatch type to ' +
				    'resolveTypedef'));
		}

	};

	/*
	 * [private] Try and read in the specific entry.
	 */
	CTypeParser.prototype.readEntry = function (type, buffer, offset)
	{
		var parse, len;

		/*
		 * Because we want to special case char[]s this is unfortunately
		 * a bit uglier than it really should be. We want to special
		 * case char[]s so that we return a node buffer, thus they are a
		 * first class type where as all other arrays just call into a
		 * generic array routine which calls their data-specific routine
		 * the specified number of times.
		 *
		 * The valid dispatch options we have are:
		 *  - Array and char => char[] handler
		 *  - Generic array handler
		 *  - Generic typedef handler
		 *  - Basic type handler
		 */
		if (type['len'] !== undefined) {
			len = parseInt(type['len'], 10);
			if (isNaN(len))
				throw (new Error('somehow got a non-numeric length'));

			if (type['type'] == 'char')
				parse = this.types['char[]']['read'](len,
				    this.endian, buffer, offset);
			else
				parse = this.readArray(type['type'],
				    len, buffer, offset);
		} else {
			if (type['type'] in deftypes)
				parse = this.types[type['type']]['read'](this.endian,
				    buffer, offset);
			else
				parse = this.resolveTypedef(type['type'], 'read',
				    buffer, offset);
		}

		return (parse);
	};

	/*
	 * [private] Read an array of data
	 */
	CTypeParser.prototype.readArray = function (type, length, buffer, offset)
	{
		var ii, ent, pt;
		var baseOffset = offset;
		var ret = new Array(length);
		pt = ctParseType(type);

		for (ii = 0; ii < length; ii++) {
			ent = this.readEntry(pt, buffer, offset);
			offset += ent['size'];
			ret[ii] = ent['value'];
		}

		return ({ value: ret, size: offset - baseOffset });
	};

	/*
	 * [private] Read a single struct in.
	 */
	CTypeParser.prototype.readStruct = function (def, buffer, offset)
	{
		var parse, ii, type, entry, key;
		var baseOffset = offset;
		var ret = {};

		/* Walk it and handle doing what's necessary */
		for (ii = 0; ii < def.length; ii++) {
			key = Object.keys(def[ii])[0];
			entry = def[ii][key];

			/* Resolve all array values */
			type = ctParseType(ctResolveArray(entry['type'], ret));

			if ('offset' in entry)
				offset = baseOffset + entry['offset'];

			parse = this.readEntry(type, buffer, offset);

			offset += parse['size'];
			ret[key] = parse['value'];
		}

		return ({ value: ret, size: (offset-baseOffset)});
	};

	/*
	 * This is what we were born to do. We read the data from a buffer and return it
	 * in an object whose keys match the values from the object.
	 *
	 *	def		The array definition of the data to read in
	 *
	 *	buffer		The buffer to read data from
	 *
	 *	offset		The offset to start writing to
	 *
	 * Returns an object where each key corresponds to an entry in def and the value
	 * is the read value.
	 */
	CTypeParser.prototype.readData = function (def, buffer, offset)
	{
		/* Sanity check for arguments */
		if (def === undefined)
			throw (new Error('missing definition for what we should be' +
			    'parsing'));

		if (buffer === undefined)
			throw (new Error('missing buffer for what we should be ' +
			    'parsing'));

		if (offset === undefined)
			throw (new Error('missing offset for what we should be ' +
			    'parsing'));

		/* Sanity check the object definition */
		ctCheckReq(def, this.types);

		return (this.readStruct(def, buffer, offset)['value']);
	};

	/*
	 * [private] Write out an array of data
	 */
	CTypeParser.prototype.writeArray = function (value, type, length, buffer,
	    offset)
	{
		var ii, pt;
		var baseOffset = offset;
		if (!(value instanceof Array))
			throw (new Error('asked to write an array, but value is not ' +
			    'an array'));

		if (value.length != length)
			throw (new Error('asked to write array of length ' + length +
			    ' but that does not match value length: ' + value.length));

		pt = ctParseType(type);
		for (ii = 0; ii < length; ii++)
			offset += this.writeEntry(value[ii], pt, buffer, offset);

		return (offset - baseOffset);
	};

	/*
	 * [private] Write the specific entry
	 */
	CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
	{
		var len, ret;

		if (type['len'] !== undefined) {
			len = parseInt(type['len'], 10);
			if (isNaN(len))
				throw (new Error('somehow got a non-numeric length'));

			if (type['type'] == 'char')
				ret = this.types['char[]']['write'](value, len,
				    this.endian, buffer, offset);
			else
				ret = this.writeArray(value, type['type'],
				    len, buffer, offset);
		} else {
			if (type['type'] in deftypes)
				ret = this.types[type['type']]['write'](value,
				    this.endian, buffer, offset);
			else
				ret = this.resolveTypedef(type['type'], 'write',
				    buffer, offset, value);
		}

		return (ret);
	};

	/*
	 * [private] Write a single struct out.
	 */
	CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
	{
		var ii, entry, type, key;
		var baseOffset = offset;
		var vals = {};

		for (ii = 0; ii < def.length; ii++) {
			key = Object.keys(def[ii])[0];
			entry = def[ii][key];

			type = ctParseType(ctResolveArray(entry['type'], vals));

			if ('offset' in entry)
				offset = baseOffset + entry['offset'];

			offset += this.writeEntry(value[ii], type, buffer, offset);
			/* Now that we've written it out, we can use it for arrays */
			vals[key] = value[ii];
		}

		return (offset);
	};

	/*
	 * Unfortunately, we're stuck with the sins of an initial poor design. Because
	 * of that, we are going to have to support the old way of writing data via
	 * writeData. There we insert the values that you want to write into the
	 * definition. A little baroque. Internally, we use the new model. So we need to
	 * just get those values out of there. But to maintain the principle of least
	 * surprise, we're not going to modify the input data.
	 */
	function getValues(def)
	{
		var ii, out, key;
		out = [];
		for (ii = 0; ii < def.length; ii++) {
			key = Object.keys(def[ii])[0];
			mod_assert.ok('value' in def[ii][key]);
			out.push(def[ii][key]['value']);
		}

		return (out);
	}

	/*
	 * This is the second half of what we were born to do, write out the data
	 * itself. Historically this function required you to put your values in the
	 * definition section. This was not the smartest thing to do and a bit of an
	 * oversight to be honest. As such, this function now takes a values argument.
	 * If values is non-null and non-undefined, it will be used to determine the
	 * values. This means that the old method is still supported, but is no longer
	 * acceptable.
	 *
	 *	def		The array definition of the data to write out with
	 *			values
	 *
	 *	buffer		The buffer to write to
	 *
	 *	offset		The offset in the buffer to write to
	 *
	 *	values		An array of values to write.
	 */
	CTypeParser.prototype.writeData = function (def, buffer, offset, values)
	{
		var hv;

		if (def === undefined)
			throw (new Error('missing definition for what we should be' +
			    'parsing'));

		if (buffer === undefined)
			throw (new Error('missing buffer for what we should be ' +
			    'parsing'));

		if (offset === undefined)
			throw (new Error('missing offset for what we should be ' +
			    'parsing'));

		hv = (values != null && values != undefined);
		if (hv) {
			if (!Array.isArray(values))
				throw (new Error('missing values for writing'));
			ctCheckReq(def, this.types);
		} else {
			ctCheckReq(def, this.types, [ 'value' ]);
		}

		this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
	};

	/*
	 * Functions to go to and from 64 bit numbers in a way that is compatible with
	 * Javascript limitations. There are two sets. One where the user is okay with
	 * an approximation and one where they are definitely not okay with an
	 * approximation.
	 */

	/*
	 * Attempts to convert an array of two integers returned from rsint64 / ruint64
	 * into an absolute 64 bit number. If however the value would exceed 2^52 this
	 * will instead throw an error. The mantissa in a double is a 52 bit number and
	 * rather than potentially give you a value that is an approximation this will
	 * error. If you would rather an approximation, please see toApprox64.
	 *
	 *	val		An array of two 32-bit integers
	 */
	function toAbs64(val)
	{
		if (val === undefined)
			throw (new Error('missing required arg: value'));

		if (!Array.isArray(val))
			throw (new Error('value must be an array'));

		if (val.length != 2)
			throw (new Error('value must be an array of length 2'));

		/* We have 20 bits worth of precision in this range */
		if (val[0] >= 0x100000)
			throw (new Error('value would become approximated'));

		return (val[0] * Math.pow(2, 32) + val[1]);
	}

	/*
	 * Will return the 64 bit value as returned in an array from rsint64 / ruint64
	 * to a value as close as it can. Note that Javascript stores all numbers as a
	 * double and the mantissa only has 52 bits. Thus this version may approximate
	 * the value.
	 *
	 *	val		An array of two 32-bit integers
	 */
	function toApprox64(val)
	{
		if (val === undefined)
			throw (new Error('missing required arg: value'));

		if (!Array.isArray(val))
			throw (new Error('value must be an array'));

		if (val.length != 2)
			throw (new Error('value must be an array of length 2'));

		return (Math.pow(2, 32) * val[0] + val[1]);
	}

	function parseCTF(json, conf)
	{
		var ctype = new CTypeParser(conf);
		mod_ctf.ctfParseJson(json, ctype);

		return (ctype);
	}

	/*
	 * Export the few things we actually want to. Currently this is just the CType
	 * Parser and ctio.
	 */
	exports.Parser = CTypeParser;
	exports.toAbs64 = toAbs64;
	exports.toApprox64 = toApprox64;

	exports.parseCTF = parseCTF;

	exports.ruint8 = mod_ctio.ruint8;
	exports.ruint16 = mod_ctio.ruint16;
	exports.ruint32 = mod_ctio.ruint32;
	exports.ruint64 = mod_ctio.ruint64;
	exports.wuint8 = mod_ctio.wuint8;
	exports.wuint16 = mod_ctio.wuint16;
	exports.wuint32 = mod_ctio.wuint32;
	exports.wuint64 = mod_ctio.wuint64;

	exports.rsint8 = mod_ctio.rsint8;
	exports.rsint16 = mod_ctio.rsint16;
	exports.rsint32 = mod_ctio.rsint32;
	exports.rsint64 = mod_ctio.rsint64;
	exports.wsint8 = mod_ctio.wsint8;
	exports.wsint16 = mod_ctio.wsint16;
	exports.wsint32 = mod_ctio.wsint32;
	exports.wsint64 = mod_ctio.wsint64;

	exports.rfloat = mod_ctio.rfloat;
	exports.rdouble = mod_ctio.rdouble;
	exports.wfloat = mod_ctio.wfloat;
	exports.wdouble = mod_ctio.wdouble;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * ctf.js
	 *
	 * Understand and parse all of the different JSON formats of CTF data and
	 * translate that into a series of node-ctype friendly pieces. The reason for
	 * the abstraction is to handle different changes in the file format.
	 *
	 * We have to be careful here that we don't end up using a name that is already
	 * a built in type.
	 */
	var mod_assert = __webpack_require__(9);
	var ASSERT = mod_assert.ok;

	var ctf_versions = [ '1.0' ];
	var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
	var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
	    'uint32_t', 'float', 'double' ];

	function ctfParseInteger(entry, ctype)
	{
		var name, sign, len, type;

		name = entry['name'];
		if (!('signed' in entry['integer']))
			throw (new Error('Malformed CTF JSON: integer missing ' +
			    'signed value'));


		if (!('length' in entry['integer']))
			throw (new Error('Malformed CTF JSON: integer missing ' +
			    'length value'));

		sign = entry['integer']['signed'];
		len = entry['integer']['length'];
		type = null;

		if (sign && len == 1)
			type = 'int8_t';
		else if (len == 1)
			type = 'uint8_t';
		else if (sign && len == 2)
			type = 'int16_t';
		else if (len == 2)
			type = 'uint16_t';
		else if (sign && len == 4)
			type = 'int32_t';
		else if (len == 4)
			type = 'uint32_t';
		else if (sign && len == 8)
			type = 'int64_t';
		else if (len == 8)
			type = 'uint64_t';

		if (type === null)
			throw (new Error('Malformed CTF JSON: integer has ' +
			    'unsupported length and sign - ' + len + '/' + sign));

		/*
		 * This means that this is the same as one of our built in types. If
		 * that's the case defining it would be an error. So instead of trying
		 * to typedef it, we'll return here.
		 */
		if (name == type)
			return;

		if (name == 'char') {
			ASSERT(type == 'int8_t');
			return;
		}

		ctype.typedef(name, type);
	}

	function ctfParseFloat(entry, ctype)
	{
		var name, len;

		name = entry['name'];
		if (!('length' in entry['float']))
			throw (new Error('Malformed CTF JSON: float missing ' +
			    'length value'));

		len = entry['float']['length'];
		if (len != 4 && len != 8)
			throw (new Error('Malformed CTF JSON: float has invalid ' +
			    'length value'));

		if (len == 4) {
			if (name == 'float')
				return;
			ctype.typedef(name, 'float');
		} else if (len == 8) {
			if (name == 'double')
				return;
			ctype.typedef(name, 'double');
		}
	}

	function ctfParseTypedef(entry, ctype)
	{
		var name, type, ii;

		name = entry['name'];
		if (typeof (entry['typedef']) != 'string')
			throw (new Error('Malformed CTF JSON: typedef value in not ' +
			    'a string'));

		type = entry['typedef'];

		/*
		 * We need to ensure that we're not looking at type that's one of our
		 * built in types. Traditionally in C a uint32_t would be a typedef to
		 * some kind of integer. However, those size types are built ins.
		 */
		for (ii = 0; ii < ctf_deftypes.length; ii++) {
			if (name == ctf_deftypes[ii])
				return;
		}

		ctype.typedef(name, type);
	}

	function ctfParseStruct(entry, ctype)
	{
		var name, type, ii, val, index, member, push;

		member = [];
		if (!Array.isArray(entry['struct']))
			throw (new Error('Malformed CTF JSON: struct value is not ' +
			    'an array'));

		for (ii = 0; ii < entry['struct'].length; ii++) {
			val = entry['struct'][ii];
			if (!('name' in val))
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'missing name'));

			if (!('type' in val))
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'missing type'));

			if (typeof (val['name']) != 'string')
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'name isn\'t a string'));

			if (typeof (val['type']) != 'string')
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'type isn\'t a string'));

			/*
			 * CTF version 2 specifies array names as <type> [<num>] where
			 * as node-ctype does this as <type>[<num>].
			 */
			name = val['name'];
			type = val['type'];
			index = type.indexOf(' [');
			if (index != -1) {
				type = type.substring(0, index) +
				    type.substring(index + 1, type.length);
			}
			push = {};
			push[name] = { 'type': type };
			member.push(push);
		}

		name = entry['name'];
		ctype.typedef(name, member);
	}

	function ctfParseEntry(entry, ctype)
	{
		var ii, found;

		if (!('name' in entry))
			throw (new Error('Malformed CTF JSON: entry missing "name" ' +
			    'section'));

		for (ii = 0; ii < ctf_entries.length; ii++) {
			if (ctf_entries[ii] in entry)
				found++;
		}

		if (found === 0)
			throw (new Error('Malformed CTF JSON: found no entries'));

		if (found >= 2)
			throw (new Error('Malformed CTF JSON: found more than one ' +
			    'entry'));

		if ('integer' in entry) {
			ctfParseInteger(entry, ctype);
			return;
		}

		if ('float' in entry) {
			ctfParseFloat(entry, ctype);
			return;
		}

		if ('typedef' in entry) {
			ctfParseTypedef(entry, ctype);
			return;
		}

		if ('struct' in entry) {
			ctfParseStruct(entry, ctype);
			return;
		}

		ASSERT(false, 'shouldn\'t reach here');
	}

	function ctfParseJson(json, ctype)
	{
		var version, ii;

		ASSERT(json);
		ASSERT(ctype);
		if (!('metadata' in json))
			throw (new Error('Invalid CTF JSON: missing metadata section'));

		if (!('ctf2json_version' in json['metadata']))
			throw (new Error('Invalid CTF JSON: missing ctf2json_version'));

		version = json['metadata']['ctf2json_version'];
		for (ii = 0; ii < ctf_versions.length; ii++) {
			if (ctf_versions[ii] == version)
				break;
		}

		if (ii == ctf_versions.length)
			throw (new Error('Unsuported ctf2json_version: ' + version));

		if (!('data' in json))
			throw (new Error('Invalid CTF JSON: missing data section'));

		if (!Array.isArray(json['data']))
			throw (new Error('Malformed CTF JSON: data section is not ' +
			    'an array'));

		for (ii = 0; ii < json['data'].length; ii++)
			ctfParseEntry(json['data'][ii], ctype);
	}

	exports.ctfParseJson = ctfParseJson;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * rm - Feb 2011
	 * ctio.js:
	 *
	 * A simple way to read and write simple ctypes. Of course, as you'll find the
	 * code isn't as simple as it might appear. The following types are currently
	 * supported in big and little endian formats:
	 *
	 * 	uint8_t			int8_t
	 * 	uint16_t		int16_t
	 * 	uint32_t		int32_t
	 *	float (single precision IEEE 754)
	 *	double (double precision IEEE 754)
	 *
	 * This is designed to work in Node and v8. It may in fact work in other
	 * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
	 * If you find that it does in fact work, that's pretty cool. Try and pass word
	 * back to the original author.
	 *
	 * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
	 * weird.
	 */

	/*
	 * Numbers in Javascript have a secret: all numbers must be represented with an
	 * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
	 * implicit one. Thus the range of integers that can be represented is limited
	 * to the size of the mantissa, this makes reading and writing 64-bit integers
	 * difficult, but far from impossible.
	 *
	 * Another side effect of this representation is what happens when you use the
	 * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
	 * each operand and the result is cast to a signed 32-bit number. However, in
	 * the case of >>> the values are cast to an unsigned number.
	 */

	/*
	 * A reminder on endian related issues:
	 *
	 * Big Endian: MSB -> First byte
	 * Little Endian: MSB->Last byte
	 */
	var mod_assert = __webpack_require__(9);

	/*
	 * An 8 bit unsigned integer involves doing no significant work.
	 */
	function ruint8(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (buffer[offset]);
	}

	/*
	 * For 16 bit unsigned numbers we can do all the casting that we want to do.
	 */
	function rgint16(buffer, endian, offset)
	{
		var val = 0;

		if (endian == 'big') {
			val = buffer[offset] << 8;
			val |=  buffer[offset+1];
		} else {
			val = buffer[offset];
			val |= buffer[offset+1] << 8;
		}

		return (val);

	}

	function ruint16(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (rgint16(buffer, endian, offset));
	}

	/*
	 * Because most bitshifting is done using signed numbers, if we would go into
	 * the realm where we use that 32nd bit, we'll end up going into the negative
	 * range. i.e.:
	 * > 200 << 24
	 * -939524096
	 *
	 * Not the value you'd expect. To work around this, we end up having to do some
	 * abuse of the JavaScript standard. in this case, we know that a >>> shift is
	 * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
	 * use that instead to save us some additional math, though it does feel a
	 * little weird and it isn't obvious as to why you woul dwant to do this at
	 * first.
	 */
	function rgint32(buffer, endian, offset)
	{
		var val = 0;

		if (endian == 'big') {
			val = buffer[offset+1] << 16;
			val |= buffer[offset+2] << 8;
			val |= buffer[offset+3];
			val = val + (buffer[offset] << 24 >>> 0);
		} else {
			val = buffer[offset+2] << 16;
			val |= buffer[offset+1] << 8;
			val |= buffer[offset];
			val = val + (buffer[offset + 3] << 24 >>> 0);
		}

		return (val);
	}

	function ruint32(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (rgint32(buffer, endian, offset));
	}

	/*
	 * Reads a 64-bit unsigned number. The astue observer will note that this
	 * doesn't quite work. Javascript has chosen to only have numbers that can be
	 * represented by a double. A double only has 52 bits of mantissa with an
	 * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
	 * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
	 * could you have possibly wanted to represent that was larger than that? Oh,
	 * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
	 * that happen?
	 *
	 * To get around this egregious language issue, we're going to instead construct
	 * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
	 * give the actual number. However, note that the above code probably won't
	 * produce the desired results because of the way Javascript numbers are
	 * doubles.
	 */
	function rgint64(buffer, endian, offset)
	{
		var val = new Array(2);

		if (endian == 'big') {
			val[0] = ruint32(buffer, endian, offset);
			val[1] = ruint32(buffer, endian, offset+4);
		} else {
			val[0] = ruint32(buffer, endian, offset+4);
			val[1] = ruint32(buffer, endian, offset);
		}

		return (val);
	}

	function ruint64(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (rgint64(buffer, endian, offset));
	}


	/*
	 * Signed integer types, yay team! A reminder on how two's complement actually
	 * works. The first bit is the signed bit, i.e. tells us whether or not the
	 * number should be positive or negative. If the two's complement value is
	 * positive, then we're done, as it's equivalent to the unsigned representation.
	 *
	 * Now if the number is positive, you're pretty much done, you can just leverage
	 * the unsigned translations and return those. Unfortunately, negative numbers
	 * aren't quite that straightforward.
	 *
	 * At first glance, one might be inclined to use the traditional formula to
	 * translate binary numbers between the positive and negative values in two's
	 * complement. (Though it doesn't quite work for the most negative value)
	 * Mainly:
	 *  - invert all the bits
	 *  - add one to the result
	 *
	 * Of course, this doesn't quite work in Javascript. Take for example the value
	 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
	 * course, Javascript will do the following:
	 *
	 * > ~0xff80
	 * -65409
	 *
	 * Whoh there, Javascript, that's not quite right. But wait, according to
	 * Javascript that's perfectly correct. When Javascript ends up seeing the
	 * constant 0xff80, it has no notion that it is actually a signed number. It
	 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
	 * binary negation, it casts it into a signed value, (positive 0xff80). Then
	 * when you perform binary negation on that, it turns it into a negative number.
	 *
	 * Instead, we're going to have to use the following general formula, that works
	 * in a rather Javascript friendly way. I'm glad we don't support this kind of
	 * weird numbering scheme in the kernel.
	 *
	 * (BIT-MAX - (unsigned)val + 1) * -1
	 *
	 * The astute observer, may think that this doesn't make sense for 8-bit numbers
	 * (really it isn't necessary for them). However, when you get 16-bit numbers,
	 * you do. Let's go back to our prior example and see how this will look:
	 *
	 * (0xffff - 0xff80 + 1) * -1
	 * (0x007f + 1) * -1
	 * (0x0080) * -1
	 *
	 * Doing it this way ends up allowing us to treat it appropriately in
	 * Javascript. Sigh, that's really quite ugly for what should just be a few bit
	 * shifts, ~ and &.
	 */

	/*
	 * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
	 * this case because the more traditional methods work, but for consistency,
	 * we'll keep doing this the same way.
	 */
	function rsint8(buffer, endian, offset)
	{
		var neg;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		neg = buffer[offset] & 0x80;
		if (!neg)
			return (buffer[offset]);

		return ((0xff - buffer[offset] + 1) * -1);
	}

	/*
	 * The 16-bit version requires a bit more effort. In this case, we can leverage
	 * our unsigned code to generate the value we want to return.
	 */
	function rsint16(buffer, endian, offset)
	{
		var neg, val;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = rgint16(buffer, endian, offset);
		neg = val & 0x8000;
		if (!neg)
			return (val);

		return ((0xffff - val + 1) * -1);
	}

	/*
	 * We really shouldn't leverage our 32-bit code here and instead utilize the
	 * fact that we know that since these are signed numbers, we can do all the
	 * shifting and binary anding to generate the 32-bit number. But, for
	 * consistency we'll do the same. If we want to do otherwise, we should instead
	 * make the 32 bit unsigned code do the optimization. But as long as there
	 * aren't floats secretly under the hood for that, we /should/ be okay.
	 */
	function rsint32(buffer, endian, offset)
	{
		var neg, val;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = rgint32(buffer, endian, offset);
		neg = val & 0x80000000;
		if (!neg)
			return (val);

		return ((0xffffffff - val + 1) * -1);
	}

	/*
	 * The signed version of this code suffers from all of the same problems of the
	 * other 64 bit version.
	 */
	function rsint64(buffer, endian, offset)
	{
		var neg, val;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = rgint64(buffer, endian, offset);
		neg = val[0] & 0x80000000;

		if (!neg)
			return (val);

		val[0] = (0xffffffff - val[0]) * -1;
		val[1] = (0xffffffff - val[1] + 1) * -1;

		/*
		 * If we had the key 0x8000000000000000, that would leave the lower 32
		 * bits as 0xffffffff, however, since we're goint to add one, that would
		 * actually leave the lower 32-bits as 0x100000000, which would break
		 * our ability to write back a value that we received. To work around
		 * this, if we actually get that value, we're going to bump the upper
		 * portion by 1 and set this to zero.
		 */
		mod_assert.ok(val[1] <= 0x100000000);
		if (val[1] == -0x100000000) {
			val[1] = 0;
			val[0]--;
		}

		return (val);
	}

	/*
	 * We now move onto IEEE 754: The traditional form for floating point numbers
	 * and what is secretly hiding at the heart of everything in this. I really hope
	 * that someone is actually using this, as otherwise, this effort is probably
	 * going to be more wasted.
	 *
	 * One might be tempted to use parseFloat here, but that wouldn't work at all
	 * for several reasons. Mostly due to the way floats actually work, and
	 * parseFloat only actually works in base 10. I don't see base 10 anywhere near
	 * this file.
	 *
	 * In this case we'll implement the single and double precision versions. The
	 * quadruple precision, while probably useful, wouldn't really be accepted by
	 * Javascript, so let's not even waste our time.
	 *
	 * So let's review how this format looks like. A single precision value is 32
	 * bits and has three parts:
	 *   -  Sign bit
	 *   -  Exponent (Using bias notation)
	 *   -  Mantissa
	 *
	 * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
	 * 31| 30-23  |  22    	-       0       |
	 *
	 * The exponent is stored in a biased input. The bias in this case 127.
	 * Therefore, our exponent is equal to the 8-bit value - 127.
	 *
	 * By default, a number is normalized in IEEE, that means that the mantissa has
	 * an implicit one that we don't see. So really the value stored is 1.m.
	 * However, if the exponent is all zeros, then instead we have to shift
	 * everything to the right one and there is no more implicit one.
	 *
	 * Special values:
	 *  - Positive Infinity:
	 *	Sign:		0
	 *	Exponent: 	All 1s
	 *	Mantissa:	0
	 *  - Negative Infinity:
	 *	Sign:		1
	 *	Exponent: 	All 1s
	 *	Mantissa:	0
	 *  - NaN:
	 *	Sign:		*
	 *	Exponent: 	All 1s
	 *	Mantissa:	non-zero
	 *  - Zero:
	 *	Sign:		*
	 *	Exponent:	All 0s
	 *	Mantissa:	0
	 *
	 * In the case of zero, the sign bit determines whether we get a positive or
	 * negative zero. However, since Javascript cannot determine the difference
	 * between the two: i.e. -0 == 0, we just always return 0.
	 *
	 */
	function rfloat(buffer, endian, offset)
	{
		var bytes = [];
		var sign, exponent, mantissa, val;
		var bias = 127;
		var maxexp = 0xff;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		/* Normalize the bytes to be in endian order */
		if (endian == 'big') {
			bytes[0] = buffer[offset];
			bytes[1] = buffer[offset+1];
			bytes[2] = buffer[offset+2];
			bytes[3] = buffer[offset+3];
		} else {
			bytes[3] = buffer[offset];
			bytes[2] = buffer[offset+1];
			bytes[1] = buffer[offset+2];
			bytes[0] = buffer[offset+3];
		}

		sign = bytes[0] & 0x80;
		exponent = (bytes[0] & 0x7f) << 1;
		exponent |= (bytes[1] & 0x80) >>> 7;
		mantissa = (bytes[1] & 0x7f) << 16;
		mantissa |= bytes[2] << 8;
		mantissa |= bytes[3];

		/* Check for special cases before we do general parsing */
		if (!sign && exponent == maxexp && mantissa === 0)
			return (Number.POSITIVE_INFINITY);

		if (sign && exponent == maxexp && mantissa === 0)
			return (Number.NEGATIVE_INFINITY);

		if (exponent == maxexp && mantissa !== 0)
			return (Number.NaN);

		/*
		 * Javascript really doesn't have support for positive or negative zero.
		 * So we're not going to try and give it to you. That would be just
		 * plain weird. Besides -0 == 0.
		 */
		if (exponent === 0 && mantissa === 0)
			return (0);

		/*
		 * Now we can deal with the bias and the determine whether the mantissa
		 * has the implicit one or not.
		 */
		exponent -= bias;
		if (exponent == -bias) {
			exponent++;
			val = 0;
		} else {
			val = 1;
		}

		val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);

		if (sign)
			val *= -1;

		return (val);
	}

	/*
	 * Doubles in IEEE 754 are like their brothers except for a few changes and
	 * increases in size:
	 *   - The exponent is now 11 bits
	 *   - The mantissa is now 52 bits
	 *   - The bias is now 1023
	 *
	 * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
	 * 63| 62 - 52   | 	51		-			0     |
	 * 63| 62 - 52   |      51              -                       0     |
	 *
	 * While the size has increased a fair amount, we're going to end up keeping the
	 * same general formula for calculating the final value. As a reminder, this
	 * formula is:
	 *
	 * (-1)^s * (n + m) * 2^(e-b)
	 *
	 * Where:
	 *	s	is the sign bit
	 *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
	 *					     or not
	 *	m	is the mantissa
	 *	e	is the exponent specified
	 *	b	is the bias for the exponent
	 *
	 */
	function rdouble(buffer, endian, offset)
	{
		var bytes = [];
		var sign, exponent, mantissa, val, lowmant;
		var bias = 1023;
		var maxexp = 0x7ff;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		/* Normalize the bytes to be in endian order */
		if (endian == 'big') {
			bytes[0] = buffer[offset];
			bytes[1] = buffer[offset+1];
			bytes[2] = buffer[offset+2];
			bytes[3] = buffer[offset+3];
			bytes[4] = buffer[offset+4];
			bytes[5] = buffer[offset+5];
			bytes[6] = buffer[offset+6];
			bytes[7] = buffer[offset+7];
		} else {
			bytes[7] = buffer[offset];
			bytes[6] = buffer[offset+1];
			bytes[5] = buffer[offset+2];
			bytes[4] = buffer[offset+3];
			bytes[3] = buffer[offset+4];
			bytes[2] = buffer[offset+5];
			bytes[1] = buffer[offset+6];
			bytes[0] = buffer[offset+7];
		}

		/*
		 * We can construct the exponent and mantissa the same way as we did in
		 * the case of a float, just increase the range of the exponent.
		 */
		sign = bytes[0] & 0x80;
		exponent = (bytes[0] & 0x7f) << 4;
		exponent |= (bytes[1] & 0xf0) >>> 4;

		/*
		 * This is going to be ugly but then again, we're dealing with IEEE 754.
		 * This could probably be done as a node add on in a few lines of C++,
		 * but oh we'll, we've made it this far so let's be native the rest of
		 * the way...
		 *
		 * What we're going to do is break the mantissa into two parts, the
		 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
		 * by the appropriate power and then add in the lower 24-bits. Not
		 * really that great. It's pretty much a giant kludge to deal with
		 * Javascript eccentricities around numbers.
		 */
		lowmant = bytes[7];
		lowmant |= bytes[6] << 8;
		lowmant |= bytes[5] << 16;
		mantissa = bytes[4];
		mantissa |= bytes[3] << 8;
		mantissa |= bytes[2] << 16;
		mantissa |= (bytes[1] & 0x0f) << 24;
		mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
		mantissa += lowmant;

		/* Check for special cases before we do general parsing */
		if (!sign && exponent == maxexp && mantissa === 0)
			return (Number.POSITIVE_INFINITY);

		if (sign && exponent == maxexp && mantissa === 0)
			return (Number.NEGATIVE_INFINITY);

		if (exponent == maxexp && mantissa !== 0)
			return (Number.NaN);

		/*
		 * Javascript really doesn't have support for positive or negative zero.
		 * So we're not going to try and give it to you. That would be just
		 * plain weird. Besides -0 == 0.
		 */
		if (exponent === 0 && mantissa === 0)
			return (0);

		/*
		 * Now we can deal with the bias and the determine whether the mantissa
		 * has the implicit one or not.
		 */
		exponent -= bias;
		if (exponent == -bias) {
			exponent++;
			val = 0;
		} else {
			val = 1;
		}

		val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);

		if (sign)
			val *= -1;

		return (val);
	}

	/*
	 * Now that we have gone through the pain of reading the individual types, we're
	 * probably going to want some way to write these back. None of this is going to
	 * be good. But since we have Javascript numbers this should certainly be more
	 * interesting. Though we can constrain this end a little bit more in what is
	 * valid. For now, let's go back to our friends the unsigned value.
	 */

	/*
	 * Unsigned numbers seem deceptively easy. Here are the general steps and rules
	 * that we are going to take:
	 *   -  If the number is negative, throw an Error
	 *   -  Truncate any floating point portion
	 *   -  Take the modulus of the number in our base
	 *   -  Write it out to the buffer in the endian format requested at the offset
	 */

	/*
	 * We have to make sure that the value is a valid integer. This means that it is
	 * non-negative. It has no fractional component and that it does not exceed the
	 * maximum allowed value.
	 *
	 *	value		The number to check for validity
	 *
	 *	max		The maximum value
	 */
	function prepuint(value, max)
	{
		if (typeof (value) != 'number')
			throw (new (Error('cannot write a non-number as a number')));

		if (value < 0)
			throw (new Error('specified a negative value for writing an ' +
			    'unsigned value'));

		if (value > max)
			throw (new Error('value is larger than maximum value for ' +
			    'type'));

		if (Math.floor(value) !== value)
			throw (new Error('value has a fractional component'));

		return (value);
	}

	/*
	 * 8-bit version, classy. We can ignore endianness which is good.
	 */
	function wuint8(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepuint(value, 0xff);
		buffer[offset] = val;
	}

	/*
	 * Pretty much the same as the 8-bit version, just this time we need to worry
	 * about endian related issues.
	 */
	function wgint16(val, endian, buffer, offset)
	{
		if (endian == 'big') {
			buffer[offset] = (val & 0xff00) >>> 8;
			buffer[offset+1] = val & 0x00ff;
		} else {
			buffer[offset+1] = (val & 0xff00) >>> 8;
			buffer[offset] = val & 0x00ff;
		}
	}

	function wuint16(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepuint(value, 0xffff);
		wgint16(val, endian, buffer, offset);
	}

	/*
	 * The 32-bit version is going to have to be a little different unfortunately.
	 * We can't quite bitshift to get the largest byte, because that would end up
	 * getting us caught by the signed values.
	 *
	 * And yes, we do want to subtract out the lower part by default. This means
	 * that when we do the division, it will be treated as a bit shift and we won't
	 * end up generating a floating point value. If we did generate a floating point
	 * value we'd have to truncate it intelligently, this saves us that problem and
	 * may even be somewhat faster under the hood.
	 */
	function wgint32(val, endian, buffer, offset)
	{
		if (endian == 'big') {
			buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
			buffer[offset+1] = (val >>> 16) & 0xff;
			buffer[offset+2] = (val >>> 8) & 0xff;
			buffer[offset+3] = val & 0xff;
		} else {
			buffer[offset+3] = (val - (val & 0x00ffffff)) /
			    Math.pow(2, 24);
			buffer[offset+2] = (val >>> 16) & 0xff;
			buffer[offset+1] = (val >>> 8) & 0xff;
			buffer[offset] = val & 0xff;
		}
	}

	function wuint32(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepuint(value, 0xffffffff);
		wgint32(val, endian, buffer, offset);
	}

	/*
	 * Unlike the other versions, we expect the value to be in the form of two
	 * arrays where value[0] << 32 + value[1] would result in the value that we
	 * want.
	 */
	function wgint64(value, endian, buffer, offset)
	{
		if (endian == 'big') {
			wgint32(value[0], endian, buffer, offset);
			wgint32(value[1], endian, buffer, offset+4);
		} else {
			wgint32(value[0], endian, buffer, offset+4);
			wgint32(value[1], endian, buffer, offset);
		}
	}

	function wuint64(value, endian, buffer, offset)
	{
		if (value === undefined)
			throw (new Error('missing value'));

		if (!(value instanceof Array))
			throw (new Error('value must be an array'));

		if (value.length != 2)
			throw (new Error('value must be an array of length 2'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		prepuint(value[0], 0xffffffff);
		prepuint(value[1], 0xffffffff);
		wgint64(value, endian, buffer, offset);
	}

	/*
	 * We now move onto our friends in the signed number category. Unlike unsigned
	 * numbers, we're going to have to worry a bit more about how we put values into
	 * arrays. Since we are only worrying about signed 32-bit values, we're in
	 * slightly better shape. Unfortunately, we really can't do our favorite binary
	 * & in this system. It really seems to do the wrong thing. For example:
	 *
	 * > -32 & 0xff
	 * 224
	 *
	 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
	 * this aren't treated as a signed number. Ultimately a bad thing.
	 *
	 * What we're going to want to do is basically create the unsigned equivalent of
	 * our representation and pass that off to the wuint* functions. To do that
	 * we're going to do the following:
	 *
	 *  - if the value is positive
	 *	we can pass it directly off to the equivalent wuint
	 *  - if the value is negative
	 *	we do the following computation:
	 *	mb + val + 1, where
	 *	mb	is the maximum unsigned value in that byte size
	 *	val	is the Javascript negative integer
	 *
	 *
	 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
	 * you do out the computations:
	 *
	 * 0xffff - 128 + 1
	 * 0xffff - 127
	 * 0xff80
	 *
	 * You can then encode this value as the signed version. This is really rather
	 * hacky, but it should work and get the job done which is our goal here.
	 *
	 * Thus the overall flow is:
	 *   -  Truncate the floating point part of the number
	 *   -  We don't have to take the modulus, because the unsigned versions will
	 *   	take care of that for us. And we don't have to worry about that
	 *   	potentially causing bad things to happen because of sign extension
	 *   -  Pass it off to the appropriate unsigned version, potentially modifying
	 *	the negative portions as necessary.
	 */

	/*
	 * A series of checks to make sure we actually have a signed 32-bit number
	 */
	function prepsint(value, max, min)
	{
		if (typeof (value) != 'number')
			throw (new (Error('cannot write a non-number as a number')));

		if (value > max)
			throw (new Error('value larger than maximum allowed value'));

		if (value < min)
			throw (new Error('value smaller than minimum allowed value'));

		if (Math.floor(value) !== value)
			throw (new Error('value has a fractional component'));

		return (value);
	}

	/*
	 * The 8-bit version of the signed value. Overall, fairly straightforward.
	 */
	function wsint8(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepsint(value, 0x7f, -0x80);
		if (val >= 0)
			wuint8(val, endian, buffer, offset);
		else
			wuint8(0xff + val + 1, endian, buffer, offset);
	}

	/*
	 * The 16-bit version of the signed value. Also, fairly straightforward.
	 */
	function wsint16(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepsint(value, 0x7fff, -0x8000);
		if (val >= 0)
			wgint16(val, endian, buffer, offset);
		else
			wgint16(0xffff + val + 1, endian, buffer, offset);

	}

	/*
	 * We can do this relatively easily by leveraging the code used for 32-bit
	 * unsigned code.
	 */
	function wsint32(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepsint(value, 0x7fffffff, -0x80000000);
		if (val >= 0)
			wgint32(val, endian, buffer, offset);
		else
			wgint32(0xffffffff + val + 1, endian, buffer, offset);
	}

	/*
	 * The signed 64 bit integer should by in the same format as when received.
	 * Mainly it should ensure that the value is an array of two integers where
	 * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
	 * need to be equal.
	 */
	function wsint64(value, endian, buffer, offset)
	{
		var vzpos, vopos;
		var vals = new Array(2);

		if (value === undefined)
			throw (new Error('missing value'));

		if (!(value instanceof Array))
			throw (new Error('value must be an array'));

		if (value.length != 2)
			throw (new Error('value must be an array of length 2'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		/*
		 * We need to make sure that we have the same sign on both values. The
		 * hokiest way to to do this is to multiply the number by +inf. If we do
		 * this, we'll get either +/-inf depending on the sign of the value.
		 * Once we have this, we can compare it to +inf to see if the number is
		 * positive or not.
		 */
		vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
		    Number.POSITIVE_INFINITY;
		vopos = (value[1] * Number.POSITIVE_INFINITY) ==
		    Number.POSITIVE_INFINITY;

		/*
		 * If either of these is zero, then we don't actually need this check.
		 */
		if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
			throw (new Error('Both entries in the array must have ' +
			    'the same sign'));

		/*
		 * Doing verification for a signed 64-bit integer is actually a big
		 * trickier than it appears. We can't quite use our standard techniques
		 * because we need to compare both sets of values. The first value is
		 * pretty straightforward. If the first value is beond the extremes than
		 * we error out. However, the valid range of the second value varies
		 * based on the first one. If the first value is negative, and *not* the
		 * largest negative value, than it can be any integer within the range [
		 * 0, 0xffffffff ]. If it is the largest negative number, it must be
		 * zero.
		 *
		 * If the first number is positive, than it doesn't matter what the
		 * value is. We just simply have to make sure we have a valid positive
		 * integer.
		 */
		if (vzpos) {
			prepuint(value[0], 0x7fffffff);
			prepuint(value[1], 0xffffffff);
		} else {
			prepsint(value[0], 0, -0x80000000);
			prepsint(value[1], 0, -0xffffffff);
			if (value[0] == -0x80000000 && value[1] != 0)
				throw (new Error('value smaller than minimum ' +
				    'allowed value'));
		}

		/* Fix negative numbers */
		if (value[0] < 0 || value[1] < 0) {
			vals[0] = 0xffffffff - Math.abs(value[0]);
			vals[1] = 0x100000000 - Math.abs(value[1]);
			if (vals[1] == 0x100000000) {
				vals[1] = 0;
				vals[0]++;
			}
		} else {
			vals[0] = value[0];
			vals[1] = value[1];
		}
		wgint64(vals, endian, buffer, offset);
	}

	/*
	 * Now we are moving onto the weirder of these, the float and double. For this
	 * we're going to just have to do something that's pretty weird. First off, we
	 * have no way to get at the underlying float representation, at least not
	 * easily. But that doesn't mean we can't figure it out, we just have to use our
	 * heads.
	 *
	 * One might propose to use Number.toString(2). Of course, this is not really
	 * that good, because the ECMAScript 262 v3 Standard says the following Section
	 * 15.7.4.2-Number.prototype.toString (radix):
	 *
	 * If radix is an integer from 2 to 36, but not 10, the result is a string, the
	 * choice of which is implementation-dependent.
	 *
	 * Well that doesn't really help us one bit now does it? We could use the
	 * standard base 10 version of the string, but that's just going to create more
	 * errors as we end up trying to convert it back to a binary value. So, really
	 * this just means we have to be non-lazy and parse the structure intelligently.
	 *
	 * First off, we can do the basic checks: NaN, positive and negative infinity.
	 *
	 * Now that those are done we can work backwards to generate the mantissa and
	 * exponent.
	 *
	 * The first thing we need to do is determine the sign bit, easy to do, check
	 * whether the value is less than 0. And convert the number to its absolute
	 * value representation. Next, we need to determine if the value is less than
	 * one or greater than or equal to one and from there determine what power was
	 * used to get there. What follows is now specific to floats, though the general
	 * ideas behind this will hold for doubles as well, but the exact numbers
	 * involved will change.
	 *
	 * Once we have that power we can determine the exponent and the mantissa. Call
	 * the value that has the number of bits to reach the power ebits. In the
	 * general case they have the following values:
	 *
	 *	exponent	127 + ebits
	 *	mantissa	value * 2^(23 - ebits) & 0x7fffff
	 *
	 * In the case where the value of ebits is <= -127 we are now in the case where
	 * we no longer have normalized numbers. In this case the values take on the
	 * following values:
	 *
	 * 	exponent	0
	 *	mantissa	value * 2^149 & 0x7fffff
	 *
	 * Once we have the values for the sign, mantissa, and exponent. We reconstruct
	 * the four bytes as follows:
	 *
	 *	byte0		sign bit and seven most significant bits from the exp
	 *			sign << 7 | (exponent & 0xfe) >>> 1
	 *
	 *	byte1		lsb from the exponent and 7 top bits from the mantissa
	 *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
	 *
	 *	byte2		bits 8-15 (zero indexing) from mantissa
	 *			mantissa & 0xff00 >> 8
	 *
	 *	byte3		bits 0-7 from mantissa
	 *			mantissa & 0xff
	 *
	 * Once we have this we have to assign them into the buffer in proper endian
	 * order.
	 */

	/*
	 * Compute the log base 2 of the value. Now, someone who remembers basic
	 * properties of logarithms will point out that we could use the change of base
	 * formula for logs, and in fact that would be astute, because that's what we'll
	 * do for now. It feels cleaner, albeit it may be less efficient than just
	 * iterating and dividing by 2. We may want to come back and revisit that some
	 * day.
	 */
	function log2(value)
	{
		return (Math.log(value) / Math.log(2));
	}

	/*
	 * Helper to determine the exponent of the number we're looking at.
	 */
	function intexp(value)
	{
		return (Math.floor(log2(value)));
	}

	/*
	 * Helper to determine the exponent of the fractional part of the value.
	 */
	function fracexp(value)
	{
		return (Math.floor(log2(value)));
	}

	function wfloat(value, endian, buffer, offset)
	{
		var sign, exponent, mantissa, ebits;
		var bytes = [];

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));


		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		if (isNaN(value)) {
			sign = 0;
			exponent = 0xff;
			mantissa = 23;
		} else if (value == Number.POSITIVE_INFINITY) {
			sign = 0;
			exponent = 0xff;
			mantissa = 0;
		} else if (value == Number.NEGATIVE_INFINITY) {
			sign = 1;
			exponent = 0xff;
			mantissa = 0;
		} else {
			/* Well we have some work to do */

			/* Thankfully the sign bit is trivial */
			if (value < 0) {
				sign = 1;
				value = Math.abs(value);
			} else {
				sign = 0;
			}

			/* Use the correct function to determine number of bits */
			if (value < 1)
				ebits = fracexp(value);
			else
				ebits = intexp(value);

			/* Time to deal with the issues surrounding normalization */
			if (ebits <= -127) {
				exponent = 0;
				mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
			} else {
				exponent = 127 + ebits;
				mantissa = value * Math.pow(2, 23 - ebits);
				mantissa &= 0x7fffff;
			}
		}

		bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
		bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
		bytes[2] = (mantissa & 0x00ff00) >>> 8;
		bytes[3] = mantissa & 0x0000ff;

		if (endian == 'big') {
			buffer[offset] = bytes[0];
			buffer[offset+1] = bytes[1];
			buffer[offset+2] = bytes[2];
			buffer[offset+3] = bytes[3];
		} else {
			buffer[offset] = bytes[3];
			buffer[offset+1] = bytes[2];
			buffer[offset+2] = bytes[1];
			buffer[offset+3] = bytes[0];
		}
	}

	/*
	 * Now we move onto doubles. Doubles are similar to floats in pretty much all
	 * ways except that the processing isn't quite as straightforward because we
	 * can't always use shifting, i.e. we have > 32 bit values.
	 *
	 * We're going to proceed in an identical fashion to floats and utilize the same
	 * helper functions. All that really is changing are the specific values that we
	 * use to do the calculations. Thus, to review we have to do the following.
	 *
	 * First get the sign bit and convert the value to its absolute value
	 * representation. Next, we determine the number of bits that we used to get to
	 * the value, branching whether the value is greater than or less than 1. Once
	 * we have that value which we will again call ebits, we have to do the
	 * following in the general case:
	 *
	 *	exponent	1023 + ebits
	 *	mantissa	[value * 2^(52 - ebits)] % 2^52
	 *
	 * In the case where the value of ebits <= -1023 we no longer use normalized
	 * numbers, thus like with floats we have to do slightly different processing:
	 *
	 *	exponent	0
	 *	mantissa	[value * 2^1074] % 2^52
	 *
	 * Once we have determined the sign, exponent and mantissa we can construct the
	 * bytes as follows:
	 *
	 *	byte0		sign bit and seven most significant bits form the exp
	 *			sign << 7 | (exponent & 0x7f0) >>> 4
	 *
	 *	byte1		Remaining 4 bits from the exponent and the four most
	 *			significant bits from the mantissa 48-51
	 *			(exponent & 0x00f) << 4 | mantissa >>> 48
	 *
	 *	byte2		Bits 40-47 from the mantissa
	 *			(mantissa >>> 40) & 0xff
	 *
	 *	byte3		Bits 32-39 from the mantissa
	 *			(mantissa >>> 32) & 0xff
	 *
	 *	byte4		Bits 24-31 from the mantissa
	 *			(mantissa >>> 24) & 0xff
	 *
	 *	byte5		Bits 16-23 from the Mantissa
	 *			(mantissa >>> 16) & 0xff
	 *
	 *	byte6		Bits 8-15 from the mantissa
	 *			(mantissa >>> 8) & 0xff
	 *
	 *	byte7		Bits 0-7 from the mantissa
	 *			mantissa & 0xff
	 *
	 * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
	 * we'll have extended too far and we'll lose those values when we try and do
	 * the shift. Instead we have to use an alternate approach. To try and stay out
	 * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
	 * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
	 * that's ugly, but it seems to avoid using floating point (just based on how v8
	 * seems to be optimizing for base 2 arithmetic).
	 */
	function wdouble(value, endian, buffer, offset)
	{
		var sign, exponent, mantissa, ebits;
		var bytes = [];

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));


		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		if (isNaN(value)) {
			sign = 0;
			exponent = 0x7ff;
			mantissa = 23;
		} else if (value == Number.POSITIVE_INFINITY) {
			sign = 0;
			exponent = 0x7ff;
			mantissa = 0;
		} else if (value == Number.NEGATIVE_INFINITY) {
			sign = 1;
			exponent = 0x7ff;
			mantissa = 0;
		} else {
			/* Well we have some work to do */

			/* Thankfully the sign bit is trivial */
			if (value < 0) {
				sign = 1;
				value = Math.abs(value);
			} else {
				sign = 0;
			}

			/* Use the correct function to determine number of bits */
			if (value < 1)
				ebits = fracexp(value);
			else
				ebits = intexp(value);

			/*
			 * This is a total hack to determine a denormalized value.
			 * Unfortunately, we sometimes do not get a proper value for
			 * ebits, i.e. we lose the values that would get rounded off.
			 *
			 *
			 * The astute observer may wonder why we would be
			 * multiplying by two Math.pows rather than just summing
			 * them. Well, that's to get around a small bug in the
			 * way v8 seems to implement the function. On occasion
			 * doing:
			 *
			 * foo * Math.pow(2, 1023 + 51)
			 *
			 * Causes us to overflow to infinity, where as doing:
			 *
			 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
			 *
			 * Does not cause us to overflow. Go figure.
			 *
			 */
			if (value <= 2.225073858507201e-308 || ebits <= -1023) {
				exponent = 0;
				mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
				mantissa %= Math.pow(2, 52);
			} else {
				/*
				 * We might have gotten fucked by our floating point
				 * logarithm magic. This is rather crappy, but that's
				 * our luck. If we just had a log base 2 or access to
				 * the stupid underlying representation this would have
				 * been much easier and we wouldn't have such stupid
				 * kludges or hacks.
				 */
				if (ebits > 1023)
					ebits = 1023;
				exponent = 1023 + ebits;
				mantissa = value * Math.pow(2, -ebits);
				mantissa *= Math.pow(2, 52);
				mantissa %= Math.pow(2, 52);
			}
		}

		/* Fill the bytes in backwards to deal with the size issues */
		bytes[7] = mantissa & 0xff;
		bytes[6] = (mantissa >>> 8) & 0xff;
		bytes[5] = (mantissa >>> 16) & 0xff;
		mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
		bytes[4] = mantissa & 0xff;
		bytes[3] = (mantissa >>> 8) & 0xff;
		bytes[2] = (mantissa >>> 16) & 0xff;
		bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
		bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;

		if (endian == 'big') {
			buffer[offset] = bytes[0];
			buffer[offset+1] = bytes[1];
			buffer[offset+2] = bytes[2];
			buffer[offset+3] = bytes[3];
			buffer[offset+4] = bytes[4];
			buffer[offset+5] = bytes[5];
			buffer[offset+6] = bytes[6];
			buffer[offset+7] = bytes[7];
		} else {
			buffer[offset+7] = bytes[0];
			buffer[offset+6] = bytes[1];
			buffer[offset+5] = bytes[2];
			buffer[offset+4] = bytes[3];
			buffer[offset+3] = bytes[4];
			buffer[offset+2] = bytes[5];
			buffer[offset+1] = bytes[6];
			buffer[offset] = bytes[7];
		}
	}

	/*
	 * Actually export our work above. One might argue that we shouldn't expose
	 * these interfaces and just force people to use the higher level abstractions
	 * around this work. However, unlike say other libraries we've come across, this
	 * interface has several properties: it makes sense, it's simple, and it's
	 * useful.
	 */
	exports.ruint8 = ruint8;
	exports.ruint16 = ruint16;
	exports.ruint32 = ruint32;
	exports.ruint64 = ruint64;
	exports.wuint8 = wuint8;
	exports.wuint16 = wuint16;
	exports.wuint32 = wuint32;
	exports.wuint64 = wuint64;

	exports.rsint8 = rsint8;
	exports.rsint16 = rsint16;
	exports.rsint32 = rsint32;
	exports.rsint64 = rsint64;
	exports.wsint8 = wsint8;
	exports.wsint16 = wsint16;
	exports.wsint32 = wsint32;
	exports.wsint64 = wsint64;

	exports.rfloat = rfloat;
	exports.rdouble = rdouble;
	exports.wfloat = wfloat;
	exports.wdouble = wdouble;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);

	var errors = __webpack_require__(105);

	var bodyReader = __webpack_require__(228);
	var jsonParser = __webpack_require__(229);
	var formParser = __webpack_require__(230);
	var multipartParser = __webpack_require__(236);
	var fieldedTextParser = __webpack_require__(247);


	///--- Globals

	var UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;


	///--- API

	/**
	 * parse the body of an incoming request.
	 * @public
	 * @function bodyParser
	 * @throws   {UnsupportedMediaTypeError}
	 * @param    {Object} options an option object
	 * @returns  {Array}
	 */
	function bodyParser(options) {
	    assert.optionalObject(options, 'options');
	    options = options || {};
	    options.bodyReader = true;

	    var read = bodyReader(options);
	    var parseForm = formParser(options);
	    var parseJson = jsonParser(options);
	    var parseMultipart = multipartParser(options);
	    var parseFieldedText = fieldedTextParser(options);

	    function parseBody(req, res, next) {
	        // Allow use of 'requestBodyOnGet' flag to allow for merging of
	        // the request body of a GET request into req.params
	        if (req.method === 'HEAD') {
	            next();
	            return;
	        }

	        if (req.method === 'GET') {
	            if (!options.requestBodyOnGet) {
	                next();
	                return;
	            }
	        }

	        if (req.contentLength() === 0 && !req.isChunked()) {
	            next();
	            return;
	        }

	        var parser;
	        var type = req.contentType().toLowerCase();

	        switch (type) {
	            case 'application/json':
	                parser = parseJson[0];
	                break;
	            case 'application/x-www-form-urlencoded':
	                parser = parseForm[0];
	                break;
	            case 'multipart/form-data':
	                parser = parseMultipart;
	                break;
	            case 'text/tsv':
	                parser = parseFieldedText;
	                break;
	            case 'text/tab-separated-values':
	                parser = parseFieldedText;
	                break;
	            case 'text/csv':
	                parser = parseFieldedText;
	                break;

	            default:
	                break;
	        }

	        if (parser) {
	            parser(req, res, next);
	        } else if (options && options.rejectUnknown) {
	            next(new UnsupportedMediaTypeError(type));
	        } else {
	            next();
	        }
	    }

	    return ([read, parseBody]);
	}

	module.exports = bodyParser;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var crypto = __webpack_require__(59);
	var zlib = __webpack_require__(116);

	var assert = __webpack_require__(4);

	var errors = __webpack_require__(105);


	///--- Globals

	var BadDigestError = errors.BadDigestError;
	var RequestEntityTooLargeError = errors.RequestEntityTooLargeError;
	var PayloadTooLargeError = errors.PayloadTooLargeError;

	var MD5_MSG = 'Content-MD5 \'%s\' didn\'t match \'%s\'';


	///--- Helpers

	function createBodyWriter(req) {
	    var buffers = [];

	    var contentType = req.contentType();
	    var isText = false;

	    if (!contentType ||
	        contentType === 'application/json' ||
	        contentType === 'application/x-www-form-urlencoded' ||
	        contentType === 'multipart/form-data' ||
	        contentType.substr(0, 5) === 'text/') {
	        isText = true;
	    }

	    req.body = new Buffer(0);
	    return {
	        write: function (chunk) {
	            buffers.push(chunk);
	        },
	        end: function () {
	            req.body = Buffer.concat(buffers);

	            if (isText) {
	                req.body = req.body.toString('utf8');
	            }
	        }
	    };
	}


	///--- API

	/**
	 * reads the body of the request.
	 * @public
	 * @function bodyReader
	 * @throws   {BadDigestError | PayloadTooLargeError}
	 * @param    {Object} options an options object
	 * @returns  {Function}
	 */
	function bodyReader(options) {
	    options = options || {};
	    assert.object(options, 'options');

	    var maxBodySize = options.maxBodySize || 0;

	    function readBody(req, res, next) {
	        if ((req.getContentLength() === 0 && !req.isChunked()) ||
	            req.contentType() === 'multipart/form-data' ||
	            req.contentType() === 'application/octet-stream') {
	            next();
	            return;
	        }
	        var bodyWriter = createBodyWriter(req);

	        var bytesReceived = 0;
	        var digest;
	        var gz;
	        var hash;
	        var md5;

	        if ((md5 = req.headers['content-md5'])) {
	            hash = crypto.createHash('md5');
	        }

	        function done() {
	            var errorMessage;
	            bodyWriter.end();

	            if (maxBodySize && bytesReceived > maxBodySize) {
	                var msg = 'Request body size exceeds ' +
	                    maxBodySize;

	                // Between Node 0.12 and 4 http status code messages changed
	                // RequestEntityTooLarge was changed to PayloadTooLarge
	                // this check is to maintain backwards compatibility
	                if (PayloadTooLargeError !== undefined) {
	                    errorMessage = new PayloadTooLargeError(msg);
	                } else {
	                    errorMessage = new RequestEntityTooLargeError(msg);
	                }

	                next(errorMessage);
	                return;
	            }

	            if (!req.body.length) {
	                next();
	                return;
	            }

	            if (hash && md5 !== (digest = hash.digest('base64'))) {
	                errorMessage = new BadDigestError(MD5_MSG, md5, digest);
	                next(errorMessage);
	                return;
	            }

	            next();
	        }

	        if (req.headers['content-encoding'] === 'gzip') {
	            gz = zlib.createGunzip();
	            gz.on('data', bodyWriter.write);
	            gz.once('end', done);
	            req.once('end', gz.end.bind(gz));
	        } else {
	            req.once('end', done);
	        }

	        req.on('data', function onRequestData(chunk) {
	            if (maxBodySize) {
	                bytesReceived += chunk.length;

	                if (bytesReceived > maxBodySize) {
	                    return;
	                }
	            }

	            if (hash) {
	                hash.update(chunk, 'binary');
	            }

	            if (gz) {
	                gz.write(chunk);
	            } else {
	                bodyWriter.write(chunk);
	            }
	        });

	        req.once('error', next);
	        req.resume();
	    }

	    return (readBody);
	}

	module.exports = bodyReader;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);

	var bodyReader = __webpack_require__(228);
	var errors = __webpack_require__(105);


	///--- API

	/**
	 * parses json body from the request.
	 * @public
	 * @function jsonBodyParser
	 * @param    {Object}               options an options object
	 * @throws   {InvalidContentError}          on bad input
	 * @returns  {Function}
	 */
	function jsonBodyParser(options) {
	    assert.optionalObject(options, 'options');
	    options = options || {};

	    var override = options.overrideParams;

	    function parseJson(req, res, next) {
	        if (req.getContentType() !== 'application/json' || !req.body) {
	            next();
	            return;
	        }

	        var params;

	        try {
	            params = JSON.parse(req.body, options.reviver);
	        } catch (e) {
	            next(new errors.InvalidContentError('Invalid JSON: ' +
	                e.message));
	            return;
	        }

	        if (options.mapParams !== false) {
	            if (Array.isArray(params)) {
	                req.params = params;
	            } else if (typeof (params) === 'object' && params !== null) {
	                Object.keys(params).forEach(function (k) {
	                    var p = req.params[k];

	                    if (p && !override) {
	                        return (false);
	                    }
	                    req.params[k] = params[k];
	                    return (true);
	                });
	            } else {
	                req.params = params || req.params;
	            }
	        } else {
	            req._body = req.body;
	        }

	        req.body = params;

	        next();
	    }

	    var chain = [];

	    if (!options.bodyReader) {
	        chain.push(bodyReader(options));
	    }
	    chain.push(parseJson);
	    return (chain);
	}

	module.exports = jsonBodyParser;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);
	var querystring = __webpack_require__(231);

	var bodyReader = __webpack_require__(228);
	var errors = __webpack_require__(105);


	///--- Globals

	var MIME_TYPE = 'application/x-www-form-urlencoded';


	///--- API

	/**
	 * Returns a plugin that will parse the HTTP request body IFF the
	 * contentType is application/x-www-form-urlencoded.
	 *
	 * If req.params already contains a given key, that key is skipped and an
	 * error is logged.
	 *
	 * @public
	 * @function urlEncodedBodyParser
	 * @param   {Object}    options an option sobject
	 * @returns {Function}
	 */
	function urlEncodedBodyParser(options) {
	    options = options || {};
	    assert.object(options, 'options');

	    var override = options.overrideParams;

	    function parseUrlEncodedBody(req, res, next) {
	        if (req.getContentType() !== MIME_TYPE || !req.body) {
	            next();
	            return;
	        }

	        try {
	            var params = querystring.parse(req.body);

	            if (options.mapParams !== false) {
	                var keys = Object.keys(params);
	                keys.forEach(function (k) {
	                    var p = req.params[k];

	                    if (p && !override) {
	                        return (false);
	                    }

	                    req.params[k] = params[k];
	                    return (true);
	                });
	            } else {
	                req._body = req.body;
	                req.body = params;
	            }
	        } catch (e) {
	            next(new errors.InvalidContentError(e.message));
	            return;
	        }

	        req.log.trace('req.params now: %j', req.params);
	        next();
	    }

	    var chain = [];

	    if (!options.bodyReader) {
	        chain.push(bodyReader(options));
	    }
	    chain.push(parseUrlEncodedBody);
	    return (chain);
	}

	module.exports = urlEncodedBodyParser;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var stringify = __webpack_require__(232);
	var parse = __webpack_require__(235);
	var formats = __webpack_require__(234);

	module.exports = {
	    formats: formats,
	    parse: parse,
	    stringify: stringify
	};


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(233);
	var formats = __webpack_require__(234);

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var toISO = Date.prototype.toISOString;

	var defaults = {
	    delimiter: '&',
	    encode: true,
	    encoder: utils.encode,
	    serializeDate: function serializeDate(date) {
	        return toISO.call(date);
	    },
	    skipNulls: false,
	    strictNullHandling: false
	};

	var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = serializeDate(obj);
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encoder ? encoder(prefix) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
	        if (encoder) {
	            return [formatter(encoder(prefix)) + '=' + formatter(encoder(obj))];
	        }
	        return [formatter(prefix) + '=' + formatter(String(obj))];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        if (Array.isArray(obj)) {
	            values = values.concat(stringify(
	                obj[key],
	                generateArrayPrefix(prefix, key),
	                generateArrayPrefix,
	                strictNullHandling,
	                skipNulls,
	                encoder,
	                filter,
	                sort,
	                allowDots,
	                serializeDate,
	                formatter
	            ));
	        } else {
	            values = values.concat(stringify(
	                obj[key],
	                prefix + (allowDots ? '.' + key : '[' + key + ']'),
	                generateArrayPrefix,
	                strictNullHandling,
	                skipNulls,
	                encoder,
	                filter,
	                sort,
	                allowDots,
	                serializeDate,
	                formatter
	            ));
	        }
	    }

	    return values;
	};

	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
	    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
	    if (typeof options.format === 'undefined') {
	        options.format = formats.default;
	    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
	        throw new TypeError('Unknown format option provided.');
	    }
	    var formatter = formats.formatters[options.format];
	    var objKeys;
	    var filter;

	    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        filter = options.filter;
	        objKeys = filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        keys = keys.concat(stringify(
	            obj[key],
	            key,
	            generateArrayPrefix,
	            strictNullHandling,
	            skipNulls,
	            encoder,
	            filter,
	            sort,
	            allowDots,
	            serializeDate,
	            formatter
	        ));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 233 */
/***/ function(module, exports) {

	'use strict';

	var has = Object.prototype.hasOwnProperty;

	var hexTable = (function () {
	    var array = [];
	    for (var i = 0; i < 256; ++i) {
	        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
	    }

	    return array;
	}());

	exports.arrayToObject = function (source, options) {
	    var obj = options && options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if (typeof target === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }

	    if (Array.isArray(target) && Array.isArray(source)) {
	        source.forEach(function (item, i) {
	            if (has.call(target, i)) {
	                if (target[i] && typeof target[i] === 'object') {
	                    target[i] = exports.merge(target[i], item, options);
	                } else {
	                    target.push(item);
	                }
	            } else {
	                target[i] = item;
	            }
	        });
	        return target;
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = typeof str === 'string' ? str : String(str);

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (
	            c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	exports.compact = function (obj, references) {
	    if (typeof obj !== 'object' || obj === null) {
	        return obj;
	    }

	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0; i < obj.length; ++i) {
	            if (obj[i] && typeof obj[i] === 'object') {
	                compacted.push(exports.compact(obj[i], refs));
	            } else if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    keys.forEach(function (key) {
	        obj[key] = exports.compact(obj[key], refs);
	    });

	    return obj;
	};

	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};


/***/ },
/* 234 */
/***/ function(module, exports) {

	'use strict';

	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;

	module.exports = {
	    'default': 'RFC3986',
	    formatters: {
	        RFC1738: function (value) {
	            return replace.call(value, percentTwenties, '+');
	        },
	        RFC3986: function (value) {
	            return value;
	        }
	    },
	    RFC1738: 'RFC1738',
	    RFC3986: 'RFC3986'
	};


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(233);

	var has = Object.prototype.hasOwnProperty;

	var defaults = {
	    allowDots: false,
	    allowPrototypes: false,
	    arrayLimit: 20,
	    decoder: utils.decode,
	    delimiter: '&',
	    depth: 5,
	    parameterLimit: 1000,
	    plainObjects: false,
	    strictNullHandling: false
	};

	var parseValues = function parseValues(str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part);
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos));
	            val = options.decoder(part.slice(pos + 1));
	        }
	        if (has.call(obj, key)) {
	            obj[key] = [].concat(obj[key]).concat(val);
	        } else {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function parseObject(chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (
	            !isNaN(index) &&
	            root !== cleanRoot &&
	            String(index) === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays && index <= options.arrayLimit)
	        ) {
	            obj = [];
	            obj[index] = parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};

	var parseKeys = function parseKeys(givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options);
	};

	module.exports = function (str, opts) {
	    var options = opts || {};

	    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options);
	        obj = utils.merge(obj, newObj, options);
	    }

	    return utils.compact(obj);
	};


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	var assert = __webpack_require__(4);
	var formidable = __webpack_require__(237);
	var once = __webpack_require__(52);
	var vasync = __webpack_require__(245);

	var errors = __webpack_require__(105);



	///--- API

	/**
	 * Returns a plugin that will parse the HTTP request body IFF the
	 * contentType is multipart/form-data
	 *
	 * If req.params already contains a given key, that key is skipped and an
	 * error is logged.
	 * @public
	 * @function multipartBodyParser
	 * @param    {Object}          options an options object
	 * @throws   {BadRequestError}
	 * @returns  {Function}
	 */
	function multipartBodyParser(options) {
	    if (!options) {
	        options = {};
	    }
	    assert.object(options, 'options');
	    assert.optionalBool(options.overrideParams, 'options.overrideParams');
	    assert.optionalBool(options.multiples, 'options.multiples');
	    assert.optionalBool(options.keepExtensions, 'options.keepExtensions');
	    assert.optionalString(options.uploadDir, 'options.uploadDir');
	    assert.optionalNumber(options.maxFieldsSize, 'options.maxFieldsSize');
	    assert.optionalString(options.hash, 'options.hash');
	    assert.optionalFunc(options.multipartFileHandler,
	                        'options.multipartFileHandler');
	    assert.optionalFunc(options.multipartHandler, 'options.multipartHandler');
	    assert.optionalBool(options.mapParams, 'options.mapParams');
	    assert.optionalBool(options.mapFiles, 'options.mapFiles');

	    var override = options.overrideParams;

	    function parseMultipartBody(req, res, next) {
	        next = once(next);

	        if (req.getContentType() !== 'multipart/form-data' ||
	            (req.getContentLength() === 0 && !req.isChunked())) {
	            return (next());
	        }

	        var form = new formidable.IncomingForm();

	        // enable multiple files on a single upload field
	        // (html5 multiple attribute)
	        form.multiples = options.multiples || false;
	        form.keepExtensions = options.keepExtensions ? true : false;

	        if (options.uploadDir) {
	            form.uploadDir = options.uploadDir;
	        }

	        if (options.maxFieldsSize) {
	            form.maxFieldsSize = options.maxFieldsSize;
	        }

	        if (options.hash) {
	            form.hash = options.hash;
	        }

	        form.onPart = function onPart(part) {
	            if (part.filename && options.multipartFileHandler) {
	                options.multipartFileHandler(part, req);
	            } else if (!part.filename && options.multipartHandler) {
	                options.multipartHandler(part, req);
	            } else {
	                form.handlePart(part);
	            }
	        };

	        form.parse(req, function (err, fields, files) {
	            if (err) {
	                return (next(new errors.BadRequestError(err.message)));
	            }

	            req.body = fields;
	            req.files = files;

	            if (options.mapParams !== false) {
	                Object.keys(fields).forEach(function (k) {
	                    if (req.params[k] && !override) {
	                        return;
	                    }

	                    req.params[k] = fields[k];
	                });

	                if (options.mapFiles) {
	                    var barrier = vasync.barrier();
	                    barrier.on('drain', function () {
	                        return next();
	                    });

	                    barrier.start('fs');
	                    Object.keys(files).forEach(function (f) {
	                        if (req.params[f] && !override) {
	                            return;
	                        }
	                        barrier.start('fs' + f);
	                        fs.readFile(files[f].path, function (ex, data) {
	                            barrier.done('fs' + f);
	                            /*
	                             * We want to stop the request here, if there's an
	                             * error trying to read the file from disk.
	                             * Ideally we'd like to stop the other oustanding
	                             * file reads too, but there's no way to cancel in
	                             * flight fs reads.  So we just return an error, and
	                             * be grudgingly let the other file reads finish.
	                             */
	                            if (ex) {
	                                return next(new errors.InternalError(ex,
	                                         'unable to read file' + f));
	                            }
	                            req.params[f] = data;
	                            return (true);
	                        });
	                    });
	                    barrier.done('fs');
	                } else {
	                    return next();
	                }
	            } else {
	                return next();
	            }

	        });

	        return (false);
	    }

	    return (parseMultipartBody);
	}

	module.exports = multipartBodyParser;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var IncomingForm = __webpack_require__(238).IncomingForm;
	IncomingForm.IncomingForm = IncomingForm;
	module.exports = IncomingForm;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(global, Buffer) {if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(239));

	var crypto = require('crypto');
	var fs = require('fs');
	var util = require('util'),
	    path = require('path'),
	    File = require('./file'),
	    MultipartParser = require('./multipart_parser').MultipartParser,
	    QuerystringParser = require('./querystring_parser').QuerystringParser,
	    OctetParser       = require('./octet_parser').OctetParser,
	    JSONParser = require('./json_parser').JSONParser,
	    StringDecoder = require('string_decoder').StringDecoder,
	    EventEmitter = require('events').EventEmitter,
	    Stream = require('stream').Stream,
	    os = require('os');

	function IncomingForm(opts) {
	  if (!(this instanceof IncomingForm)) return new IncomingForm(opts);
	  EventEmitter.call(this);

	  opts=opts||{};

	  this.error = null;
	  this.ended = false;

	  this.maxFields = opts.maxFields || 1000;
	  this.maxFieldsSize = opts.maxFieldsSize || 2 * 1024 * 1024;
	  this.keepExtensions = opts.keepExtensions || false;
	  this.uploadDir = opts.uploadDir || os.tmpDir();
	  this.encoding = opts.encoding || 'utf-8';
	  this.headers = null;
	  this.type = null;
	  this.hash = opts.hash || false;
	  this.multiples = opts.multiples || false;

	  this.bytesReceived = null;
	  this.bytesExpected = null;

	  this._parser = null;
	  this._flushing = 0;
	  this._fieldsSize = 0;
	  this.openedFiles = [];

	  return this;
	}
	util.inherits(IncomingForm, EventEmitter);
	exports.IncomingForm = IncomingForm;

	IncomingForm.prototype.parse = function(req, cb) {
	  this.pause = function() {
	    try {
	      req.pause();
	    } catch (err) {
	      // the stream was destroyed
	      if (!this.ended) {
	        // before it was completed, crash & burn
	        this._error(err);
	      }
	      return false;
	    }
	    return true;
	  };

	  this.resume = function() {
	    try {
	      req.resume();
	    } catch (err) {
	      // the stream was destroyed
	      if (!this.ended) {
	        // before it was completed, crash & burn
	        this._error(err);
	      }
	      return false;
	    }

	    return true;
	  };

	  // Setup callback first, so we don't miss anything from data events emitted
	  // immediately.
	  if (cb) {
	    var fields = {}, files = {};
	    this
	      .on('field', function(name, value) {
	        fields[name] = value;
	      })
	      .on('file', function(name, file) {
	        if (this.multiples) {
	          if (files[name]) {
	            if (!Array.isArray(files[name])) {
	              files[name] = [files[name]];
	            }
	            files[name].push(file);
	          } else {
	            files[name] = file;
	          }
	        } else {
	          files[name] = file;
	        }
	      })
	      .on('error', function(err) {
	        cb(err, fields, files);
	      })
	      .on('end', function() {
	        cb(null, fields, files);
	      });
	  }

	  // Parse headers and setup the parser, ready to start listening for data.
	  this.writeHeaders(req.headers);

	  // Start listening for data.
	  var self = this;
	  req
	    .on('error', function(err) {
	      self._error(err);
	    })
	    .on('aborted', function() {
	      self.emit('aborted');
	      self._error(new Error('Request aborted'));
	    })
	    .on('data', function(buffer) {
	      self.write(buffer);
	    })
	    .on('end', function() {
	      if (self.error) {
	        return;
	      }

	      var err = self._parser.end();
	      if (err) {
	        self._error(err);
	      }
	    });

	  return this;
	};

	IncomingForm.prototype.writeHeaders = function(headers) {
	  this.headers = headers;
	  this._parseContentLength();
	  this._parseContentType();
	};

	IncomingForm.prototype.write = function(buffer) {
	  if (this.error) {
	    return;
	  }
	  if (!this._parser) {
	    this._error(new Error('uninitialized parser'));
	    return;
	  }

	  this.bytesReceived += buffer.length;
	  this.emit('progress', this.bytesReceived, this.bytesExpected);

	  var bytesParsed = this._parser.write(buffer);
	  if (bytesParsed !== buffer.length) {
	    this._error(new Error('parser error, '+bytesParsed+' of '+buffer.length+' bytes parsed'));
	  }

	  return bytesParsed;
	};

	IncomingForm.prototype.pause = function() {
	  // this does nothing, unless overwritten in IncomingForm.parse
	  return false;
	};

	IncomingForm.prototype.resume = function() {
	  // this does nothing, unless overwritten in IncomingForm.parse
	  return false;
	};

	IncomingForm.prototype.onPart = function(part) {
	  // this method can be overwritten by the user
	  this.handlePart(part);
	};

	IncomingForm.prototype.handlePart = function(part) {
	  var self = this;

	  if (part.filename === undefined) {
	    var value = ''
	      , decoder = new StringDecoder(this.encoding);

	    part.on('data', function(buffer) {
	      self._fieldsSize += buffer.length;
	      if (self._fieldsSize > self.maxFieldsSize) {
	        self._error(new Error('maxFieldsSize exceeded, received '+self._fieldsSize+' bytes of field data'));
	        return;
	      }
	      value += decoder.write(buffer);
	    });

	    part.on('end', function() {
	      self.emit('field', part.name, value);
	    });
	    return;
	  }

	  this._flushing++;

	  var file = new File({
	    path: this._uploadPath(part.filename),
	    name: part.filename,
	    type: part.mime,
	    hash: self.hash
	  });

	  this.emit('fileBegin', part.name, file);

	  file.open();
	  this.openedFiles.push(file);

	  part.on('data', function(buffer) {
	    if (buffer.length == 0) {
	      return;
	    }
	    self.pause();
	    file.write(buffer, function() {
	      self.resume();
	    });
	  });

	  part.on('end', function() {
	    file.end(function() {
	      self._flushing--;
	      self.emit('file', part.name, file);
	      self._maybeEnd();
	    });
	  });
	};

	function dummyParser(self) {
	  return {
	    end: function () {
	      self.ended = true;
	      self._maybeEnd();
	      return null;
	    }
	  };
	}

	IncomingForm.prototype._parseContentType = function() {
	  if (this.bytesExpected === 0) {
	    this._parser = dummyParser(this);
	    return;
	  }

	  if (!this.headers['content-type']) {
	    this._error(new Error('bad content-type header, no content-type'));
	    return;
	  }

	  if (this.headers['content-type'].match(/octet-stream/i)) {
	    this._initOctetStream();
	    return;
	  }

	  if (this.headers['content-type'].match(/urlencoded/i)) {
	    this._initUrlencoded();
	    return;
	  }

	  if (this.headers['content-type'].match(/multipart/i)) {
	    var m = this.headers['content-type'].match(/boundary=(?:"([^"]+)"|([^;]+))/i);
	    if (m) {
	      this._initMultipart(m[1] || m[2]);
	    } else {
	      this._error(new Error('bad content-type header, no multipart boundary'));
	    }
	    return;
	  }

	  if (this.headers['content-type'].match(/json/i)) {
	    this._initJSONencoded();
	    return;
	  }

	  this._error(new Error('bad content-type header, unknown content-type: '+this.headers['content-type']));
	};

	IncomingForm.prototype._error = function(err) {
	  if (this.error || this.ended) {
	    return;
	  }

	  this.error = err;
	  this.emit('error', err);

	  if (Array.isArray(this.openedFiles)) {
	    this.openedFiles.forEach(function(file) {
	      file._writeStream.destroy();
	      setTimeout(fs.unlink, 0, file.path, function(error) { });
	    });
	  }
	};

	IncomingForm.prototype._parseContentLength = function() {
	  this.bytesReceived = 0;
	  if (this.headers['content-length']) {
	    this.bytesExpected = parseInt(this.headers['content-length'], 10);
	  } else if (this.headers['transfer-encoding'] === undefined) {
	    this.bytesExpected = 0;
	  }

	  if (this.bytesExpected !== null) {
	    this.emit('progress', this.bytesReceived, this.bytesExpected);
	  }
	};

	IncomingForm.prototype._newParser = function() {
	  return new MultipartParser();
	};

	IncomingForm.prototype._initMultipart = function(boundary) {
	  this.type = 'multipart';

	  var parser = new MultipartParser(),
	      self = this,
	      headerField,
	      headerValue,
	      part;

	  parser.initWithBoundary(boundary);

	  parser.onPartBegin = function() {
	    part = new Stream();
	    part.readable = true;
	    part.headers = {};
	    part.name = null;
	    part.filename = null;
	    part.mime = null;

	    part.transferEncoding = 'binary';
	    part.transferBuffer = '';

	    headerField = '';
	    headerValue = '';
	  };

	  parser.onHeaderField = function(b, start, end) {
	    headerField += b.toString(self.encoding, start, end);
	  };

	  parser.onHeaderValue = function(b, start, end) {
	    headerValue += b.toString(self.encoding, start, end);
	  };

	  parser.onHeaderEnd = function() {
	    headerField = headerField.toLowerCase();
	    part.headers[headerField] = headerValue;

	    var m = headerValue.match(/\bname="([^"]+)"/i);
	    if (headerField == 'content-disposition') {
	      if (m) {
	        part.name = m[1];
	      }

	      part.filename = self._fileName(headerValue);
	    } else if (headerField == 'content-type') {
	      part.mime = headerValue;
	    } else if (headerField == 'content-transfer-encoding') {
	      part.transferEncoding = headerValue.toLowerCase();
	    }

	    headerField = '';
	    headerValue = '';
	  };

	  parser.onHeadersEnd = function() {
	    switch(part.transferEncoding){
	      case 'binary':
	      case '7bit':
	      case '8bit':
	      parser.onPartData = function(b, start, end) {
	        part.emit('data', b.slice(start, end));
	      };

	      parser.onPartEnd = function() {
	        part.emit('end');
	      };
	      break;

	      case 'base64':
	      parser.onPartData = function(b, start, end) {
	        part.transferBuffer += b.slice(start, end).toString('ascii');

	        /*
	        four bytes (chars) in base64 converts to three bytes in binary
	        encoding. So we should always work with a number of bytes that
	        can be divided by 4, it will result in a number of buytes that
	        can be divided vy 3.
	        */
	        var offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
	        part.emit('data', new Buffer(part.transferBuffer.substring(0, offset), 'base64'));
	        part.transferBuffer = part.transferBuffer.substring(offset);
	      };

	      parser.onPartEnd = function() {
	        part.emit('data', new Buffer(part.transferBuffer, 'base64'));
	        part.emit('end');
	      };
	      break;

	      default:
	      return self._error(new Error('unknown transfer-encoding'));
	    }

	    self.onPart(part);
	  };


	  parser.onEnd = function() {
	    self.ended = true;
	    self._maybeEnd();
	  };

	  this._parser = parser;
	};

	IncomingForm.prototype._fileName = function(headerValue) {
	  var m = headerValue.match(/\bfilename="(.*?)"($|; )/i);
	  if (!m) return;

	  var filename = m[1].substr(m[1].lastIndexOf('\\') + 1);
	  filename = filename.replace(/%22/g, '"');
	  filename = filename.replace(/&#([\d]{4});/g, function(m, code) {
	    return String.fromCharCode(code);
	  });
	  return filename;
	};

	IncomingForm.prototype._initUrlencoded = function() {
	  this.type = 'urlencoded';

	  var parser = new QuerystringParser(this.maxFields)
	    , self = this;

	  parser.onField = function(key, val) {
	    self.emit('field', key, val);
	  };

	  parser.onEnd = function() {
	    self.ended = true;
	    self._maybeEnd();
	  };

	  this._parser = parser;
	};

	IncomingForm.prototype._initOctetStream = function() {
	  this.type = 'octet-stream';
	  var filename = this.headers['x-file-name'];
	  var mime = this.headers['content-type'];

	  var file = new File({
	    path: this._uploadPath(filename),
	    name: filename,
	    type: mime
	  });

	  this.emit('fileBegin', filename, file);
	  file.open();

	  this._flushing++;

	  var self = this;

	  self._parser = new OctetParser();

	  //Keep track of writes that haven't finished so we don't emit the file before it's done being written
	  var outstandingWrites = 0;

	  self._parser.on('data', function(buffer){
	    self.pause();
	    outstandingWrites++;

	    file.write(buffer, function() {
	      outstandingWrites--;
	      self.resume();

	      if(self.ended){
	        self._parser.emit('doneWritingFile');
	      }
	    });
	  });

	  self._parser.on('end', function(){
	    self._flushing--;
	    self.ended = true;

	    var done = function(){
	      file.end(function() {
	        self.emit('file', 'file', file);
	        self._maybeEnd();
	      });
	    };

	    if(outstandingWrites === 0){
	      done();
	    } else {
	      self._parser.once('doneWritingFile', done);
	    }
	  });
	};

	IncomingForm.prototype._initJSONencoded = function() {
	  this.type = 'json';

	  var parser = new JSONParser()
	    , self = this;

	  if (this.bytesExpected) {
	    parser.initWithLength(this.bytesExpected);
	  }

	  parser.onField = function(key, val) {
	    self.emit('field', key, val);
	  };

	  parser.onEnd = function() {
	    self.ended = true;
	    self._maybeEnd();
	  };

	  this._parser = parser;
	};

	IncomingForm.prototype._uploadPath = function(filename) {
	  var name = 'upload_';
	  var buf = crypto.randomBytes(16);
	  for (var i = 0; i < buf.length; ++i) {
	    name += ('0' + buf[i].toString(16)).slice(-2);
	  }

	  if (this.keepExtensions) {
	    var ext = path.extname(filename);
	    ext     = ext.replace(/(\.[a-z0-9]+).*/i, '$1');

	    name += ext;
	  }

	  return path.join(this.uploadDir, name);
	};

	IncomingForm.prototype._maybeEnd = function() {
	  if (!this.ended || this._flushing || this.error) {
	    return;
	  }

	  this.emit('end');
	};


	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5).Buffer))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./file": 240,
		"./file.js": 240,
		"./incoming_form": 238,
		"./incoming_form.js": 238,
		"./index": 237,
		"./index.js": 237,
		"./json_parser": 241,
		"./json_parser.js": 241,
		"./multipart_parser": 242,
		"./multipart_parser.js": 242,
		"./octet_parser": 243,
		"./octet_parser.js": 243,
		"./querystring_parser": 244,
		"./querystring_parser.js": 244
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 239;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(global) {if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(239));

	var util = require('util'),
	    WriteStream = require('fs').WriteStream,
	    EventEmitter = require('events').EventEmitter,
	    crypto = require('crypto');

	function File(properties) {
	  EventEmitter.call(this);

	  this.size = 0;
	  this.path = null;
	  this.name = null;
	  this.type = null;
	  this.hash = null;
	  this.lastModifiedDate = null;

	  this._writeStream = null;
	  
	  for (var key in properties) {
	    this[key] = properties[key];
	  }

	  if(typeof this.hash === 'string') {
	    this.hash = crypto.createHash(properties.hash);
	  } else {
	    this.hash = null;
	  }
	}
	module.exports = File;
	util.inherits(File, EventEmitter);

	File.prototype.open = function() {
	  this._writeStream = new WriteStream(this.path);
	};

	File.prototype.toJSON = function() {
	  return {
	    size: this.size,
	    path: this.path,
	    name: this.name,
	    type: this.type,
	    mtime: this.lastModifiedDate,
	    length: this.length,
	    filename: this.filename,
	    mime: this.mime
	  };
	};

	File.prototype.write = function(buffer, cb) {
	  var self = this;
	  if (self.hash) {
	    self.hash.update(buffer);
	  }
	  this._writeStream.write(buffer, function() {
	    self.lastModifiedDate = new Date();
	    self.size += buffer.length;
	    self.emit('progress', self.size);
	    cb();
	  });
	};

	File.prototype.end = function(cb) {
	  var self = this;
	  if (self.hash) {
	    self.hash = self.hash.digest('hex');
	  }
	  this._writeStream.end(function() {
	    self.emit('end');
	    cb();
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(global) {if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(239));

	var Buffer = require('buffer').Buffer;

	function JSONParser() {
	  this.data = new Buffer('');
	  this.bytesWritten = 0;
	}
	exports.JSONParser = JSONParser;

	JSONParser.prototype.initWithLength = function(length) {
	  this.data = new Buffer(length);
	};

	JSONParser.prototype.write = function(buffer) {
	  if (this.data.length >= this.bytesWritten + buffer.length) {
	    buffer.copy(this.data, this.bytesWritten);
	  } else {
	    this.data = Buffer.concat([this.data, buffer]);
	  }
	  this.bytesWritten += buffer.length;
	  return buffer.length;
	};

	JSONParser.prototype.end = function() {
	  try {
	    var fields = JSON.parse(this.data.toString('utf8'));
	    for (var field in fields) {
	      this.onField(field, fields[field]);
	    }
	  } catch (e) {}
	  this.data = null;

	  this.onEnd();
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(5).Buffer,
	    s = 0,
	    S =
	    { PARSER_UNINITIALIZED: s++,
	      START: s++,
	      START_BOUNDARY: s++,
	      HEADER_FIELD_START: s++,
	      HEADER_FIELD: s++,
	      HEADER_VALUE_START: s++,
	      HEADER_VALUE: s++,
	      HEADER_VALUE_ALMOST_DONE: s++,
	      HEADERS_ALMOST_DONE: s++,
	      PART_DATA_START: s++,
	      PART_DATA: s++,
	      PART_END: s++,
	      END: s++
	    },

	    f = 1,
	    F =
	    { PART_BOUNDARY: f,
	      LAST_BOUNDARY: f *= 2
	    },

	    LF = 10,
	    CR = 13,
	    SPACE = 32,
	    HYPHEN = 45,
	    COLON = 58,
	    A = 97,
	    Z = 122,

	    lower = function(c) {
	      return c | 0x20;
	    };

	for (s in S) {
	  exports[s] = S[s];
	}

	function MultipartParser() {
	  this.boundary = null;
	  this.boundaryChars = null;
	  this.lookbehind = null;
	  this.state = S.PARSER_UNINITIALIZED;

	  this.index = null;
	  this.flags = 0;
	}
	exports.MultipartParser = MultipartParser;

	MultipartParser.stateToString = function(stateNumber) {
	  for (var state in S) {
	    var number = S[state];
	    if (number === stateNumber) return state;
	  }
	};

	MultipartParser.prototype.initWithBoundary = function(str) {
	  this.boundary = new Buffer(str.length+4);
	  this.boundary.write('\r\n--', 0);
	  this.boundary.write(str, 4);
	  this.lookbehind = new Buffer(this.boundary.length+8);
	  this.state = S.START;

	  this.boundaryChars = {};
	  for (var i = 0; i < this.boundary.length; i++) {
	    this.boundaryChars[this.boundary[i]] = true;
	  }
	};

	MultipartParser.prototype.write = function(buffer) {
	  var self = this,
	      i = 0,
	      len = buffer.length,
	      prevIndex = this.index,
	      index = this.index,
	      state = this.state,
	      flags = this.flags,
	      lookbehind = this.lookbehind,
	      boundary = this.boundary,
	      boundaryChars = this.boundaryChars,
	      boundaryLength = this.boundary.length,
	      boundaryEnd = boundaryLength - 1,
	      bufferLength = buffer.length,
	      c,
	      cl,

	      mark = function(name) {
	        self[name+'Mark'] = i;
	      },
	      clear = function(name) {
	        delete self[name+'Mark'];
	      },
	      callback = function(name, buffer, start, end) {
	        if (start !== undefined && start === end) {
	          return;
	        }

	        var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);
	        if (callbackSymbol in self) {
	          self[callbackSymbol](buffer, start, end);
	        }
	      },
	      dataCallback = function(name, clear) {
	        var markSymbol = name+'Mark';
	        if (!(markSymbol in self)) {
	          return;
	        }

	        if (!clear) {
	          callback(name, buffer, self[markSymbol], buffer.length);
	          self[markSymbol] = 0;
	        } else {
	          callback(name, buffer, self[markSymbol], i);
	          delete self[markSymbol];
	        }
	      };

	  for (i = 0; i < len; i++) {
	    c = buffer[i];
	    switch (state) {
	      case S.PARSER_UNINITIALIZED:
	        return i;
	      case S.START:
	        index = 0;
	        state = S.START_BOUNDARY;
	      case S.START_BOUNDARY:
	        if (index == boundary.length - 2) {
	          if (c == HYPHEN) {
	            flags |= F.LAST_BOUNDARY;
	          } else if (c != CR) {
	            return i;
	          }
	          index++;
	          break;
	        } else if (index - 1 == boundary.length - 2) {
	          if (flags & F.LAST_BOUNDARY && c == HYPHEN){
	            callback('end');
	            state = S.END;
	            flags = 0;
	          } else if (!(flags & F.LAST_BOUNDARY) && c == LF) {
	            index = 0;
	            callback('partBegin');
	            state = S.HEADER_FIELD_START;
	          } else {
	            return i;
	          }
	          break;
	        }

	        if (c != boundary[index+2]) {
	          index = -2;
	        }
	        if (c == boundary[index+2]) {
	          index++;
	        }
	        break;
	      case S.HEADER_FIELD_START:
	        state = S.HEADER_FIELD;
	        mark('headerField');
	        index = 0;
	      case S.HEADER_FIELD:
	        if (c == CR) {
	          clear('headerField');
	          state = S.HEADERS_ALMOST_DONE;
	          break;
	        }

	        index++;
	        if (c == HYPHEN) {
	          break;
	        }

	        if (c == COLON) {
	          if (index == 1) {
	            // empty header field
	            return i;
	          }
	          dataCallback('headerField', true);
	          state = S.HEADER_VALUE_START;
	          break;
	        }

	        cl = lower(c);
	        if (cl < A || cl > Z) {
	          return i;
	        }
	        break;
	      case S.HEADER_VALUE_START:
	        if (c == SPACE) {
	          break;
	        }

	        mark('headerValue');
	        state = S.HEADER_VALUE;
	      case S.HEADER_VALUE:
	        if (c == CR) {
	          dataCallback('headerValue', true);
	          callback('headerEnd');
	          state = S.HEADER_VALUE_ALMOST_DONE;
	        }
	        break;
	      case S.HEADER_VALUE_ALMOST_DONE:
	        if (c != LF) {
	          return i;
	        }
	        state = S.HEADER_FIELD_START;
	        break;
	      case S.HEADERS_ALMOST_DONE:
	        if (c != LF) {
	          return i;
	        }

	        callback('headersEnd');
	        state = S.PART_DATA_START;
	        break;
	      case S.PART_DATA_START:
	        state = S.PART_DATA;
	        mark('partData');
	      case S.PART_DATA:
	        prevIndex = index;

	        if (index === 0) {
	          // boyer-moore derrived algorithm to safely skip non-boundary data
	          i += boundaryEnd;
	          while (i < bufferLength && !(buffer[i] in boundaryChars)) {
	            i += boundaryLength;
	          }
	          i -= boundaryEnd;
	          c = buffer[i];
	        }

	        if (index < boundary.length) {
	          if (boundary[index] == c) {
	            if (index === 0) {
	              dataCallback('partData', true);
	            }
	            index++;
	          } else {
	            index = 0;
	          }
	        } else if (index == boundary.length) {
	          index++;
	          if (c == CR) {
	            // CR = part boundary
	            flags |= F.PART_BOUNDARY;
	          } else if (c == HYPHEN) {
	            // HYPHEN = end boundary
	            flags |= F.LAST_BOUNDARY;
	          } else {
	            index = 0;
	          }
	        } else if (index - 1 == boundary.length)  {
	          if (flags & F.PART_BOUNDARY) {
	            index = 0;
	            if (c == LF) {
	              // unset the PART_BOUNDARY flag
	              flags &= ~F.PART_BOUNDARY;
	              callback('partEnd');
	              callback('partBegin');
	              state = S.HEADER_FIELD_START;
	              break;
	            }
	          } else if (flags & F.LAST_BOUNDARY) {
	            if (c == HYPHEN) {
	              callback('partEnd');
	              callback('end');
	              state = S.END;
	              flags = 0;
	            } else {
	              index = 0;
	            }
	          } else {
	            index = 0;
	          }
	        }

	        if (index > 0) {
	          // when matching a possible boundary, keep a lookbehind reference
	          // in case it turns out to be a false lead
	          lookbehind[index-1] = c;
	        } else if (prevIndex > 0) {
	          // if our boundary turned out to be rubbish, the captured lookbehind
	          // belongs to partData
	          callback('partData', lookbehind, 0, prevIndex);
	          prevIndex = 0;
	          mark('partData');

	          // reconsider the current character even so it interrupted the sequence
	          // it could be the beginning of a new sequence
	          i--;
	        }

	        break;
	      case S.END:
	        break;
	      default:
	        return i;
	    }
	  }

	  dataCallback('headerField');
	  dataCallback('headerValue');
	  dataCallback('partData');

	  this.index = index;
	  this.state = state;
	  this.flags = flags;

	  return len;
	};

	MultipartParser.prototype.end = function() {
	  var callback = function(self, name) {
	    var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);
	    if (callbackSymbol in self) {
	      self[callbackSymbol]();
	    }
	  };
	  if ((this.state == S.HEADER_FIELD_START && this.index === 0) ||
	      (this.state == S.PART_DATA && this.index == this.boundary.length)) {
	    callback(this, 'partEnd');
	    callback(this, 'end');
	  } else if (this.state != S.END) {
	    return new Error('MultipartParser.end(): stream ended unexpectedly: ' + this.explain());
	  }
	};

	MultipartParser.prototype.explain = function() {
	  return 'state = ' + MultipartParser.stateToString(this.state);
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var EventEmitter = __webpack_require__(14).EventEmitter
		, util = __webpack_require__(10);

	function OctetParser(options){
		if(!(this instanceof OctetParser)) return new OctetParser(options);
		EventEmitter.call(this);
	}

	util.inherits(OctetParser, EventEmitter);

	exports.OctetParser = OctetParser;

	OctetParser.prototype.write = function(buffer) {
	    this.emit('data', buffer);
		return buffer.length;
	};

	OctetParser.prototype.end = function() {
		this.emit('end');
	};


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(global) {if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(239));

	// This is a buffering parser, not quite as nice as the multipart one.
	// If I find time I'll rewrite this to be fully streaming as well
	var querystring = require('querystring');

	function QuerystringParser(maxKeys) {
	  this.maxKeys = maxKeys;
	  this.buffer = '';
	}
	exports.QuerystringParser = QuerystringParser;

	QuerystringParser.prototype.write = function(buffer) {
	  this.buffer += buffer.toString('ascii');
	  return buffer.length;
	};

	QuerystringParser.prototype.end = function() {
	  var fields = querystring.parse(this.buffer, '&', '=', { maxKeys: this.maxKeys });
	  for (var field in fields) {
	    this.onField(field, fields[field]);
	  }
	  this.buffer = '';

	  this.onEnd();
	};


	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*
	 * vasync.js: utilities for observable asynchronous control flow
	 */

	var mod_assert = __webpack_require__(9);
	var mod_events = __webpack_require__(14);
	var mod_util = __webpack_require__(10);
	var mod_verror = __webpack_require__(246);

	/*
	 * Public interface
	 */
	exports.parallel = parallel;
	exports.forEachParallel = forEachParallel;
	exports.pipeline = pipeline;
	exports.forEachPipeline = forEachPipeline;
	exports.queue = queue;
	exports.queuev = queuev;
	exports.barrier = barrier;
	exports.waterfall = waterfall;

	if (!global.setImmediate) {
		global.setImmediate = function (func) {
			var args = Array.prototype.slice.call(arguments, 1);
			args.unshift(0);
			args.unshift(func);
			setTimeout.apply(this, args);
		};
	}

	/*
	 * This is incorporated here from jsprim because jsprim ends up pulling in a lot
	 * of dependencies.  If we end up needing more from jsprim, though, we should
	 * add it back and rip out this function.
	 */
	function isEmpty(obj)
	{
		var key;
		for (key in obj)
			return (false);
		return (true);
	}

	/*
	 * Given a set of functions that complete asynchronously using the standard
	 * callback(err, result) pattern, invoke them all and merge the results.  See
	 * README.md for details.
	 */
	function parallel(args, callback)
	{
		var funcs, rv, doneOne, i;

		mod_assert.equal(typeof (args), 'object', '"args" must be an object');
		mod_assert.ok(Array.isArray(args['funcs']),
		    '"args.funcs" must be specified and must be an array');
		mod_assert.equal(typeof (callback), 'function',
		    'callback argument must be specified and must be a function');

		funcs = args['funcs'].slice(0);

		rv = {
		    'operations': new Array(funcs.length),
		    'successes': [],
		    'ndone': 0,
		    'nerrors': 0
		};

		if (funcs.length === 0) {
			setImmediate(function () { callback(null, rv); });
			return (rv);
		}

		doneOne = function (entry) {
			return (function (err, result) {
				mod_assert.equal(entry['status'], 'pending');

				entry['err'] = err;
				entry['result'] = result;
				entry['status'] = err ? 'fail' : 'ok';

				if (err)
					rv['nerrors']++;
				else
					rv['successes'].push(result);

				if (++rv['ndone'] < funcs.length)
					return;

				var errors = rv['operations'].filter(function (ent) {
					return (ent['status'] == 'fail');
				}).map(function (ent) { return (ent['err']); });

				if (errors.length > 0)
					callback(new mod_verror.MultiError(errors), rv);
				else
					callback(null, rv);
			});
		};

		for (i = 0; i < funcs.length; i++) {
			rv['operations'][i] = {
				'func': funcs[i],
				'funcname': funcs[i].name || '(anon)',
				'status': 'pending'
			};

			funcs[i](doneOne(rv['operations'][i]));
		}

		return (rv);
	}

	/*
	 * Exactly like parallel, except that the input is specified as a single
	 * function to invoke on N different inputs (rather than N functions).  "args"
	 * must have the following fields:
	 *
	 *	func		asynchronous function to invoke on each input value
	 *
	 *	inputs		array of input values
	 */
	function forEachParallel(args, callback)
	{
		var func, funcs;

		mod_assert.equal(typeof (args), 'object', '"args" must be an object');
		mod_assert.equal(typeof (args['func']), 'function',
		    '"args.func" must be specified and must be a function');
		mod_assert.ok(Array.isArray(args['inputs']),
		    '"args.inputs" must be specified and must be an array');

		func = args['func'];
		funcs = args['inputs'].map(function (input) {
			return (function (subcallback) {
				return (func(input, subcallback));
			});
		});

		return (parallel({ 'funcs': funcs }, callback));
	}

	/*
	 * Like parallel, but invokes functions in sequence rather than in parallel
	 * and aborts if any function exits with failure.  Arguments include:
	 *
	 *    funcs	invoke the functions in parallel
	 *
	 *    arg	first argument to each pipeline function
	 */
	function pipeline(args, callback)
	{
		var funcs, uarg, rv, next;

		mod_assert.equal(typeof (args), 'object', '"args" must be an object');
		mod_assert.ok(Array.isArray(args['funcs']),
		    '"args.funcs" must be specified and must be an array');

		funcs = args['funcs'].slice(0);
		uarg = args['arg'];

		rv = {
		    'operations': funcs.map(function (func) {
			return ({
			    'func': func,
			    'funcname': func.name || '(anon)',
			    'status': 'waiting'
			});
		    }),
		    'successes': [],
		    'ndone': 0,
		    'nerrors': 0
		};

		if (funcs.length === 0) {
			setImmediate(function () { callback(null, rv); });
			return (rv);
		}

		next = function (err, result) {
			if (rv['nerrors'] > 0 ||
			    rv['ndone'] >= rv['operations'].length) {
				throw new mod_verror.VError('pipeline callback ' +
				    'invoked after the pipeline has already ' +
				    'completed (%j)', rv);
			}

			var entry = rv['operations'][rv['ndone']++];

			mod_assert.equal(entry['status'], 'pending');

			entry['status'] = err ? 'fail' : 'ok';
			entry['err'] = err;
			entry['result'] = result;

			if (err)
				rv['nerrors']++;
			else
				rv['successes'].push(result);

			if (err || rv['ndone'] == funcs.length) {
				callback(err, rv);
			} else {
				var nextent = rv['operations'][rv['ndone']];
				nextent['status'] = 'pending';

				/*
				 * We invoke the next function on the next tick so that
				 * the caller (stage N) need not worry about the case
				 * that the next stage (stage N + 1) runs in its own
				 * context.
				 */
				setImmediate(function () {
					nextent['func'](uarg, next);
				});
			}
		};

		rv['operations'][0]['status'] = 'pending';
		funcs[0](uarg, next);

		return (rv);
	}

	/*
	 * Exactly like pipeline, except that the input is specified as a single
	 * function to invoke on N different inputs (rather than N functions).  "args"
	 * must have the following fields:
	 *
	 *	func		asynchronous function to invoke on each input value
	 *
	 *	inputs		array of input values
	 */
	function forEachPipeline(args, callback) {
	    mod_assert.equal(typeof (args), 'object', '"args" must be an object');
	    mod_assert.equal(typeof (args['func']), 'function',
			'"args.func" must be specified and must be a function');
	    mod_assert.ok(Array.isArray(args['inputs']),
			'"args.inputs" must be specified and must be an array');
	    mod_assert.equal(typeof (callback), 'function',
			'callback argument must be specified and must be a function');

	    var func = args['func'];

	    var funcs = args['inputs'].map(function (input) {
			return (function (_, subcallback) {
				return (func(input, subcallback));
			});
	    });

	    return (pipeline({'funcs': funcs}, callback));
	}


	/*
	 * async-compatible "queue" function.
	 */
	function queue(worker, concurrency)
	{
		return (new WorkQueue({
		    'worker': worker,
		    'concurrency': concurrency
		}));
	}

	function queuev(args)
	{
		return (new WorkQueue(args));
	}

	function WorkQueue(args)
	{
		mod_assert.ok(args.hasOwnProperty('worker'));
		mod_assert.equal(typeof (args['worker']), 'function');
		mod_assert.ok(args.hasOwnProperty('concurrency'));
		mod_assert.equal(typeof (args['concurrency']), 'number');
		mod_assert.equal(Math.floor(args['concurrency']), args['concurrency']);
		mod_assert.ok(args['concurrency'] > 0);

		mod_events.EventEmitter.call(this);

		this.nextid = 0;
		this.worker = args['worker'];
		this.worker_name = args['worker'].name || 'anon';
		this.npending = 0;
		this.pending = {};
		this.queued = [];
		this.closed = false;
		this.ended = false;

		/* user-settable fields inherited from "async" interface */
		this.concurrency = args['concurrency'];
		this.saturated = undefined;
		this.empty = undefined;
		this.drain = undefined;
	}

	mod_util.inherits(WorkQueue, mod_events.EventEmitter);

	WorkQueue.prototype.push = function (tasks, callback)
	{
		if (!Array.isArray(tasks))
			return (this.pushOne(tasks, callback));

		var wq = this;
		return (tasks.map(function (task) {
		    return (wq.pushOne(task, callback));
		}));
	};

	WorkQueue.prototype.updateConcurrency = function (concurrency)
	{
		if (this.closed)
			throw new mod_verror.VError(
				'update concurrency invoked after queue closed');
		this.concurrency = concurrency;
		this.dispatchNext();
	};

	WorkQueue.prototype.close = function ()
	{
		var wq = this;

		if (wq.closed)
			return;
		wq.closed = true;

		/*
		 * If the queue is already empty, just fire the "end" event on the
		 * next tick.
		 */
		if (wq.npending === 0 && wq.queued.length === 0) {
			setImmediate(function () {
				if (!wq.ended) {
					wq.ended = true;
					wq.emit('end');
				}
			});
		}
	};

	/* private */
	WorkQueue.prototype.pushOne = function (task, callback)
	{
		if (this.closed)
			throw new mod_verror.VError('push invoked after queue closed');

		var id = ++this.nextid;
		var entry = { 'id': id, 'task': task, 'callback': callback };

		this.queued.push(entry);
		this.dispatchNext();

		return (id);
	};

	/* private */
	WorkQueue.prototype.dispatchNext = function ()
	{
		var wq = this;
		if (wq.npending === 0 && wq.queued.length === 0) {
			if (wq.drain)
				wq.drain();
			wq.emit('drain');
			/*
			 * The queue is closed; emit the final "end"
			 * event before we come to rest:
			 */
			if (wq.closed) {
				wq.ended = true;
				wq.emit('end');
			}
		} else if (wq.queued.length > 0) {
			while (wq.queued.length > 0 && wq.npending < wq.concurrency) {
				var next = wq.queued.shift();
				wq.dispatch(next);

				if (wq.queued.length === 0) {
					if (wq.empty)
						wq.empty();
					wq.emit('empty');
				}
			}
		}
	};

	WorkQueue.prototype.dispatch = function (entry)
	{
		var wq = this;

		mod_assert.ok(!this.pending.hasOwnProperty(entry['id']));
		mod_assert.ok(this.npending < this.concurrency);
		mod_assert.ok(!this.ended);

		this.npending++;
		this.pending[entry['id']] = entry;

		if (this.npending === this.concurrency) {
			if (this.saturated)
				this.saturated();
			this.emit('saturated');
		}

		/*
		 * We invoke the worker function on the next tick so that callers can
		 * always assume that the callback is NOT invoked during the call to
		 * push() even if the queue is not at capacity.  It also avoids O(n)
		 * stack usage when used with synchronous worker functions.
		 */
		setImmediate(function () {
			wq.worker(entry['task'], function (err) {
				--wq.npending;
				delete (wq.pending[entry['id']]);

				if (entry['callback'])
					entry['callback'].apply(null, arguments);

				wq.dispatchNext();
			});
		});
	};

	WorkQueue.prototype.length = function ()
	{
		return (this.queued.length);
	};

	WorkQueue.prototype.kill = function ()
	{
		this.killed = true;
		this.queued = [];
		this.drain = undefined;
		this.close();
	};

	/*
	 * Barriers coordinate multiple concurrent operations.
	 */
	function barrier(args)
	{
		return (new Barrier(args));
	}

	function Barrier(args)
	{
		mod_assert.ok(!args || !args['nrecent'] ||
		    typeof (args['nrecent']) == 'number',
		    '"nrecent" must have type "number"');

		mod_events.EventEmitter.call(this);

		var nrecent = args && args['nrecent'] ? args['nrecent'] : 10;

		if (nrecent > 0) {
			this.nrecent = nrecent;
			this.recent = [];
		}

		this.pending = {};
		this.scheduled = false;
	}

	mod_util.inherits(Barrier, mod_events.EventEmitter);

	Barrier.prototype.start = function (name)
	{
		mod_assert.ok(!this.pending.hasOwnProperty(name),
		    'operation "' + name + '" is already pending');
		this.pending[name] = Date.now();
	};

	Barrier.prototype.done = function (name)
	{
		mod_assert.ok(this.pending.hasOwnProperty(name),
		    'operation "' + name + '" is not pending');

		if (this.recent) {
			this.recent.push({
			    'name': name,
			    'start': this.pending[name],
			    'done': Date.now()
			});

			if (this.recent.length > this.nrecent)
				this.recent.shift();
		}

		delete (this.pending[name]);

		/*
		 * If we executed at least one operation and we're now empty, we should
		 * emit "drain".  But most code doesn't deal well with events being
		 * processed while they're executing, so we actually schedule this event
		 * for the next tick.
		 *
		 * We use the "scheduled" flag to avoid emitting multiple "drain" events
		 * on consecutive ticks if the user starts and ends another task during
		 * this tick.
		 */
		if (!isEmpty(this.pending) || this.scheduled)
			return;

		this.scheduled = true;

		var self = this;

		setImmediate(function () {
			self.scheduled = false;

			/*
			 * It's also possible that the user has started another task on
			 * the previous tick, in which case we really shouldn't emit
			 * "drain".
			 */
			if (isEmpty(self.pending))
				self.emit('drain');
		});
	};

	/*
	 * waterfall([ funcs ], callback): invoke each of the asynchronous functions
	 * "funcs" in series.  Each function is passed any values emitted by the
	 * previous function (none for the first function), followed by the callback to
	 * invoke upon completion.  This callback must be invoked exactly once,
	 * regardless of success or failure.  As conventional in Node, the first
	 * argument to the callback indicates an error (if non-null).  Subsequent
	 * arguments are passed to the next function in the "funcs" chain.
	 *
	 * If any function fails (i.e., calls its callback with an Error), then the
	 * remaining functions are not invoked and "callback" is invoked with the error.
	 *
	 * The only difference between waterfall() and pipeline() are the arguments
	 * passed to each function in the chain.  pipeline() always passes the same
	 * argument followed by the callback, while waterfall() passes whatever values
	 * were emitted by the previous function followed by the callback.
	 */
	function waterfall(funcs, callback)
	{
		var rv, current, next;

		mod_assert.ok(Array.isArray(funcs));
		mod_assert.ok(arguments.length == 1 || callback instanceof Function);
		funcs = funcs.slice(0);

		rv = {
		    'operations': funcs.map(function (func) {
		        return ({
			    'func': func,
			    'funcname': func.name || '(anon)',
			    'status': 'waiting'
			});
		    }),
		    'successes': [],
		    'ndone': 0,
		    'nerrors': 0
		};

		if (funcs.length === 0) {
			if (callback)
				setImmediate(function () { callback(null, rv); });
			return (rv);
		}

		next = function (idx, err) {
			var args, entry, nextentry;

			if (err === undefined)
				err = null;

			if (idx != current) {
				throw (new mod_verror.VError(
				    'vasync.waterfall: function %d ("%s") invoked ' +
				    'its callback twice', idx,
				    rv['operations'][idx].funcname));
			}

			mod_assert.equal(idx, rv['ndone']);
			entry = rv['operations'][rv['ndone']++];
			args = Array.prototype.slice.call(arguments, 2);

			mod_assert.equal(entry['status'], 'pending');
			entry['status'] = err ? 'fail' : 'ok';
			entry['err'] = err;
			entry['results'] = args;

			if (err)
				rv['nerrors']++;
			else
				rv['successes'].push(args);

			if (err || rv['ndone'] == funcs.length) {
				if (callback) {
					args.unshift(err);
					callback.apply(null, args);
				}
			} else {
				nextentry = rv['operations'][rv['ndone']];
				nextentry['status'] = 'pending';
				current++;
				args.push(next.bind(null, current));
				setImmediate(function () {
					nextentry['func'].apply(null, args);
				});
			}
		};

		rv['operations'][0]['status'] = 'pending';
		current = 0;
		funcs[0](next.bind(null, current));
		return (rv);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(38).setImmediate))

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * verror.js: richer JavaScript errors
	 */

	var mod_assert = __webpack_require__(9);
	var mod_util = __webpack_require__(10);

	var mod_extsprintf = __webpack_require__(109);

	/*
	 * Public interface
	 */

	/* So you can 'var VError = require('verror')' */
	module.exports = VError;
	/* For compatibility */
	VError.VError = VError;
	/* Other exported classes */
	VError.SError = SError;
	VError.WError = WError;
	VError.MultiError = MultiError;

	/*
	 * VError([cause], fmt[, arg...]): Like JavaScript's built-in Error class, but
	 * supports a "cause" argument (another error) and a printf-style message.  The
	 * cause argument can be null or omitted entirely.
	 *
	 * Examples:
	 *
	 * CODE                                    MESSAGE
	 * new VError('something bad happened')    "something bad happened"
	 * new VError('missing file: "%s"', file)  "missing file: "/etc/passwd"
	 *   with file = '/etc/passwd'
	 * new VError(err, 'open failed')          "open failed: file not found"
	 *   with err.message = 'file not found'
	 */
	function VError(options)
	{
		var args, obj, causedBy, ctor, tailmsg;

		/*
		 * This is a regrettable pattern, but JavaScript's built-in Error class
		 * is defined to work this way, so we allow the constructor to be called
		 * without "new".
		 */
		if (!(this instanceof VError)) {
			args = Array.prototype.slice.call(arguments, 0);
			obj = Object.create(VError.prototype);
			VError.apply(obj, arguments);
			return (obj);
		}

		if (options instanceof Error || typeof (options) === 'object') {
			args = Array.prototype.slice.call(arguments, 1);
		} else {
			args = Array.prototype.slice.call(arguments, 0);
			options = undefined;
		}

		/*
		 * extsprintf (which we invoke here with our caller's arguments in order
		 * to construct this Error's message) is strict in its interpretation of
		 * values to be processed by the "%s" specifier.  The value passed to
		 * extsprintf must actually be a string or something convertible to a
		 * String using .toString().  Passing other values (notably "null" and
		 * "undefined") is considered a programmer error.  The assumption is
		 * that if you actually want to print the string "null" or "undefined",
		 * then that's easy to do that when you're calling extsprintf; on the
		 * other hand, if you did NOT want that (i.e., there's actually a bug
		 * where the program assumes some variable is non-null and tries to
		 * print it, which might happen when constructing a packet or file in
		 * some specific format), then it's better to stop immediately than
		 * produce bogus output.
		 *
		 * However, sometimes the bug is only in the code calling VError, and a
		 * programmer might prefer to have the error message contain "null" or
		 * "undefined" rather than have the bug in the error path crash the
		 * program (making the first bug harder to identify).  For that reason,
		 * by default VError converts "null" or "undefined" arguments to their
		 * string representations and passes those to extsprintf.  Programmers
		 * desiring the strict behavior can use the SError class or pass the
		 * "strict" option to the VError constructor.
		 */
		if (!options || !options.strict) {
			args = args.map(function (a) {
				return (a === null ? 'null' :
				    a === undefined ? 'undefined' : a);
			});
		}

		tailmsg = args.length > 0 ?
		    mod_extsprintf.sprintf.apply(null, args) : '';
		this.jse_shortmsg = tailmsg;
		this.jse_summary = tailmsg;

		if (options) {
			causedBy = options.cause;

			if (!causedBy || !(options.cause instanceof Error))
				causedBy = options;

			if (causedBy && (causedBy instanceof Error)) {
				this.jse_cause = causedBy;
				this.jse_summary += ': ' + causedBy.message;
			}
		}

		this.message = this.jse_summary;
		Error.call(this, this.jse_summary);

		if (Error.captureStackTrace) {
			ctor = options ? options.constructorOpt : undefined;
			ctor = ctor || arguments.callee;
			Error.captureStackTrace(this, ctor);
		}

		return (this);
	}

	mod_util.inherits(VError, Error);
	VError.prototype.name = 'VError';

	VError.prototype.toString = function ve_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;

		return (str);
	};

	VError.prototype.cause = function ve_cause()
	{
		return (this.jse_cause);
	};


	/*
	 * SError is like VError, but stricter about types.  You cannot pass "null" or
	 * "undefined" as string arguments to the formatter.  Since SError is only a
	 * different function, not really a different class, we don't set
	 * SError.prototype.name.
	 */
	function SError()
	{
		var fmtargs, opts, key, args;

		opts = {};
		opts.constructorOpt = SError;

		if (arguments[0] instanceof Error) {
			opts.cause = arguments[0];
			fmtargs = Array.prototype.slice.call(arguments, 1);
		} else if (typeof (arguments[0]) == 'object') {
			for (key in arguments[0])
				opts[key] = arguments[0][key];
			fmtargs = Array.prototype.slice.call(arguments, 1);
		} else {
			fmtargs = Array.prototype.slice.call(arguments, 0);
		}

		opts.strict = true;
		args = [ opts ].concat(fmtargs);
		VError.apply(this, args);
	}

	mod_util.inherits(SError, VError);


	/*
	 * Represents a collection of errors for the purpose of consumers that generally
	 * only deal with one error.  Callers can extract the individual errors
	 * contained in this object, but may also just treat it as a normal single
	 * error, in which case a summary message will be printed.
	 */
	function MultiError(errors)
	{
		mod_assert.ok(errors.length > 0);
		this.ase_errors = errors;

		VError.call(this, errors[0], 'first of %d error%s',
		    errors.length, errors.length == 1 ? '' : 's');
	}

	mod_util.inherits(MultiError, VError);


	/*
	 * Like JavaScript's built-in Error class, but supports a "cause" argument which
	 * is wrapped, not "folded in" as with VError.	Accepts a printf-style message.
	 * The cause argument can be null.
	 */
	function WError(options)
	{
		Error.call(this);

		var args, cause, ctor;
		if (typeof (options) === 'object') {
			args = Array.prototype.slice.call(arguments, 1);
		} else {
			args = Array.prototype.slice.call(arguments, 0);
			options = undefined;
		}

		if (args.length > 0) {
			this.message = mod_extsprintf.sprintf.apply(null, args);
		} else {
			this.message = '';
		}

		if (options) {
			if (options instanceof Error) {
				cause = options;
			} else {
				cause = options.cause;
				ctor = options.constructorOpt;
			}
		}

		Error.captureStackTrace(this, ctor || this.constructor);
		if (cause)
			this.cause(cause);

	}

	mod_util.inherits(WError, Error);
	WError.prototype.name = 'WError';


	WError.prototype.toString = function we_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;
		if (this.we_cause && this.we_cause.message)
			str += '; caused by ' + this.we_cause.toString();

		return (str);
	};

	WError.prototype.cause = function we_cause(c)
	{
		if (c instanceof Error)
			this.we_cause = c;

		return (this.we_cause);
	};


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Dependencies
	 */

	'use strict';

	var csv = __webpack_require__(248);
	var assert = __webpack_require__(4);

	///--- API

	/**
	 * Returns a plugin that will parse the HTTP request body if the
	 * contentType is `text/csv` or `text/tsv`
	 * @public
	 * @function fieldedTextParser
	 * @param    {Object}    options an options object
	 * @returns  {Function}
	 */
	function fieldedTextParser(options) {

	    assert.optionalObject(options, 'options');
	    options = options || {};

	    function parseFieldedText(req, res, next) {

	        var contentType = req.getContentType();

	        if (contentType !== 'text/csv' &&
	            contentType !== 'text/tsv' &&
	            contentType !== 'text/tab-separated-values' || !req.body) {
	            next();
	            return;
	        }


	        var hDelimiter = req.headers['x-content-delimiter'];
	        var hEscape = req.headers['x-content-escape'];
	        var hQuote = req.headers['x-content-quote'];
	        var hColumns = req.headers['x-content-columns'];


	        var delimiter = (contentType === 'text/tsv') ? '\t' : ',';
	        delimiter = (hDelimiter) ? hDelimiter : delimiter;
	        var escape = (hEscape) ? hEscape : '\\';
	        var quote = (hQuote) ? hQuote : '"';
	        var columns = (hColumns) ? hColumns : true;

	        var parserOptions = {
	            delimiter: delimiter,
	            quote: quote,
	            escape: escape,
	            columns: columns
	        };

	        csv.parse(req.body, parserOptions, function (err, parsedBody) {
	            if (err) {
	                return (next(err));
	            }

	            // Add an "index" property to every row
	            parsedBody.forEach(function (row, index) {
	                row.index = index;
	            });
	            req.body = parsedBody;
	            return (next());
	        });

	    }

	    return (parseFieldedText);

	}

	module.exports = fieldedTextParser;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.7.1
	var generate, parse, stringify, transform;

	generate = __webpack_require__(249);

	parse = __webpack_require__(250);

	transform = __webpack_require__(251);

	stringify = __webpack_require__(252);

	module.exports.generate = generate;

	module.exports.parse = parse;

	module.exports.transform = transform;

	module.exports.stringify = stringify;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.7.1
	var Generator, stream, util;

	stream = __webpack_require__(13);

	util = __webpack_require__(10);

	module.exports = function() {
	  var callback, data, generator, options;
	  if (arguments.length === 2) {
	    options = arguments[0];
	    callback = arguments[1];
	  } else if (arguments.length === 1) {
	    if (typeof arguments[0] === 'function') {
	      options = {};
	      callback = arguments[0];
	    } else {
	      options = arguments[0];
	    }
	  } else if (arguments.length === 0) {
	    options = {};
	  }
	  generator = new Generator(options);
	  if (callback) {
	    data = [];
	    generator.on('readable', function() {
	      var d, _results;
	      _results = [];
	      while (d = generator.read()) {
	        _results.push(data.push(options.objectMode ? d : d.toString()));
	      }
	      return _results;
	    });
	    generator.on('error', callback);
	    generator.on('end', function() {
	      return callback(null, options.objectMode ? data : data.join(''));
	    });
	  }
	  return generator;
	};

	Generator = function(options) {
	  var i, v, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _i, _len, _ref;
	  this.options = options != null ? options : {};
	  stream.Readable.call(this, this.options);
	  this.options.count = 0;
	  if ((_base = this.options).duration == null) {
	    _base.duration = 4 * 60 * 1000;
	  }
	  if ((_base1 = this.options).columns == null) {
	    _base1.columns = 8;
	  }
	  if ((_base2 = this.options).max_word_length == null) {
	    _base2.max_word_length = 16;
	  }
	  if ((_base3 = this.options).fixed_size == null) {
	    _base3.fixed_size = false;
	  }
	  if (this.fixed_size_buffer == null) {
	    this.fixed_size_buffer = '';
	  }
	  if ((_base4 = this.options).start == null) {
	    _base4.start = Date.now();
	  }
	  if ((_base5 = this.options).end == null) {
	    _base5.end = null;
	  }
	  if ((_base6 = this.options).seed == null) {
	    _base6.seed = false;
	  }
	  if ((_base7 = this.options).length == null) {
	    _base7.length = -1;
	  }
	  if ((_base8 = this.options).delimiter == null) {
	    _base8.delimiter = ',';
	  }
	  this.count_written = 0;
	  this.count_created = 0;
	  if (typeof this.options.columns === 'number') {
	    this.options.columns = new Array(this.options.columns);
	  }
	  _ref = this.options.columns;
	  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
	    v = _ref[i];
	    if (v == null) {
	      v = 'ascii';
	    }
	    if (typeof v === 'string') {
	      this.options.columns[i] = Generator[v];
	    }
	  }
	  return this;
	};

	util.inherits(Generator, stream.Readable);

	module.exports.Generator = Generator;

	Generator.prototype.random = function() {
	  if (this.options.seed) {
	    return this.options.seed = this.options.seed * Math.PI * 100 % 100 / 100;
	  } else {
	    return Math.random();
	  }
	};

	Generator.prototype.end = function() {
	  return this.push(null);
	};

	Generator.prototype._read = function(size) {
	  var column, data, header, length, line, lineLength, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
	  data = [];
	  length = this.fixed_size_buffer.length;
	  if (length) {
	    data.push(this.fixed_size_buffer);
	  }
	  while (true) {
	    if ((this.count_created === this.options.length) || (this.options.end && Date.now() > this.options.end)) {
	      if (data.length) {
	        if (this.options.objectMode) {
	          for (_i = 0, _len = data.length; _i < _len; _i++) {
	            line = data[_i];
	            this.count_written++;
	            this.push(line);
	          }
	        } else {
	          this.count_written++;
	          this.push(data.join(''));
	        }
	      }
	      return this.push(null);
	    }
	    line = [];
	    _ref = this.options.columns;
	    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
	      header = _ref[_j];
	      line.push("" + (header(this)));
	    }
	    if (this.options.objectMode) {
	      lineLength = 0;
	      for (_k = 0, _len2 = line.length; _k < _len2; _k++) {
	        column = line[_k];
	        lineLength += column.length;
	      }
	    } else {
	      line = "" + (this.count_created === 0 ? '' : '\n') + (line.join(this.options.delimiter));
	      lineLength = line.length;
	    }
	    this.count_created++;
	    if (length + lineLength > size) {
	      if (this.options.objectMode) {
	        data.push(line);
	        for (_l = 0, _len3 = data.length; _l < _len3; _l++) {
	          line = data[_l];
	          this.count_written++;
	          this.push(line);
	        }
	      } else {
	        if (this.options.fixed_size) {
	          this.fixed_size_buffer = line.substr(size - length);
	          data.push(line.substr(0, size - length));
	        } else {
	          data.push(line);
	        }
	        this.count_written++;
	        this.push(data.join(''));
	      }
	      break;
	    }
	    length += lineLength;
	    data.push(line);
	  }
	};

	Generator.ascii = function(gen) {
	  var char, column, nb_chars, _i, _ref;
	  column = [];
	  for (nb_chars = _i = 0, _ref = Math.ceil(gen.random() * gen.options.max_word_length); 0 <= _ref ? _i < _ref : _i > _ref; nb_chars = 0 <= _ref ? ++_i : --_i) {
	    char = Math.floor(gen.random() * 32);
	    column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));
	  }
	  return column.join('');
	};

	Generator.int = function(gen) {
	  return Math.floor(gen.random() * Math.pow(2, 52));
	};

	Generator.bool = function(gen) {
	  return Math.floor(gen.random() * 2);
	};


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Generated by CoffeeScript 1.10.0
	var Parser, StringDecoder, stream, util;

	stream = __webpack_require__(13);

	util = __webpack_require__(10);

	StringDecoder = __webpack_require__(166).StringDecoder;

	module.exports = function() {
	  var callback, called, chunks, data, options, parser;
	  if (arguments.length === 3) {
	    data = arguments[0];
	    options = arguments[1];
	    callback = arguments[2];
	    if (typeof callback !== 'function') {
	      throw Error("Invalid callback argument: " + (JSON.stringify(callback)));
	    }
	    if (!(typeof data === 'string' || Buffer.isBuffer(arguments[0]))) {
	      return callback(Error("Invalid data argument: " + (JSON.stringify(data))));
	    }
	  } else if (arguments.length === 2) {
	    if (typeof arguments[0] === 'string' || Buffer.isBuffer(arguments[0])) {
	      data = arguments[0];
	    } else {
	      options = arguments[0];
	    }
	    if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	    } else {
	      options = arguments[1];
	    }
	  } else if (arguments.length === 1) {
	    if (typeof arguments[0] === 'function') {
	      callback = arguments[0];
	    } else {
	      options = arguments[0];
	    }
	  }
	  if (options == null) {
	    options = {};
	  }
	  parser = new Parser(options);
	  if (data != null) {
	    process.nextTick(function() {
	      parser.write(data);
	      return parser.end();
	    });
	  }
	  if (callback) {
	    called = false;
	    chunks = options.objname ? {} : [];
	    parser.on('readable', function() {
	      var chunk, results;
	      results = [];
	      while (chunk = parser.read()) {
	        if (options.objname) {
	          results.push(chunks[chunk[0]] = chunk[1]);
	        } else {
	          results.push(chunks.push(chunk));
	        }
	      }
	      return results;
	    });
	    parser.on('error', function(err) {
	      called = true;
	      return callback(err);
	    });
	    parser.on('end', function() {
	      if (!called) {
	        return callback(null, chunks);
	      }
	    });
	  }
	  return parser;
	};

	Parser = function(options) {
	  var base, base1, base10, base11, base12, base13, base14, base15, base16, base2, base3, base4, base5, base6, base7, base8, base9, k, v;
	  if (options == null) {
	    options = {};
	  }
	  options.objectMode = true;
	  this.options = {};
	  for (k in options) {
	    v = options[k];
	    this.options[k] = v;
	  }
	  stream.Transform.call(this, this.options);
	  if ((base = this.options).rowDelimiter == null) {
	    base.rowDelimiter = null;
	  }
	  if ((base1 = this.options).delimiter == null) {
	    base1.delimiter = ',';
	  }
	  if ((base2 = this.options).quote == null) {
	    base2.quote = '"';
	  }
	  if ((base3 = this.options).escape == null) {
	    base3.escape = '"';
	  }
	  if ((base4 = this.options).columns == null) {
	    base4.columns = null;
	  }
	  if ((base5 = this.options).comment == null) {
	    base5.comment = '';
	  }
	  if ((base6 = this.options).objname == null) {
	    base6.objname = false;
	  }
	  if ((base7 = this.options).trim == null) {
	    base7.trim = false;
	  }
	  if ((base8 = this.options).ltrim == null) {
	    base8.ltrim = false;
	  }
	  if ((base9 = this.options).rtrim == null) {
	    base9.rtrim = false;
	  }
	  if ((base10 = this.options).auto_parse == null) {
	    base10.auto_parse = false;
	  }
	  if ((base11 = this.options).auto_parse_date == null) {
	    base11.auto_parse_date = false;
	  }
	  if ((base12 = this.options).relax == null) {
	    base12.relax = false;
	  }
	  if ((base13 = this.options).relax_column_count == null) {
	    base13.relax_column_count = false;
	  }
	  if ((base14 = this.options).skip_empty_lines == null) {
	    base14.skip_empty_lines = false;
	  }
	  if ((base15 = this.options).max_limit_on_data_read == null) {
	    base15.max_limit_on_data_read = 128000;
	  }
	  if ((base16 = this.options).skip_lines_with_empty_values == null) {
	    base16.skip_lines_with_empty_values = false;
	  }
	  this.lines = 0;
	  this.count = 0;
	  this.skipped_line_count = 0;
	  this.empty_line_count = 0;
	  this.is_int = /^(\-|\+)?([1-9]+[0-9]*)$/;
	  this.is_float = function(value) {
	    return (value - parseFloat(value) + 1) >= 0;
	  };
	  this.decoder = new StringDecoder();
	  this.buf = '';
	  this.quoting = false;
	  this.commenting = false;
	  this.field = '';
	  this.nextChar = null;
	  this.closingQuote = 0;
	  this.line = [];
	  this.chunks = [];
	  this.rawBuf = '';
	  return this;
	};

	util.inherits(Parser, stream.Transform);

	module.exports.Parser = Parser;

	Parser.prototype._transform = function(chunk, encoding, callback) {
	  var err, error;
	  if (chunk instanceof Buffer) {
	    chunk = this.decoder.write(chunk);
	  }
	  try {
	    this.__write(chunk, false);
	    return callback();
	  } catch (error) {
	    err = error;
	    return this.emit('error', err);
	  }
	};

	Parser.prototype._flush = function(callback) {
	  var err, error;
	  try {
	    this.__write(this.decoder.end(), true);
	    if (this.quoting) {
	      this.emit('error', new Error("Quoted field not terminated at line " + (this.lines + 1)));
	      return;
	    }
	    if (this.line.length > 0) {
	      this.__push(this.line);
	    }
	    return callback();
	  } catch (error) {
	    err = error;
	    return this.emit('error', err);
	  }
	};

	Parser.prototype.__push = function(line) {
	  var field, i, j, len, lineAsColumns, rawBuf, row;
	  if (this.options.skip_lines_with_empty_values && line.join('').trim() === '') {
	    return;
	  }
	  row = null;
	  if (this.options.columns === true) {
	    this.options.columns = line;
	    rawBuf = '';
	    return;
	  } else if (typeof this.options.columns === 'function') {
	    this.options.columns = this.options.columns(line);
	    rawBuf = '';
	    return;
	  }
	  if (!this.line_length && line.length > 0) {
	    this.line_length = this.options.columns ? this.options.columns.length : line.length;
	  }
	  if (line.length === 1 && line[0] === '') {
	    this.empty_line_count++;
	  } else if (line.length !== this.line_length) {
	    if (this.options.relax_column_count) {
	      this.skipped_line_count++;
	    } else if (this.options.columns != null) {
	      throw Error("Number of columns on line " + this.lines + " does not match header");
	    } else {
	      throw Error("Number of columns is inconsistent on line " + this.lines);
	    }
	  } else {
	    this.count++;
	  }
	  if (this.options.columns != null) {
	    lineAsColumns = {};
	    for (i = j = 0, len = line.length; j < len; i = ++j) {
	      field = line[i];
	      if (this.options.columns[i] === false) {
	        continue;
	      }
	      lineAsColumns[this.options.columns[i]] = field;
	    }
	    if (this.options.objname) {
	      row = [lineAsColumns[this.options.objname], lineAsColumns];
	    } else {
	      row = lineAsColumns;
	    }
	  } else {
	    row = line;
	  }
	  if (this.options.raw) {
	    this.push({
	      raw: this.rawBuf,
	      row: row
	    });
	    return this.rawBuf = '';
	  } else {
	    return this.push(row);
	  }
	};

	Parser.prototype.__write = function(chars, end, callback) {
	  var areNextCharsDelimiter, areNextCharsRowDelimiters, auto_parse, char, escapeIsQuote, i, isDelimiter, isEscape, isNextCharAComment, isQuote, isRowDelimiter, is_float, is_int, l, ltrim, nextCharPos, ref, remainingBuffer, results, rowDelimiter, rowDelimiterLength, rtrim, wasCommenting;
	  is_int = (function(_this) {
	    return function(value) {
	      if (typeof _this.is_int === 'function') {
	        return _this.is_int(value);
	      } else {
	        return _this.is_int.test(value);
	      }
	    };
	  })(this);
	  is_float = (function(_this) {
	    return function(value) {
	      if (typeof _this.is_float === 'function') {
	        return _this.is_float(value);
	      } else {
	        return _this.is_float.test(value);
	      }
	    };
	  })(this);
	  auto_parse = (function(_this) {
	    return function(value) {
	      var m;
	      if (_this.options.auto_parse && is_int(_this.field)) {
	        _this.field = parseInt(_this.field);
	      } else if (_this.options.auto_parse && is_float(_this.field)) {
	        _this.field = parseFloat(_this.field);
	      } else if (_this.options.auto_parse && _this.options.auto_parse_date) {
	        m = Date.parse(_this.field);
	        if (!isNaN(m)) {
	          _this.field = new Date(m);
	        }
	      }
	      return _this.field;
	    };
	  })(this);
	  ltrim = this.options.trim || this.options.ltrim;
	  rtrim = this.options.trim || this.options.rtrim;
	  chars = this.buf + chars;
	  l = chars.length;
	  rowDelimiterLength = this.options.rowDelimiter ? this.options.rowDelimiter.length : 0;
	  i = 0;
	  if (this.lines === 0 && 0xFEFF === chars.charCodeAt(0)) {
	    i++;
	  }
	  while (i < l) {
	    if (!end) {
	      remainingBuffer = chars.substr(i, l - i);
	      if ((!this.commenting && l - i < this.options.comment.length && this.options.comment.substr(0, l - i) === remainingBuffer) || (this.options.rowDelimiter && l - i < rowDelimiterLength && this.options.rowDelimiter.substr(0, l - i) === remainingBuffer) || (this.options.rowDelimiter && this.quoting && l - i < (this.options.quote.length + rowDelimiterLength) && (this.options.quote + this.options.rowDelimiter).substr(0, l - i) === remainingBuffer) || (l - i <= this.options.delimiter.length && this.options.delimiter.substr(0, l - i) === remainingBuffer) || (l - i <= this.options.escape.length && this.options.escape.substr(0, l - i) === remainingBuffer)) {
	        break;
	      }
	    }
	    char = this.nextChar ? this.nextChar : chars.charAt(i);
	    this.nextChar = l > i + 1 ? chars.charAt(i + 1) : '';
	    if (this.options.raw) {
	      this.rawBuf += char;
	    }
	    if (this.options.rowDelimiter == null) {
	      if ((!this.quoting) && (char === '\n' || char === '\r')) {
	        rowDelimiter = char;
	        nextCharPos = i + 1;
	      } else if (this.nextChar === '\n' || this.nextChar === '\r') {
	        rowDelimiter = this.nextChar;
	        nextCharPos = i + 2;
	        if (this.raw) {
	          rawBuf += this.nextChar;
	        }
	      }
	      if (rowDelimiter) {
	        if (rowDelimiter === '\r' && chars.charAt(nextCharPos) === '\n') {
	          rowDelimiter += '\n';
	        }
	        this.options.rowDelimiter = rowDelimiter;
	        rowDelimiterLength = this.options.rowDelimiter.length;
	      }
	    }
	    if (!this.commenting && char === this.options.escape) {
	      escapeIsQuote = this.options.escape === this.options.quote;
	      isEscape = this.nextChar === this.options.escape;
	      isQuote = this.nextChar === this.options.quote;
	      if (!(escapeIsQuote && !this.field && !this.quoting) && (isEscape || isQuote)) {
	        i++;
	        char = this.nextChar;
	        this.nextChar = chars.charAt(i + 1);
	        this.field += char;
	        if (this.options.raw) {
	          this.rawBuf += char;
	        }
	        i++;
	        continue;
	      }
	    }
	    if (!this.commenting && char === this.options.quote) {
	      if (this.quoting) {
	        areNextCharsRowDelimiters = this.options.rowDelimiter && chars.substr(i + 1, this.options.rowDelimiter.length) === this.options.rowDelimiter;
	        areNextCharsDelimiter = chars.substr(i + 1, this.options.delimiter.length) === this.options.delimiter;
	        isNextCharAComment = this.nextChar === this.options.comment;
	        if (this.nextChar && !areNextCharsRowDelimiters && !areNextCharsDelimiter && !isNextCharAComment) {
	          if (this.options.relax) {
	            this.quoting = false;
	            this.field = "" + this.options.quote + this.field;
	          } else {
	            throw Error("Invalid closing quote at line " + (this.lines + 1) + "; found " + (JSON.stringify(this.nextChar)) + " instead of delimiter " + (JSON.stringify(this.options.delimiter)));
	          }
	        } else {
	          this.quoting = false;
	          this.closingQuote = this.options.quote.length;
	          i++;
	          if (end && i === l) {
	            this.line.push(auto_parse(this.field));
	            this.field = '';
	          }
	          continue;
	        }
	      } else if (!this.field) {
	        this.quoting = true;
	        i++;
	        continue;
	      } else if (this.field && !this.options.relax) {
	        throw Error("Invalid opening quote at line " + (this.lines + 1));
	      }
	    }
	    isRowDelimiter = this.options.rowDelimiter && chars.substr(i, this.options.rowDelimiter.length) === this.options.rowDelimiter;
	    if (isRowDelimiter || (end && i === l - 1)) {
	      this.lines++;
	    }
	    wasCommenting = false;
	    if (!this.commenting && !this.quoting && this.options.comment && chars.substr(i, this.options.comment.length) === this.options.comment) {
	      this.commenting = true;
	    } else if (this.commenting && isRowDelimiter) {
	      wasCommenting = true;
	      this.commenting = false;
	    }
	    isDelimiter = chars.substr(i, this.options.delimiter.length) === this.options.delimiter;
	    if (!this.commenting && !this.quoting && (isDelimiter || isRowDelimiter)) {
	      if (isRowDelimiter && this.line.length === 0 && this.field === '') {
	        if (wasCommenting || this.options.skip_empty_lines) {
	          i += this.options.rowDelimiter.length;
	          this.nextChar = chars.charAt(i);
	          continue;
	        }
	      }
	      if (rtrim) {
	        if (!this.closingQuote) {
	          this.field = this.field.trimRight();
	        }
	      }
	      this.line.push(auto_parse(this.field));
	      this.closingQuote = 0;
	      this.field = '';
	      if (isDelimiter) {
	        i += this.options.delimiter.length;
	        this.nextChar = chars.charAt(i);
	        if (end && !this.nextChar) {
	          isRowDelimiter = true;
	          this.line.push('');
	        }
	      }
	      if (isRowDelimiter) {
	        this.__push(this.line);
	        this.line = [];
	        i += (ref = this.options.rowDelimiter) != null ? ref.length : void 0;
	        this.nextChar = chars.charAt(i);
	        continue;
	      }
	    } else if (!this.commenting && !this.quoting && (char === ' ' || char === '\t')) {
	      if (!(ltrim && !this.field)) {
	        this.field += char;
	      }
	      if (end && i + 1 === l) {
	        if (this.options.trim || this.options.rtrim) {
	          this.field = this.field.trimRight();
	        }
	      }
	      i++;
	    } else if (!this.commenting) {
	      this.field += char;
	      i++;
	    } else {
	      i++;
	    }
	    if (!this.commenting && this.field.length > this.options.max_limit_on_data_read) {
	      throw Error("Delimiter not found in the file " + (JSON.stringify(this.options.delimiter)));
	    }
	    if (!this.commenting && this.line.length > this.options.max_limit_on_data_read) {
	      throw Error("Row delimiter not found in the file " + (JSON.stringify(this.options.rowDelimiter)));
	    }
	  }
	  if (end) {
	    if (rtrim) {
	      if (!this.closingQuote) {
	        this.field = this.field.trimRight();
	      }
	    }
	    if (this.field !== '') {
	      this.line.push(auto_parse(this.field));
	      this.field = '';
	    }
	    if (this.field.length > this.options.max_limit_on_data_read) {
	      throw Error("Delimiter not found in the file " + (JSON.stringify(this.options.delimiter)));
	    }
	    if (l === 0) {
	      this.lines++;
	    }
	    if (this.line.length > this.options.max_limit_on_data_read) {
	      throw Error("Row delimiter not found in the file " + (JSON.stringify(this.options.rowDelimiter)));
	    }
	  }
	  this.buf = '';
	  results = [];
	  while (i < l) {
	    this.buf += chars.charAt(i);
	    results.push(i++);
	  }
	  return results;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(2)))

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.9.2
	var Transformer, stream, util,
	  slice = [].slice;

	stream = __webpack_require__(13);

	util = __webpack_require__(10);

	module.exports = function() {
	  var argument, callback, data, error, handler, i, j, k, len, options, result, transform, type, v;
	  options = {};
	  for (i = j = 0, len = arguments.length; j < len; i = ++j) {
	    argument = arguments[i];
	    type = typeof argument;
	    if (argument === null) {
	      type = 'null';
	    } else if (type === 'object' && Array.isArray(argument)) {
	      type = 'array';
	    }
	    if (i === 0) {
	      if (type === 'function') {
	        handler = argument;
	      } else if (type !== null) {
	        data = argument;
	      }
	      continue;
	    }
	    if (type === 'object') {
	      for (k in argument) {
	        v = argument[k];
	        options[k] = v;
	      }
	    } else if (type === 'function') {
	      if (handler && i === arguments.length - 1) {
	        callback = argument;
	      } else {
	        handler = argument;
	      }
	    } else if (type !== 'null') {
	      throw new Error('Invalid arguments');
	    }
	  }
	  transform = new Transformer(options, handler);
	  error = false;
	  if (data) {
	    process.nextTick(function() {
	      var l, len1, row;
	      for (l = 0, len1 = data.length; l < len1; l++) {
	        row = data[l];
	        if (error) {
	          break;
	        }
	        transform.write(row);
	      }
	      return transform.end();
	    });
	  }
	  if (callback || options.consume) {
	    result = [];
	    transform.on('readable', function() {
	      var r, results;
	      results = [];
	      while ((r = transform.read())) {
	        results.push(result.push(r));
	      }
	      return results;
	    });
	    transform.on('error', function(err) {
	      error = true;
	      if (callback) {
	        return callback(err);
	      }
	    });
	    transform.on('end', function() {
	      if (callback && !error) {
	        return callback(null, result);
	      }
	    });
	  }
	  return transform;
	};

	Transformer = function(options1, transform1) {
	  var base;
	  this.options = options1 != null ? options1 : {};
	  this.transform = transform1;
	  this.options.objectMode = true;
	  if ((base = this.options).parallel == null) {
	    base.parallel = 100;
	  }
	  stream.Transform.call(this, this.options);
	  this.running = 0;
	  this.started = 0;
	  this.finished = 0;
	  return this;
	};

	util.inherits(Transformer, stream.Transform);

	module.exports.Transformer = Transformer;

	Transformer.prototype._transform = function(chunk, encoding, cb) {
	  var err;
	  this.started++;
	  this.running++;
	  if (this.running < this.options.parallel) {
	    cb();
	    cb = null;
	  }
	  try {
	    if (this.transform.length === 2) {
	      this.transform.call(null, chunk, (function(_this) {
	        return function() {
	          var chunks, err;
	          err = arguments[0], chunks = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	          return _this._done(err, chunks, cb);
	        };
	      })(this));
	    } else {
	      this._done(null, [this.transform.call(null, chunk)], cb);
	    }
	    return false;
	  } catch (_error) {
	    err = _error;
	    return this._done(err);
	  }
	};

	Transformer.prototype._flush = function(cb) {
	  this._ending = function() {
	    if (this.running === 0) {
	      return cb();
	    }
	  };
	  return this._ending();
	};

	Transformer.prototype._done = function(err, chunks, cb) {
	  var chunk, j, len;
	  this.running--;
	  if (err) {
	    return this.emit('error', err);
	  }
	  this.finished++;
	  for (j = 0, len = chunks.length; j < len; j++) {
	    chunk = chunks[j];
	    if (typeof chunk === 'number') {
	      chunk = "" + chunk;
	    }
	    if (chunk != null) {
	      this.push(chunk);
	    }
	  }
	  if (cb) {
	    cb();
	  }
	  if (this._ending) {
	    return this._ending();
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.9.2
	var Stringifier, stream, util;

	stream = __webpack_require__(13);

	util = __webpack_require__(10);

	module.exports = function() {
	  var callback, chunks, data, options, stringifier;
	  if (arguments.length === 3) {
	    data = arguments[0];
	    options = arguments[1];
	    callback = arguments[2];
	  } else if (arguments.length === 2) {
	    if (Array.isArray(arguments[0])) {
	      data = arguments[0];
	    } else {
	      options = arguments[0];
	    }
	    if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	    } else {
	      options = arguments[1];
	    }
	  } else if (arguments.length === 1) {
	    if (typeof arguments[0] === 'function') {
	      callback = arguments[0];
	    } else if (Array.isArray(arguments[0])) {
	      data = arguments[0];
	    } else {
	      options = arguments[0];
	    }
	  }
	  if (options == null) {
	    options = {};
	  }
	  stringifier = new Stringifier(options);
	  if (data) {
	    process.nextTick(function() {
	      var d, j, len;
	      for (j = 0, len = data.length; j < len; j++) {
	        d = data[j];
	        stringifier.write(d);
	      }
	      return stringifier.end();
	    });
	  }
	  if (callback) {
	    chunks = [];
	    stringifier.on('readable', function() {
	      var chunk, results;
	      results = [];
	      while (chunk = stringifier.read()) {
	        results.push(chunks.push(chunk));
	      }
	      return results;
	    });
	    stringifier.on('error', function(err) {
	      return callback(err);
	    });
	    stringifier.on('end', function() {
	      return callback(null, chunks.join(''));
	    });
	  }
	  return stringifier;
	};

	Stringifier = function(options) {
	  var base, base1, base2, base3, base4, base5, base6, base7, base8;
	  if (options == null) {
	    options = {};
	  }
	  stream.Transform.call(this, options);
	  this.options = options;
	  if ((base = this.options).delimiter == null) {
	    base.delimiter = ',';
	  }
	  if ((base1 = this.options).quote == null) {
	    base1.quote = '"';
	  }
	  if ((base2 = this.options).quoted == null) {
	    base2.quoted = false;
	  }
	  if ((base3 = this.options).quotedString == null) {
	    base3.quotedString = false;
	  }
	  if ((base4 = this.options).eof == null) {
	    base4.eof = true;
	  }
	  if ((base5 = this.options).escape == null) {
	    base5.escape = '"';
	  }
	  if ((base6 = this.options).columns == null) {
	    base6.columns = null;
	  }
	  if ((base7 = this.options).header == null) {
	    base7.header = false;
	  }
	  if ((base8 = this.options).rowDelimiter == null) {
	    base8.rowDelimiter = '\n';
	  }
	  if (this.countWriten == null) {
	    this.countWriten = 0;
	  }
	  switch (this.options.rowDelimiter) {
	    case 'auto':
	      this.options.rowDelimiter = null;
	      break;
	    case 'unix':
	      this.options.rowDelimiter = "\n";
	      break;
	    case 'mac':
	      this.options.rowDelimiter = "\r";
	      break;
	    case 'windows':
	      this.options.rowDelimiter = "\r\n";
	      break;
	    case 'unicode':
	      this.options.rowDelimiter = "\u2028";
	  }
	  return this;
	};

	util.inherits(Stringifier, stream.Transform);

	module.exports.Stringifier = Stringifier;

	Stringifier.prototype.headers = function() {
	  var k, label, labels;
	  if (!this.options.header) {
	    return;
	  }
	  if (!this.options.columns) {
	    return;
	  }
	  labels = this.options.columns;
	  if (typeof labels === 'object') {
	    labels = (function() {
	      var results;
	      results = [];
	      for (k in labels) {
	        label = labels[k];
	        results.push(label);
	      }
	      return results;
	    })();
	  }
	  if (this.options.eof) {
	    labels = this.stringify(labels) + this.options.rowDelimiter;
	  } else {
	    labels = this.stringify(labels);
	  }
	  return stream.Transform.prototype.write.call(this, labels);
	};

	Stringifier.prototype.end = function(chunk, encoding, callback) {
	  if (this.countWriten === 0) {
	    this.headers();
	  }
	  return stream.Transform.prototype.end.apply(this, arguments);
	};

	Stringifier.prototype.write = function(chunk, encoding, callback) {
	  var base, e, preserve;
	  if (chunk == null) {
	    return;
	  }
	  preserve = typeof chunk !== 'object';
	  if (!preserve) {
	    if (this.countWriten === 0 && !Array.isArray(chunk)) {
	      if ((base = this.options).columns == null) {
	        base.columns = Object.keys(chunk);
	      }
	    }
	    try {
	      this.emit('record', chunk, this.countWriten);
	    } catch (_error) {
	      e = _error;
	      return this.emit('error', e);
	    }
	    if (this.options.eof) {
	      chunk = this.stringify(chunk) + this.options.rowDelimiter;
	    } else {
	      chunk = this.stringify(chunk);
	      if (this.options.header || this.countWriten) {
	        chunk = this.options.rowDelimiter + chunk;
	      }
	    }
	  }
	  if (typeof chunk === 'number') {
	    chunk = "" + chunk;
	  }
	  if (this.countWriten === 0) {
	    this.headers();
	  }
	  if (!preserve) {
	    this.countWriten++;
	  }
	  return stream.Transform.prototype.write.call(this, chunk, encoding, callback);
	};

	Stringifier.prototype._transform = function(chunk, encoding, callback) {
	  this.push(chunk);
	  return callback();
	};

	Stringifier.prototype.stringify = function(line) {
	  var _line, column, columns, containsLinebreak, containsQuote, containsdelimiter, delimiter, escape, field, i, j, l, newLine, quote, ref, ref1, regexp;
	  if (typeof line !== 'object') {
	    return line;
	  }
	  columns = this.options.columns;
	  if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
	    columns = Object.keys(columns);
	  }
	  delimiter = this.options.delimiter;
	  quote = this.options.quote;
	  escape = this.options.escape;
	  if (!Array.isArray(line)) {
	    _line = [];
	    if (columns) {
	      for (i = j = 0, ref = columns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	        column = columns[i];
	        _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
	      }
	    } else {
	      for (column in line) {
	        _line.push(line[column]);
	      }
	    }
	    line = _line;
	    _line = null;
	  } else if (columns) {
	    line.splice(columns.length);
	  }
	  if (Array.isArray(line)) {
	    newLine = '';
	    for (i = l = 0, ref1 = line.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
	      field = line[i];
	      if (typeof field === 'string') {

	      } else if (typeof field === 'number') {
	        field = '' + field;
	      } else if (typeof field === 'boolean') {
	        field = field ? '1' : '';
	      } else if (field instanceof Date) {
	        field = '' + field.getTime();
	      } else if (typeof field === 'object' && field !== null) {
	        field = JSON.stringify(field);
	      }
	      if (field) {
	        containsdelimiter = field.indexOf(delimiter) >= 0;
	        containsQuote = field.indexOf(quote) >= 0;
	        containsLinebreak = field.indexOf('\r') >= 0 || field.indexOf('\n') >= 0;
	        if (containsQuote) {
	          regexp = new RegExp(quote, 'g');
	          field = field.replace(regexp, escape + quote);
	        }
	        if (containsQuote || containsdelimiter || containsLinebreak || this.options.quoted || (this.options.quotedString && typeof line[i] === 'string')) {
	          field = quote + field + quote;
	        }
	        newLine += field;
	      } else if (this.options.quotedEmpty || ((this.options.quotedEmpty == null) && line[i] === '' && this.options.quotedString)) {
	        newLine += quote + quote;
	      }
	      if (i !== line.length - 1) {
	        newLine += delimiter;
	      }
	    }
	    line = newLine;
	  }
	  return line;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var errors = __webpack_require__(105);


	///--- Globals

	var BadRequestError = errors.BadRequestError;
	var PreconditionFailedError = errors.PreconditionFailedError;

	var IF_MATCH_FAIL = 'if-match \'%s\' didn\'t match etag \'%s\'';
	var IF_NO_MATCH_FAIL = 'if-none-match \'%s\' matched etag \'%s\'';
	var IF_MOD_FAIL = 'object was modified at \'%s\'; if-modified-since \'%s\'';
	var IF_UNMOD_FAIL = 'object was modified at \'%s\'; if-unmodified-since \'%s\'';


	///--- API
	// Reference RFC2616 section 14 for an explanation of what this all does.

	function checkIfMatch(req, res, next) {
	    var clientETags;
	    var cur;
	    var etag = res.etag || res.getHeader('etag') || '';
	    var ifMatch;
	    var matched = false;

	    if ((ifMatch = req.headers['if-match'])) {

	        clientETags = ifMatch.split(/\s*,\s*/);

	        for (var i = 0; i < clientETags.length; i++) {
	            cur = clientETags[i];

	            // only strong comparison

	            cur = cur.replace(/^W\//, '');
	            cur = cur.replace(/^"(\w*)"$/, '$1');

	            if (cur === '*' || cur === etag) {
	                matched = true;
	                break;
	            }
	        }

	        if (!matched) {
	            var err = new PreconditionFailedError(IF_MATCH_FAIL,
	                ifMatch,
	                etag);
	            return (next(err));
	        }
	    }

	    return (next());
	}


	function checkIfNoneMatch(req, res, next) {
	    var clientETags;
	    var cur;
	    var etag = res.etag || res.getHeader('etag') || '';
	    var ifNoneMatch;
	    var matched = false;

	    if ((ifNoneMatch = req.headers['if-none-match'])) {

	        clientETags = ifNoneMatch.split(/\s*,\s*/);

	        for (var i = 0; i < clientETags.length; i++) {
	            cur = clientETags[i];

	            // ignore weak validation
	            cur = cur.replace(/^W\//, '');
	            cur = cur.replace(/^"(\w*)"$/, '$1');

	            if (cur === '*' || cur === etag) {
	                matched = true;
	                break;
	            }
	        }

	        if (!matched) {
	            return (next());
	        }

	        if (req.method !== 'GET' && req.method !== 'HEAD') {
	            var err = new PreconditionFailedError(IF_NO_MATCH_FAIL,
	                ifNoneMatch,
	                etag);
	            return (next(err));
	        }

	        res.send(304);
	        return (next(false));
	    }

	    return (next());
	}


	function checkIfModified(req, res, next) {
	    var code;
	    var err;
	    var ctime = req.header('if-modified-since');
	    var mtime = res.mtime || res.header('Last-Modified') || '';

	    if (!mtime || !ctime) {
	        next();
	        return;
	    }

	    try {
	        //
	        // TODO handle Range header modifications
	        //
	        // Note: this is not technically correct as per 2616 -
	        // 2616 only specifies semantics for GET requests, not
	        // any other method - but using if-modified-since with a
	        // PUT or DELETE seems like returning 412 is sane
	        //
	        if (Date.parse(mtime) <= Date.parse(ctime)) {
	            switch (req.method) {
	                case 'GET':
	                case 'HEAD':
	                    code = 304;
	                    break;

	                default:
	                    err = new PreconditionFailedError(IF_MOD_FAIL,
	                        mtime,
	                        ctime);
	                    break;
	            }
	        }
	    } catch (e) {
	        next(new BadRequestError(e.message));
	        return;
	    }

	    if (code !== undefined) {
	        res.send(code);
	        next(false);
	        return;
	    }

	    next(err);
	}


	function checkIfUnmodified(req, res, next) {
	    var err;
	    var ctime = req.headers['if-unmodified-since'];
	    var mtime = res.mtime || res.header('Last-Modified') || '';

	    if (!mtime || !ctime) {
	        next();
	        return;
	    }

	    try {
	        if (Date.parse(mtime) > Date.parse(ctime)) {
	            err = new PreconditionFailedError(IF_UNMOD_FAIL,
	                mtime,
	                ctime);
	        }
	    } catch (e) {
	        next(new BadRequestError(e.message));
	        return;
	    }

	    next(err);
	}


	///--- Exports

	/**
	 * Returns a set of plugins that will compare an already set ETag header with
	 * the client's If-Match and If-None-Match header, and an already set
	 * Last-Modified header with the client's If-Modified-Since and
	 * If-Unmodified-Since header.
	 * @public
	 * @throws {BadRequestError | PreconditionFailedError}
	 * @function conditionalRequest
	 * @returns  {Array}
	 */
	function conditionalRequest() {
	    var chain = [
	        checkIfMatch,
	        checkIfNoneMatch,
	        checkIfModified,
	        checkIfUnmodified
	    ];
	    return (chain);
	}

	module.exports = conditionalRequest;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);

	var errors = __webpack_require__(105);


	///--- Globals

	var InvalidHeaderError = errors.InvalidHeaderError;
	var RequestExpiredError = errors.RequestExpiredError;

	var BAD_MSG = 'Date header is invalid';
	var OLD_MSG = 'Date header %s is too old';


	///--- API

	/**
	 * Returns a plugin that will parse the Date header (if present) and check for
	 * an "expired" request, where expired means the request originated at a time
	 * before ($now - $clockSkew). The default clockSkew allowance is 5m (thanks
	 * Kerberos!)
	 * @public
	 * @function dateParser
	 * @throws   {RequestExpiredError | InvalidHeaderError}
	 * @param    {Number}    clockSkew optional age of time (in seconds).
	 * @returns  {Function}            restify handler.
	 */
	function dateParser(clockSkew) {
	    if (!clockSkew) {
	        clockSkew = 300;
	    }
	    assert.number(clockSkew, 'clockSkew');

	    clockSkew = clockSkew * 1000;

	    function parseDate(req, res, next) {
	        if (!req.headers.date) {
	            return (next());
	        }

	        var e;
	        var date = req.headers.date;
	        var log = req.log;

	        try {
	            var now = Date.now();
	            var sent = new Date(date).getTime();

	            if (log.trace()) {
	                log.trace({
	                    allowedSkew: clockSkew,
	                    now: now,
	                    sent: sent
	                }, 'Checking clock skew');
	            }

	            if ((now - sent) > clockSkew) {
	                e = new RequestExpiredError(OLD_MSG, date);
	                return (next(e));
	            }


	        } catch (err) {
	            log.trace({
	                err: err
	            }, 'Bad Date header: %s', date);

	            e = new InvalidHeaderError(BAD_MSG, date);
	            return (next(e));
	        }

	        return (next());
	    }

	    return (parseDate);
	}

	module.exports = dateParser;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var qs = __webpack_require__(231);


	///--- API

	/**
	 * parses the jsonp callback out of the request.
	 * @public
	 * @function jsonp
	 * @returns  {Function}
	 */
	function jsonp() {
	    function _jsonp(req, res, next) {
	        var q = req.getQuery();

	        // If the query plugin wasn't used, we need to hack it in now
	        if (typeof (q) === 'string') {
	            req.query = qs.parse(q);
	        }

	        if (req.query.callback || req.query.jsonp) {
	            res.setHeader('Content-Type', 'application/javascript');
	        }

	        next();
	    }

	    return (_jsonp);
	}


	module.exports = jsonp;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);

	var shallowCopy = __webpack_require__(3).shallowCopy;


	///--- API

	/**
	 * attaches bunyan logger to the request.
	 * @public
	 * @function requestLogger
	 * @param    {Object}   options an options object
	 * @returns  {Function}
	 */
	function requestLogger(options) {
	    assert.optionalObject(options);
	    options = options || {};

	    var props;

	    if (options.properties) {
	        props = shallowCopy(options.properties);
	    } else {
	        props = {};
	    }

	    if (options.serializers) {
	        props.serializers = options.serializers;
	    }

	    var headersToCopy = options.headers || [];

	    return function bunyan(req, res, next) {
	        if (!req.log && !options.log) {
	            next();
	            return;
	        }

	        var log = req.log || options.log;

	        props.req_id = req.getId();
	        headersToCopy.forEach(function (k) {

	            if (req.headers[k]) {
	                props[k] = req.headers[k];
	            }
	        });
	        req.log = log.child(props, props.serializers ? false : true);

	        if (props.req_id) {
	            delete props.req_id;
	        }

	        next();
	    };
	}


	///--- Exports

	module.exports = requestLogger;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var zlib = __webpack_require__(116);

	var assert = __webpack_require__(4);


	function _writeHead(originalFunction) {
	    this.removeHeader('Content-Length');
	    originalFunction.apply(this, Array.prototype.slice.call(arguments, 1));
	}

	///--- API

	/**
	 * gzips the response.
	 * https://github.com/restify/node-restify/issues/284
	 * @public
	 * @function gzipResponse
	 * @param   {Object}   opts an options object
	 * @returns {Function}
	 */
	function gzipResponse(opts) {
	    assert.optionalObject(opts, 'options');

	    function gzip(req, res, next) {
	        if (!req.acceptsEncoding('gzip')) {
	            next();
	            return;
	        }

	        var gz = zlib.createGzip(opts);

	        gz.on('data', res.write.bind(res));
	        gz.once('end', res.end.bind(res));
	        gz.on('drain', res.emit.bind(res, 'drain'));

	        var origWrite = res.write;
	        var origEnd = res.end;
	        var origWriteHead = res.writeHead;
	        res.handledGzip = function _handledGzip() {
	            res.write = origWrite;
	            res.end = origEnd;
	            res.writeHead = origWriteHead;
	        };

	        res.write = gz.write.bind(gz);
	        res.end = gz.end.bind(gz);

	        res.writeHead = _writeHead.bind(res, res.writeHead);
	        res.setHeader('Content-Encoding', 'gzip');
	        next();
	    }

	    return (gzip);
	}


	///--- Exports

	module.exports = gzipResponse;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var crypto = __webpack_require__(59);

	var httpDate = __webpack_require__(208);


	///--- Globals

	var ALLOW_HEADERS = [
	    'Accept',
	    'Accept-Version',
	    'Content-Length',
	    'Content-MD5',
	    'Content-Type',
	    'Date',
	    'Api-Version',
	    'Response-Time'
	].join(', ');

	var EXPOSE_HEADERS = [
	    'Api-Version',
	    'Request-Id',
	    'Response-Time'
	].join(', ');


	///--- API

	function setHeaders(req, res) {
	    var hash;
	    var now = new Date();
	    var methods;

	    if (!res.getHeader('Access-Control-Allow-Origin')) {
	        res.setHeader('Access-Control-Allow-Origin', '*');
	    }

	    if (!res.getHeader('Access-Control-Allow-Headers')) {
	        res.setHeader('Access-Control-Allow-Headers', ALLOW_HEADERS);
	    }

	    if (!res.getHeader('Access-Control-Allow-Methods')) {
	        if (res.methods && res.methods.length > 0) {
	            methods = res.methods.join(', ');
	            res.setHeader('Access-Control-Allow-Methods', methods);
	        }
	    }

	    if (!res.getHeader('Access-Control-Expose-Headers')) {
	        res.setHeader('Access-Control-Expose-Headers', EXPOSE_HEADERS);
	    }

	    if (!res.getHeader('Connection')) {
	        res.setHeader('Connection',
	            req.isKeepAlive() ? 'Keep-Alive' : 'close');
	    }

	    if (res._data && !res.getHeader('Content-MD5')) {
	        hash = crypto.createHash('md5');
	        hash.update(res._data);
	        res.setHeader('Content-MD5', hash.digest('base64'));
	    }

	    if (!res.getHeader('Date')) {
	        res.setHeader('Date', httpDate(now));
	    }

	    if (res.etag && !res.getHeader('Etag')) {
	        res.setHeader('Etag', res.etag);
	    }

	    if (!res.getHeader('Server')) {
	        res.setHeader('Server', res.serverName);
	    }

	    if (res.version && !res.getHeader('Api-Version')) {
	        res.setHeader('Api-Version', res.version);
	    }

	    if (!res.getHeader('Request-Id')) {
	        res.setHeader('Request-Id', req.getId());
	    }

	    if (!res.getHeader('Response-Time')) {
	        res.setHeader('Response-Time', now.getTime() - req._time);
	    }

	}


	/**
	 * handles disappeared CORS headers.
	 * https://github.com/restify/node-restify/issues/284
	 * @public
	 * @function fullResponse
	 * @returns  {Function}
	 */
	function fullResponse() {
	    function restifyResponseHeaders(req, res, next) {
	        res.once('header', function () {

	            // Restify 1.0 compatibility
	            if (res.defaultResponseFormatters) {
	                res.defaultResponseFormatters(res._data);
	            }

	            res.emit('beforeSend', res._data, res._body);

	            // end backwards-compatibility
	            return (setHeaders(req, res));
	        });

	        return (next());
	    }

	    return (restifyResponseHeaders);
	}


	///--- Exports

	module.exports = fullResponse;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var qs = __webpack_require__(231);
	var assert = __webpack_require__(4);

	var EXPOSED_QS_OPTIONS = {
	    allowDots: assert.optionalBool,
	    arrayLimit: assert.optionalNumber,
	    depth: assert.optionalNumber,
	    parameterLimit: assert.optionalNumber,
	    parseArrays: assert.optionalBool,
	    plainObjects: assert.optionalBool,
	    strictNullHandling: assert.optionalBool

	    /*
	     * Exclusions (`qs.parse` options that restify does NOT expose):
	     * - `allowPrototypes`: It is strongly suggested against in qs docs.
	     * - `decoder`
	     * - `delimiter`: For query string parsing we shouldn't support anything
	     *   but the default '&'.
	     */
	};

	/**
	 * Returns a plugin that will parse the query string, and merge the results
	 * into req.query.
	 *
	 * Unless options.mapParams is false, they will also be mapped into req.params.
	 * @public
	 * @function queryParser
	 * @param    {Object}   options an options object
	 * @returns  {Function}
	 */
	function queryParser(options) {
	    if (!options) {
	        options = {};
	    }
	    assert.object(options, 'options');

	    /*
	     * Releases of restify 4.x up to 4.1.1 used qs@3 which effectively defaulted
	     * to `plainObjects=true` and `allowDots=true`. To maintain backward
	     * compatibility for the restify 4.x stream while using the latest qs
	     * version, we need to maintain those defaults. Note that restify-plugins
	     * changes back to the pre-restify-4.x behaviour. See test/query.test.js
	     * for more details.
	     */
	    var qsOptions = {
	        plainObjects: true,
	        allowDots: true
	    };
	    Object.keys(EXPOSED_QS_OPTIONS).forEach(function (k) {
	        EXPOSED_QS_OPTIONS[k](options[k], k); // assert type of this option

	        if (options.hasOwnProperty(k)) {
	            qsOptions[k] = options[k];
	        }
	    });

	    function parseQueryString(req, res, next) {
	        if (!req.getQuery()) {
	            req.query = {};
	            return (next());
	        }

	        req.query = qs.parse(req.getQuery(), qsOptions);

	        if (options.mapParams !== false) {
	            Object.keys(req.query).forEach(function (k) {
	                if (req.params[k] && !options.overrideParams) {
	                    return (false);
	                }

	                req.params[k] = req.query[k];
	                return (true);
	            });
	        }

	        return (next());
	    }

	    return (parseQueryString);
	}

	module.exports = queryParser;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assert = __webpack_require__(4);
	var GatewayTimeoutError = __webpack_require__(105).GatewayTimeoutError;

	/**
	 * A request expiry will use the headers to tell if the
	 * incoming request has expired or not.  The header is
	 * expected to be in absolute time since the epoch.
	 * @public
	 * @function requestExpiry
	 * @param    {Object} options        an options object
	 * @param    {String} options.header The header key to be used for
	 *                                   the expiry time of each request.
	 * @returns  {Function}
	 */
	function requestExpiry(options) {
	    assert.object(options, 'options');
	    assert.string(options.header, 'options.header');
	    var headerKey = options.header;

	    return function (req, res, next) {
	        var expiry = req.headers[headerKey];

	        if (expiry) {
	            var expiryTime = Number(expiry);

	            // The request has expired
	            if (Date.now() > expiryTime) {
	                return next(new GatewayTimeoutError('Request has expired'));
	            }
	        }

	        // Happy case
	        return next();
	    };
	}

	module.exports = requestExpiry;


/***/ },
/* 261 */
/***/ function(module, exports) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Helpers


	/**
	 * Cleans up sloppy URLs on the request object, like /foo////bar/// to /foo/bar.
	 * @private
	 * @function strip
	 * @param    {Object} path a url path to clean up
	 * @returns  {String}
	 */
	function strip(path) {
	    var cur;
	    var next;
	    var str = '';

	    for (var i = 0; i < path.length; i++) {
	        cur = path.charAt(i);

	        if (i !== path.length - 1) {
	            next = path.charAt(i + 1);
	        }

	        if (cur === '/' && (next === '/' || (next === '?' && i > 0))) {
	            continue;
	        }

	        str += cur;
	    }

	    return (str);
	}


	/**
	 * @public
	 * @function sanitizePath
	 * @param    {Object}   options an options object
	 * @returns  {Function}
	 */
	function sanitizePath(options) {
	    options = options || {};

	    function _sanitizePath(req, res, next) {
	        req.url = strip(req.url);
	        next();
	    }

	    return (_sanitizePath);
	}


	///--- Exports

	module.exports = sanitizePath;



/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var path = __webpack_require__(39);
	var escapeRE = __webpack_require__(263);

	var assert = __webpack_require__(4);
	var mime = __webpack_require__(100);
	var errors = __webpack_require__(105);


	///--- Globals

	var MethodNotAllowedError = errors.MethodNotAllowedError;
	var NotAuthorizedError = errors.NotAuthorizedError;
	var ResourceNotFoundError = errors.ResourceNotFoundError;


	///--- Functions

	/**
	 * serves static files.
	 * @public
	 * @function serveStatic
	 * @param    {Object} opts an options object
	 * @throws   {MethodNotAllowedError |
	 *            NotAuthorizedError |
	 *            ResourceNotFoundError}
	 * @returns  {Function}
	 */
	function serveStatic(opts) {
	    opts = opts || {};
	    assert.object(opts, 'options');
	    assert.string(opts.directory, 'options.directory');
	    assert.optionalNumber(opts.maxAge, 'options.maxAge');
	    assert.optionalObject(opts.match, 'options.match');
	    assert.optionalString(opts.charSet, 'options.charSet');
	    assert.optionalString(opts.file, 'options.file');

	    var p = path.normalize(opts.directory).replace(/\\/g, '/');
	    var re = new RegExp('^' + escapeRE(p) + '/?.*');

	    function serveFileFromStats(file, err, stats, isGzip, req, res, next) {
	        if (err) {
	            next(new ResourceNotFoundError(err,
	                req.path()));
	            return;
	        } else if (!stats.isFile()) {
	            next(new ResourceNotFoundError('%s does not exist', req.path()));
	            return;
	        }

	        if (res.handledGzip && isGzip) {
	            res.handledGzip();
	        }

	        var fstream = fs.createReadStream(file + (isGzip ? '.gz' : ''));
	        var maxAge = opts.maxAge === undefined ? 3600 : opts.maxAge;
	        fstream.once('open', function (fd) {
	            res.cache({maxAge: maxAge});
	            res.set('Content-Length', stats.size);
	            res.set('Content-Type', mime.lookup(file));
	            res.set('Last-Modified', stats.mtime);

	            if (opts.charSet) {
	                var type = res.getHeader('Content-Type') +
	                    '; charset=' + opts.charSet;
	                res.setHeader('Content-Type', type);
	            }

	            if (opts.etag) {
	                res.set('ETag', opts.etag(stats, opts));
	            }
	            res.writeHead(200);
	            fstream.pipe(res);
	            fstream.once('end', function () {
	                next(false);
	            });
	        });
	    }

	    function serveNormal(file, req, res, next) {
	        fs.stat(file, function (err, stats) {
	            if (!err && stats.isDirectory() && opts.default) {
	                // Serve an index.html page or similar
	                file = path.join(file, opts.default);
	                fs.stat(file, function (dirErr, dirStats) {
	                    serveFileFromStats(file,
	                        dirErr,
	                        dirStats,
	                        false,
	                        req,
	                        res,
	                        next);
	                });
	            } else {
	                serveFileFromStats(file,
	                    err,
	                    stats,
	                    false,
	                    req,
	                    res,
	                    next);
	            }
	        });
	    }

	    function serve(req, res, next) {
	        var file;

	        if (opts.file) {
	            //serves a direct file
	            file = path.join(opts.directory,
	                decodeURIComponent(opts.file));
	        } else {
	            file = path.join(opts.directory,
	                decodeURIComponent(req.path()));
	        }

	        if (req.method !== 'GET' && req.method !== 'HEAD') {
	            next(new MethodNotAllowedError(req.method));
	            return;
	        }

	        if (!re.test(file.replace(/\\/g, '/'))) {
	            next(new NotAuthorizedError(req.path()));
	            return;
	        }

	        if (opts.match && !opts.match.test(file)) {
	            next(new NotAuthorizedError(req.path()));
	            return;
	        }

	        if (opts.gzip && req.acceptsEncoding('gzip')) {
	            fs.stat(file + '.gz', function (err, stats) {
	                if (!err) {
	                    res.setHeader('Content-Encoding', 'gzip');
	                    serveFileFromStats(file,
	                        err,
	                        stats,
	                        true,
	                        req,
	                        res,
	                        next);
	                } else {
	                    serveNormal(file, req, res, next);
	                }
	            });
	        } else {
	            serveNormal(file, req, res, next);
	        }

	    }

	    return (serve);
	}

	module.exports = serveStatic;


/***/ },
/* 263 */
/***/ function(module, exports) {

	
	/**
	 * Escape regexp special characters in `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api public
	 */

	module.exports = function(str){
	  return String(str).replace(/([.*+?=^!:${}()|[\]\/\\])/g, '\\$1');
	};

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage <mcavage@gmail.com> All rights reserved.

	'use strict';

	var sprintf = __webpack_require__(10).format;

	var assert = __webpack_require__(4);
	var LRU = __webpack_require__(54);

	var errors = __webpack_require__(105);


	///--- Globals

	var TooManyRequestsError = errors.TooManyRequestsError;

	var MESSAGE = 'You have exceeded your request rate of %s r/s.';


	///--- Helpers

	function xor() {
	    var x = false;

	    for (var i = 0; i < arguments.length; i++) {
	        if (arguments[i] && !x) {
	            x = true;
	        } else if (arguments[i] && x) {
	            return (false);
	        }
	    }
	    return (x);
	}


	///--- Internal Class (TokenBucket)

	/**
	 * An implementation of the Token Bucket algorithm.
	 *
	 * Basically, in network throttling, there are two "mainstream"
	 * algorithms for throttling requests, Token Bucket and Leaky Bucket.
	 * For restify, I went with Token Bucket.  For a good description of the
	 * algorithm, see: http://en.wikipedia.org/wiki/Token_bucket
	 *
	 * In the options object, you pass in the total tokens and the fill rate.
	 * Practically speaking, this means "allow `fill rate` requests/second,
	 * with bursts up to `total tokens`".  Note that the bucket is initialized
	 * to full.
	 *
	 * Also, in googling, I came across a concise python implementation, so this
	 * is just a port of that. Thanks http://code.activestate.com/recipes/511490 !
	 *
	 * @private
	 * @class
	 * @param {Object} options contains the parameters:
	 *                   - {Number} capacity the maximum burst.
	 *                   - {Number} fillRate the rate to refill tokens.
	 */
	function TokenBucket(options) {
	    assert.object(options, 'options');
	    assert.number(options.capacity, 'options.capacity');
	    assert.number(options.fillRate, 'options.fillRate');

	    this.tokens = this.capacity = options.capacity;
	    this.fillRate = options.fillRate;
	    this.time = Date.now();
	}


	/**
	 * Consume N tokens from the bucket.
	 *
	 * If there is not capacity, the tokens are not pulled from the bucket.
	 *
	 * @private
	 * @function consume
	 * @param    {Number}  tokens the number of tokens to pull out.
	 * @returns  {Boolean}        true if capacity, false otherwise.
	 */
	TokenBucket.prototype.consume = function consume(tokens) {
	    if (tokens <= this._fill()) {
	        this.tokens -= tokens;
	        return (true);
	    }

	    return (false);
	};


	/**
	 * Fills the bucket with more tokens.
	 *
	 * Rather than do some whacky setTimeout() deal, we just approximate refilling
	 * the bucket by tracking elapsed time from the last time we touched the bucket.
	 *
	 * Simply, we set the bucket size to min(totalTokens,
	 *                                       current + (fillRate * elapsed time)).
	 *
	 * @private
	 * @function _fill
	 * @returns  {Number} the current number of tokens in the bucket.
	 */
	TokenBucket.prototype._fill = function _fill() {
	    var now = Date.now();

	    // reset account for clock drift (like DST)
	    if (now < this.time) {
	        this.time = now - 1000;
	    }

	    if (this.tokens < this.capacity) {
	        var delta = this.fillRate * ((now - this.time) / 1000);
	        this.tokens = Math.min(this.capacity, this.tokens + delta);
	    }
	    this.time = now;

	    return (this.tokens);
	};


	///--- Internal Class (TokenTable)
	/**
	 * Just a wrapper over LRU that supports put/get to store token -> bucket
	 * mappings.
	 * @private
	 * @class
	 * @param {Object} options      an options object
	 * @param {Number} options.size size of the LRU
	 */
	function TokenTable(options) {
	    assert.object(options, 'options');

	    this.table = new LRU(options.size || 10000);
	}


	/**
	 * puts a value in the token table
	 * @private
	 * @function put
	 * @param {String}      key   a name
	 * @param {TokenBucket} value a TokenBucket
	 * @returns {undefined}
	 */
	TokenTable.prototype.put = function put(key, value) {
	    this.table.set(key, value);
	};


	/**
	 * puts a value in the token table
	 * @private
	 * @function get
	 * @param {String} key a key
	 * @returns {TokenBucket}
	 */
	TokenTable.prototype.get = function get(key) {
	    return (this.table.get(key));
	};


	///--- Exported API

	/**
	 * Creates an API rate limiter that can be plugged into the standard
	 * restify request handling pipeline.
	 *
	 * This throttle gives you three options on which to throttle:
	 * username, IP address and 'X-Forwarded-For'. IP/XFF is a /32 match,
	 * so keep that in mind if using it.  Username takes the user specified
	 * on req.username (which gets automagically set for supported Authorization
	 * types; otherwise set it yourself with a filter that runs before this).
	 *
	 * In both cases, you can set a `burst` and a `rate` (in requests/seconds),
	 * as an integer/float.  Those really translate to the `TokenBucket`
	 * algorithm, so read up on that (or see the comments above...).
	 *
	 * In either case, the top level options burst/rate set a blanket throttling
	 * rate, and then you can pass in an `overrides` object with rates for
	 * specific users/IPs.  You should use overrides sparingly, as we make a new
	 * TokenBucket to track each.
	 *
	 * On the `options` object ip and username are treated as an XOR.
	 *
	 * An example options object with overrides:
	 *
	 *  {
	 *    burst: 10,  // Max 10 concurrent requests (if tokens)
	 *    rate: 0.5,  // Steady state: 1 request / 2 seconds
	 *    ip: true,   // throttle per IP
	 *    overrides: {
	 *      '192.168.1.1': {
	 *        burst: 0,
	 *        rate: 0    // unlimited
	 *    }
	 *  }
	 *
	 * @public
	 * @function throttle
	 * @throws   {TooManyRequestsError}
	 * @param    {Object}    options required options with:
	 *                   - {Number} burst (required).
	 *                   - {Number} rate (required).
	 *                   - {Boolean} ip (optional).
	 *                   - {Boolean} username (optional).
	 *                   - {Boolean} xff (optional).
	 *                   - {Object} overrides (optional).
	 *                   - {Object} tokensTable: a storage engine this plugin will
	 *                              use to store throttling keys -> bucket mappings.
	 *                              If you don't specify this, the default is to
	 *                              use an in-memory O(1) LRU, with 10k distinct
	 *                              keys.  Any implementation just needs to support
	 *                              put/get.
	 *                   - {Number} maxKeys: If using the default implementation,
	 *                              you can specify how large you want the table to
	 *                              be.  Default is 10000.
	 * @returns  {Function}
	 */
	function throttle(options) {
	    assert.object(options, 'options');
	    assert.number(options.burst, 'options.burst');
	    assert.number(options.rate, 'options.rate');

	    if (!xor(options.ip, options.xff, options.username)) {
	        throw new Error('(ip ^ username ^ xff)');
	    }

	    var table = options.tokensTable ||
	        new TokenTable({size: options.maxKeys});

	    function rateLimit(req, res, next) {
	        var attr;
	        var burst = options.burst;
	        var rate = options.rate;

	        if (options.ip) {
	            attr = req.connection.remoteAddress;
	        } else if (options.xff) {
	            attr = req.headers['x-forwarded-for'];
	        } else if (options.username) {
	            attr = req.username;
	        } else {
	            req.log.warn({config: options},
	                'Invalid throttle configuration');
	            return (next());
	        }

	        // Before bothering with overrides, see if this request
	        // even matches
	        if (!attr) {
	            return (next());
	        }

	        // Check the overrides
	        if (options.overrides &&
	            options.overrides[attr] &&
	            options.overrides[attr].burst !== undefined &&
	            options.overrides[attr].rate !== undefined) {

	            burst = options.overrides[attr].burst;
	            rate = options.overrides[attr].rate;
	        }

	        if (!rate || !burst) {
	            return (next());
	        }

	        var bucket = table.get(attr);

	        if (!bucket) {
	            bucket = new TokenBucket({
	                capacity: burst,
	                fillRate: rate
	            });
	            table.put(attr, bucket);
	        }

	        req.log.trace('Throttle(%s): num_tokens= %d',
	            attr, bucket.tokens);

	        if (!bucket.consume(1)) {
	            req.log.info({
	                address: req.connection.remoteAddress || '?',
	                method: req.method,
	                url: req.url,
	                user: req.username || '?'
	            }, 'Throttling');

	            var msg = sprintf(MESSAGE, rate);
	            return (next(new TooManyRequestsError(msg)));
	        }

	        return (next());
	    }

	    return (rateLimit);
	}

	module.exports = throttle;


/***/ },
/* 265 */
/***/ function(module, exports) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	///--- Helpers

	/**
	 * this pre handler fixes issues with node hanging when an asyncHandler is
	 * used prior to bodyParser.
	 * https://github.com/restify/node-restify/issues/287
	 * https://github.com/restify/node-restify/issues/409
	 * https://github.com/restify/node-restify/wiki/1.4-to-2.0-Migration-Tips
	 * @public
	 * @function pauseStream
	 * @param    {Stream} stream the stream to pause
	 * @returns  {undefined}
	 */
	function pauseStream(stream) {
	    function _buffer(chunk) {
	        stream.__buffered.push(chunk);
	    }

	    function _catchEnd(chunk) {
	        stream.__rstfy_ended = true;
	    }

	    stream.__rstfy_ended = false;
	    stream.__rstfy_paused = true;
	    stream.__buffered = [];
	    stream.on('data', _buffer);
	    stream.once('end', _catchEnd);
	    stream.pause();

	    stream._resume = stream.resume;
	    stream.resume = function _rstfy_resume() {
	        if (!stream.__rstfy_paused) {
	            return;
	        }

	        stream.removeListener('data', _buffer);
	        stream.removeListener('end', _catchEnd);

	        stream.__buffered.forEach(stream.emit.bind(stream, 'data'));
	        stream.__buffered.length = 0;

	        stream._resume();
	        stream.resume = stream._resume;

	        if (stream.__rstfy_ended) {
	            stream.emit('end');
	        }
	    };
	}


	///--- Exports

	module.exports = function pause() {

	    function prePause(req, res, next) {
	        pauseStream(req);
	        next();
	    }

	    return (prePause);
	};


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Mark Cavage, Inc.  All rights reserved.

	'use strict';

	var assert = __webpack_require__(4);


	///--- API

	/**
	 * This basically exists for curl.  curl on HEAD requests usually
	 * just sits there and hangs, unless you explicitly set
	 * Connection:close.  And in general, you probably want to set
	 * Connection: close to curl anyway.
	 *
	 * Also, because curl spits out an annoying message to stderr about
	 * remaining bytes if content-length is set, this plugin also drops
	 * the content-length header (some user agents handle it and want it,
	 * curl does not).
	 *
	 * To be slightly more generic, the options block takes a user
	 * agent regexp, however.
	 * @public
	 * @function userAgentConnection
	 * @param    {Object}   opts an options object
	 * @returns  {Function}
	 */
	function userAgentConnection(opts) {
	    assert.optionalObject(opts, 'options');
	    opts = opts || {};
	    assert.optionalObject(opts.userAgentRegExp, 'options.userAgentRegExp');

	    var re = opts.userAgentRegExp;

	    if (!re) {
	        re = /^curl.+/;
	    }

	    function handleUserAgent(req, res, next) {
	        var ua = req.headers['user-agent'];

	        if (ua && re.test(ua)) {
	            res.setHeader('Connection', 'close');
	        }

	        if (req.method === 'HEAD') {
	            res.once('header',
	                res.removeHeader.bind(res, 'content-length'));
	        }

	        next();
	    }

	    return (handleUserAgent);
	}

	module.exports = userAgentConnection;


/***/ }
/******/ ]);